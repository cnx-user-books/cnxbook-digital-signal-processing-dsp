<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Java1492-Plotting Large Quantities of Data using Java</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m49805</md:content-id>
  <md:title>Java1492-Plotting Large Quantities of Data using Java</md:title>
  <md:abstract>Learn how to use Java to plot millions of multi-channel data values in an easy-to-view format with very little programming effort.</md:abstract>
  <md:uuid>6b9491f9-a9c8-45c4-b1ec-45cb21f600ff</md:uuid>
</metadata>

<content>






<quote id="blockquote1000" display="block">



<para id="p1000">
Revised: Fri Oct 16 23:15:53 CDT 2015

</para>





<para id="p1001">
This page is included in the following books:

</para>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">
<link id="a1000" url="http://cnx.org/contents/98d253c0-8044-4e22-a707-7b8d819bc8a7">


        Digital Signal Processing - DSP

</link>

 

</item>




</list>




</quote>











<section id="h11000">
<title>
<emphasis id="Table_of_contents" effect="bold">

Table of contents

</emphasis>


</title>




<list id="ul1001" list-type="bulleted">

	

<item id="li1001">
<link id="a1001" target-id="Preface">

Preface

</link>


	

<list id="ul1002" list-type="bulleted">

		

<item id="li1002">
<link id="a1002" target-id="Viewing_tip">

Viewing tip

</link>


<list id="ul1003" list-type="bulleted">

			

<item id="li1003">
<link id="a1003" target-id="Figures">

Figures

</link>


</item>


			

<item id="li1004">
<link id="a1004" target-id="Listings">

Listings

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>



	

<item id="li1005">
<link id="a1005" target-id="Preview">

Preview

</link>


<list id="ul1004" list-type="bulleted">

		

<item id="li1006">
<link id="a1006" target-id="Sample_output_for_PlotALot01class">

Sample output for PlotALot01 class

</link>


		

</item>


		

<item id="li1007">
<link id="a1007" target-id="Usage_information">

Usage information

</link>


<list id="ul1005" list-type="bulleted">

			

<item id="li1008">
<link id="a1008" target-id="Plotting_format">

Plotting format

</link>


</item>


			

<item id="li1009">
<link id="a1009" target-id="On_to_the_next_page">

On to the next page

</link>


</item>


		

</list>


		

</item>


		

<item id="li1010">
<link id="a1010" target-id="Sample_output_for_PlotALot02_class">

Sample output for PlotALot02 class

</link>


<list id="ul1006" list-type="bulleted">

			

<item id="li1011">
<link id="a1011" target-id="Superimposed_data">

Superimposed data

</link>


</item>



		

</list>


		

</item>


		

<item id="li1012">
<link id="a1012" target-id="Sample_output_for_PlotALot03_class">

Sample output for PlotALot03 class

</link>


<list id="ul1007" list-type="bulleted">

			

<item id="li1013">
<link id="a1013" target-id="Same_data_two_colors">

Same data, two colors

</link>


</item>


		

</list>


		

</item>


		

<item id="li1014">
<link id="a1014" target-id="Sample_output_for_PlotALot04_class">

Sample output for PlotALot04 class

</link>


<list id="ul1008" list-type="bulleted">

			

<item id="li1015">
<link id="a1015" target-id="Same_data_three_colors">

Same data, three colors

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>



	

<item id="li1016">
<link id="a1016" target-id="Sample_Programs">

Sample programs

</link>


<list id="ul1009" list-type="bulleted">

		

<item id="li1017">
<link id="a1017" target-id="The_class_named_PlotALot01">

The class named PlotALot01

</link>


<list id="ul1010" list-type="bulleted">

		
		
		    

<item id="li1018">
<link id="a1018" target-id="Purpose_of_the_class">

Purpose of the class

</link>


</item>


		    

<item id="li1019">
<link id="a1019" target-id="Usagezzzinformation">

Usage information

</link>


</item>


		
		
			

<item id="li1020">
<link id="a1020" target-id="Different_plotting_objects">

Different plotting objects

</link>


</item>


			

<item id="li1021">
<link id="a1021" target-id="Beginning_of_the_class_named_PlotALot01">

Beginning of 
			the class named PlotALot01

</link>


</item>


			

<item id="li1022">
<link id="a1022" target-id="Feed_the_plotting_object_titled_A">

Feed the plotting 
			object titled "A"

</link>


</item>


			

<item id="li1023">
<link id="a1023" target-id="Plot_the_data">

Plot the data

</link>


</item>


			

<item id="li1024">
<link id="a1024" target-id="Feed_and_plot_the_object_titled_B">

Feed and plot the 
			object titled "B"

</link>


</item>


			

<item id="li1025">
<link id="a1025" target-id="Some_instance_variables">

Some instance variables

</link>


</item>


			

<item id="li1026">
<link id="a1026" target-id="The_first_overloaded_constructor">

The first overloaded 
			constructor

</link>


</item>


			

<item id="li1027">
<link id="a1027" target-id="Save_the_parameter_values">

Save the parameter values

</link>


</item>


			

<item id="li1028">
<link id="a1028" target-id="A_temporary_Page_object">

A temporary Page object

</link>


</item>


			

<item id="li1029">
<link id="a1029" target-id="Display_some_information">

Display some information

</link>


</item>


			

<item id="li1030">
<link id="a1030" target-id="Dispose_of_the_temporary_Page_object">

Dispose of the 
			temporary Page object

</link>


</item>


			

<item id="li1031">

			

<link id="a1031" target-id="Compute_and_display_the_remaining_plotting_parameters">


			Compute and display the remaining plotting parameters

</link>


</item>


			

<item id="li1032">
<link id="a1032" target-id="Instantiate_first_usable_Page_object">

Instantiate 
			first usable Page object

</link>


</item>


			

<item id="li1033">
<link id="a1033" target-id="The_other_overloaded_constructor">

The other overloaded 
			constructor

</link>


</item>


			

<item id="li1034">
<link id="a1034" target-id="The_feedData_method">

The feedData method

</link>


</item>


			

<item id="li1035">
<link id="a1035" target-id="The_MyCanvas_class_a_preview">

The MyCanvas class, a 
			preview

</link>


</item>


			

<item id="li1036">
<link id="a1036" target-id="The_plotData_method">

The plotData method

</link>


</item>


			

<item id="li1037">
<link id="a1037" target-id="Make_all_pages_invisible">

Make all pages invisible

</link>


</item>


			

<item id="li1038">
<link id="a1038" target-id="Make_the_pages_visible_in_reverse_order">

Make the pages visible in reverse order

</link>


</item>


			

<item id="li1039">
<link id="a1039" target-id="The_other_overloaded_version_of_the_plotData_method">

The other overloaded version of the plotData method

</link>


</item>


			

<item id="li1040">
<link id="a1040" target-id="The_Page_class">

The Page class

</link>


</item>


			

<item id="li1041">
<link id="a1041" target-id="An_anonymous_terminator_for_the_Page_class">

An anonymous terminator for the Page class

</link>


</item>


			

<item id="li1042">
<link id="a1042" target-id="The_putData_method_of_the_Page_class">

The putData method of the Page class

</link>


</item>


			

<item id="li1043">
<link id="a1043" target-id="The_MyCanvas_class">

The MyCanvas class

</link>


</item>


			

<item id="li1044">
<link id="a1044" target-id="The_overridden_paint_method">

The overridden paint method

</link>


</item>


			

<item id="li1045">
<link id="a1045" target-id="Plot_the_points">

Plot the points

</link>


</item>


			

<item id="li1046">
<link id="a1046" target-id="Draw_an_oval">

Draw an oval

</link>


</item>


			

<item id="li1047">
<link id="a1047" target-id="Connect_the_points_with_straight_lines">

Connect the points with straight lines

</link>


</item>


			

<item id="li1048">
<link id="a1048" target-id="End_of_the_PlotALot01_class">

End of the PlotALot01 class

</link>


</item>


		

</list>


		

</item>


		

<item id="li1049">
<link id="a1049" target-id="The_class_named_PlotALot02">

The class named PlotALot02

</link>


<list id="ul1011" list-type="bulleted">

			

<item id="li1050">
<link id="a1050" target-id="Designed_for_two-channel_data">

Designed for two-channel data

</link>


</item>


			

<item id="li1051">
<link id="a1051" target-id="The_class_named_PlotALot02_and_the_main_method">

The class named PlotALot02 and the main method

</link>


</item>


			

<item id="li1052">
<link id="a1052" target-id="ThefeedDatamethod">

The feedData method

</link>


</item>


			

<item id="li1053">
<link id="a1053" target-id="The_putData_method">

The putData method

</link>


</item>


			

<item id="li1054">
<link id="a1054" target-id="TheMyCanvasclass">

The MyCanvas class

</link>


</item>


			

<item id="li1055">
<link id="a1055" target-id="Theoverriddenpaintmethod">

The overridden paint method

</link>


</item>


			

<item id="li1056">
<link id="a1056" target-id="New_code_in_the_overridden_paint_method">

New code in the overridden paint method

</link>


</item>


		

</list>


		

</item>


		

<item id="li1057">
<link id="a1057" target-id="The_class_named_PlotALot03">

The class named PlotALot03

</link>


<list id="ul1012" list-type="bulleted">

			

<item id="li1058">
<link id="a1058" target-id="Two-channel_data_on_alternating_axes_">

Two-channel data on alternating axes

</link>

 

</item>


			

<item id="li1059">
<link id="a1059" target-id="Modified_constructor_code">

Modified constructor code

</link>


</item>


			

<item id="li1060">
<link id="a1060" target-id="Thezoverriddenzpaintzmethod">

The overridden paint method

</link>


</item>


		

</list>


</item>


<item id="li1061">

		

<link id="a1061" target-id="The_class_named_PlotALot04">

The class named PlotALot04

</link>


		

<list id="ul1013" list-type="bulleted">

			

<item id="li1062">
<link id="a1062" target-id="Three_steps_for_using_the_class">

Three steps for using the class

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>



	

<item id="li1063">
<link id="a1063" target-id="Run_the_program">

Run the programs

</link>


</item>


	

<item id="li1064">
<link id="a1064" target-id="Summary">

Summary

</link>


</item>


	

<item id="li1065">
<link id="a1065" target-id="Complete_program_listings">

Complete program listings

</link>


</item>



	

<item id="li1066">
<link id="a1066" target-id="Miscellaneous">

Miscellaneous

</link>


</item>





</list>


	
	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	
	

<para id="p1002">
In one of my earlier modules titled
	

<link id="a1067" url="http://cnx.org/contents/b5a14d3a-c54c-4239-b414-bae75d1e8cda/Java1468-Plotting-Engineering-">


	Plotting Engineering and Scientific Data using Java

</link>

, I published a 
	generalized 2D plotting class that makes it easy to cause other programs to 
	display their outputs in 2D
	

<link id="a1068" url="http://mathworld.wolfram.com/CartesianCoordinates.html">

Cartesian 
	coordinates

</link>

. I have used that plotting class in numerous modules since I 
	published it. Hopefully, some of you have been using it as well.

</para>





<para id="p1003">
In another of my earlier modules titled


<link id="a1069" url="http://cnx.org/contents/ea4ac046-e5a6-4503-b6e4-6c2d23b65d57/Java1489-Plotting-3D-Surfaces-">


Plotting 3D Surfaces using Java

</link>

, I presented and explained a 3D surface 
plotting class that is also very easy to use. I have used that class in several 
modules since then, and I will be using it in many future modules as well.

</para>





<para id="p1004">
<emphasis id="strong1000" effect="bold">
<emphasis id="em1000" effect="italics">
Plotting large quantities of data

</emphasis>
</emphasis>
</para>





<para id="p1005">
One of the common requirements of engineering, technical, and scientific 
computing is to be able to plot and to examine very large quantities of data. 
This is particularly true in time-series analysis, spectral analysis, and 
digital signal processing 

<emphasis id="em1001" effect="italics">
(

</emphasis>
<link id="a1070" url="https://en.wikipedia.org/wiki/Digital_signal_processing">


<emphasis id="em1002" effect="italics">
DSP

</emphasis>
</link>

). 
I will present and explain four separate Java classes in this module, which make 
it very easy to plot and to examine large quantities of data in Java programs.

</para>





<para id="p1006">
<emphasis id="strong1001" effect="bold">
<emphasis id="em1003" effect="italics">
How do you use these classes?

</emphasis>
</emphasis>
</para>





<para id="p1007">
All that's necessary to use these classes to plot large quantities of data is 
to:

</para>





<list id="ol1000" list-type="enumerated">

	

<item id="li1067">
Instantiate a plotting object of type 

<emphasis id="strong1002" effect="bold">
PlotALot01

</emphasis>
,
	

<emphasis id="strong1003" effect="bold">
PlotALot02

</emphasis>
, 

<emphasis id="strong1004" effect="bold">
PlotALot03

</emphasis>
 or 

<emphasis id="strong1005" effect="bold">

	PlotALot04

</emphasis>
.

</item>


	

<item id="li1068">
Feed the data values that need to be plotted to the plotting object as 
	they become available.

</item>


	

<item id="li1069">
Call a method named 

<emphasis id="strong1006" effect="bold">
plotData

</emphasis>
 on the plotting object 
	when all of the data has been fed to the object.

</item>




</list>




<para id="p1008">
<emphasis id="strong1007" effect="bold">
<emphasis id="em1004" effect="italics">
It couldn't be easier

</emphasis>
</emphasis>
</para>





<para id="p1009">
The choice among the four classes listed above depends on whether you need to 
plot one, two, or three channels of data, and the format in which you want to 
plot the data. The class named 

<emphasis id="strong1008" effect="bold">
PlotALot01

</emphasis>
 is used to plot 
single-channel data. The classes named 

<emphasis id="strong1009" effect="bold">
PlotALot02

</emphasis>
 and 

<emphasis id="strong1010" effect="bold">

PlotALot03

</emphasis>
 are used to plot two-channel data in two different formats. 
The class named 

<emphasis id="strong1011" effect="bold">
PlotALot04

</emphasis>
 is used to plot three-channel data.

</para>





<para id="p1010">
<emphasis id="strong1012" effect="bold">
<emphasis id="em1005" effect="italics">
A free plotting class

</emphasis>
</emphasis>
</para>





<para id="p1011">
If you arrived at this page seeking a free Java class for plotting your data, 
you are in luck. Just copy the source code for the classes in 

<link id="a1071" target-id="Listing_35">

 Listing 35

</link>

 through 


<link id="a1072" target-id="Listing_38">

 Listing 38

</link>

 near the end of this module and feel free to use them as described in 
the comments in the source code.

</para>





<para id="p1012">
On the other hand, if you would like to learn how the classes do what they 
do, and perhaps use your programming skills to improve them, keep reading. 
Hopefully, once you have finished the module, you will have learned quite a lot 
about plotting large quantities of data using Java.

</para>



	
	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1013">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Figures 
and Listings while you are reading about them.

</para>



	

<section id="h31000">
<title>
<emphasis id="Figures" effect="bold">

Figures

</emphasis>


</title>


	

<list id="ul1014" list-type="bulleted">

		

<item id="li1070">
<link id="a1073" target-id="Figure_1">

Figure 1

</link>

. Sample output for PlotALot01 class.

</item>


		

<item id="li1071">
<link id="a1074" target-id="Figure_2">

Figure 2

</link>

. Sample output for PlotALot02 class.

</item>


		

<item id="li1072">
<link id="a1075" target-id="Figure_3">

Figure 3

</link>

. Sample output for PlotALot03 class.

</item>


		

<item id="li1073">
<link id="a1076" target-id="Figure_4">

Figure 4

</link>

. Sample output for PlotALot04 class.

</item>


		

<item id="li1074">
<link id="a1077" target-id="Figure_5">

Figure 5

</link>

. Self-test output for PlotALot01. 

</item>



	

</list>


	

</section>
<section id="h31001">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1015" list-type="bulleted">

		

<item id="li1075">
<link id="a1078" target-id="Listing_1">

Listing 1

</link>

. Beginning of the class named PlotALot01.

</item>


		

<item id="li1076">
<link id="a1079" target-id="Listing_2">

Listing 2

</link>

. Feed the plotting object titled "A". 

</item>


		

<item id="li1077">
<link id="a1080" target-id="Listing_3">

Listing 3

</link>

. Plot the data. 

</item>


		

<item id="li1078">
<link id="a1081" target-id="Listing_4">

Listing 4

</link>

. Feed and plot the object titled "B". 

</item>


		

<item id="li1079">
<link id="a1082" target-id="Listing_5">

Listing 5

</link>

. Some instance variables. 

</item>


		

<item id="li1080">
<link id="a1083" target-id="Listing_6">

Listing 6

</link>

. The first overloaded constructor. 

</item>


		

<item id="li1081">
<link id="a1084" target-id="Listing_7">

Listing 7

</link>

. Save the parameter values. 

</item>


		

<item id="li1082">
<link id="a1085" target-id="Listing_8">

Listing 8

</link>

. A temporary Page object. 

</item>


		

<item id="li1083">
<link id="a1086" target-id="Listing_9">

Listing 9

</link>

. Display some information.

</item>


		

<item id="li1084">
<link id="a1087" target-id="Listing_10">

Listing 10

</link>

. Dispose of the temporary Page object. 

</item>


		

<item id="li1085">
<link id="a1088" target-id="Listing_11">

Listing 11

</link>

. Compute and display the remaining plotting parameters.

</item>


		

<item id="li1086">
<link id="a1089" target-id="Listing_12">

Listing 12

</link>

. Instantiate first usable Page object.

</item>


		

<item id="li1087">
<link id="a1090" target-id="Listing_13">

Listing 13

</link>

. The other overloaded constructor. 

</item>


		

<item id="li1088">
<link id="a1091" target-id="Listing_14">

Listing 14

</link>

. The feedData method. 

</item>


		

<item id="li1089">
<link id="a1092" target-id="Listing_15">

Listing 15

</link>

. Beginning of the plotData method. 

</item>


		

<item id="li1090">
<link id="a1093" target-id="Listing_16">

Listing 16

</link>

. Make all pages invisible. 

</item>


		

<item id="li1091">
<link id="a1094" target-id="Listing_17">

Listing 17

</link>

. Make the pages visible in reverse order. 

</item>


		

<item id="li1092">
<link id="a1095" target-id="Listing_18">

Listing 18

</link>

. The other overloaded version of the plotData method. 

</item>


		

<item id="li1093">
<link id="a1096" target-id="Listing_19">

Listing 19

</link>

. Beginning of the class named Page. 

</item>


		

<item id="li1094">
<link id="a1097" target-id="Listing_20">

Listing 20

</link>

. An anonymous terminator for the Page class. 

</item>


		

<item id="li1095">
<link id="a1098" target-id="Listing_21">

Listing 21

</link>

. The putData method of the Page class. 

</item>


		

<item id="li1096">
<link id="a1099" target-id="Listing_22">

Listing 22

</link>

. Beginning of the MyCanvas class. 

</item>


		

<item id="li1097">
<link id="a1100" target-id="Listing_23">

Listing 23

</link>

. Beginning of the overridden paint method. 

</item>


		

<item id="li1098">
<link id="a1101" target-id="Listing_24">

Listing 24

</link>

. Beginning of code to plot the points.

</item>


		

<item id="li1099">
<link id="a1102" target-id="Listing_25">

Listing 25

</link>

. Draw an oval. 

</item>


		

<item id="li1100">
<link id="a1103" target-id="Listing_26">

Listing 26

</link>

. Connect the points with straight lines. 

</item>


		

<item id="li1101">
<link id="a1104" target-id="Listing_27">

Listing 27

</link>

. The class named PlotALot02 and the main method. 

</item>


		

<item id="li1102">
<link id="a1105" target-id="Listing_28">

Listing 28

</link>

. The feedData method. 

</item>


		

<item id="li1103">
<link id="a1106" target-id="Listing_29">

Listing 29

</link>

. The putData method. 

</item>


		

<item id="li1104">
<link id="a1107" target-id="Listing_30">

Listing 30

</link>

. Beginning of the MyCanvas class. 

</item>


		

<item id="li1105">
<link id="a1108" target-id="Listing_31">

Listing 31

</link>

. Beginning of the overridden paint method. 

</item>


		

<item id="li1106">
<link id="a1109" target-id="Listing_32">

Listing 32

</link>

. New code in the overridden paint method. 

</item>

		
		

<item id="li1107">
<link id="a1110" target-id="Listing_33">

Listing 33

</link>

. Modified constructor code. 

</item>


		

<item id="li1108">
<link id="a1111" target-id="Listing_34">

Listing 34

</link>

. The overridden paint method. 

</item>


		

<item id="li1109">
<link id="a1112" target-id="Listing_35">

Listing 35

</link>

. PlotALot01.java. 

</item>


		

<item id="li1110">
<link id="a1113" target-id="Listing_36">

Listing 36

</link>

. PlotALot02.java. 

</item>


		

<item id="li1111">
<link id="a1114" target-id="Listing_37">

Listing 37

</link>

. PlotALot03.java. 

</item>


		

<item id="li1112">
<link id="a1115" target-id="Listing_38">

Listing 38

</link>

. PlotALot04.java. 

</item>


		
	

</list>






</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="Preview" effect="bold">

Preview

</emphasis>


</title>




<para id="p1014">
The four classes that I will present and explain in this module are designed 
to make it easy for you to plot and examine large quantities of data.

</para>





<section id="h21001">
<title>
<emphasis id="Sample_output_for_PlotALot01class" effect="bold">

Sample output for PlotALot01 
class

</emphasis>

 

</title>




<para id="p1015">
The first class named 

<emphasis id="strong1013" effect="bold">
PlotALot01

</emphasis>
 is designed for the 
plotting of large quantities of single-channel data. 

<link id="a1116" target-id="Figure_1">

 Figure 1

</link>

 shows an example 
of the plotted output from this class when used to plot a small amount of data.

</para>






<table id="table1000" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1000">
<row id="tr1000">
<entry id="th1000">



<emphasis id="Figure_1" effect="bold">

Figure 1.

</emphasis>

 Sample output for PlotALot01 class.

</entry>
</row>
</thead>


<tbody id="tbody1000">
<row id="tr1001">
<entry id="td1000">




<media id="media1000" alt="Missing Figure." display="block">
<image id="img1000" mime-type="image/jpeg" src="../../media/1492-fig01.jpg" width="408" height="837"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





</section>
<section id="h21002">
<title>
<emphasis id="Usage_information" effect="bold">

Usage information

</emphasis>


</title>




<para id="p1016">
To use the class named 

<emphasis id="strong1014" effect="bold">
PlotALot01

</emphasis>
 to plot data, you first 
instantiate an object of the class, and then you feed data to it as the data 
becomes available within your program.

</para>





<para id="p1017">
When all of the data has been fed to the plotting object, you call a method 
named 

<emphasis id="strong1015" effect="bold">
plotData

</emphasis>
 on the object. This causes the object to produce 
one or more pages of plotted data in a stack on the screen. The page containing 
the earliest data is on the top of the stack and the page containing the latest 
data on the bottom of the stack.

</para>





<section id="h31002">
<title>
<emphasis id="Plotting_format" effect="bold">

Plotting format

</emphasis>


</title>




<para id="p1018">
The first data sample is plotted on the left end of the top trace on the top 
page 

<emphasis id="em1006" effect="italics">
(titled Page: 0)

</emphasis>
. Successive data values are plotted from left to 
right across the page. When the data for the first trace reaches the right end 
of the trace, the next data sample is plotted at the left end of a new trace 
that is created below the current trace. Hence, the chronological order of the 
data is from left to right, top to bottom.

</para>





<para id="p1019">
A horizontal axis is drawn for each trace. Positive data values are plotted 
above the axis and negative values are plotted below the axis.

</para>





</section>
<section id="h31003">
<title>
<emphasis id="On_to_the_next_page" effect="bold">

On to the next page

</emphasis>


</title>




<para id="p1020">
When the bottom trace on a page is filled, a new page is created 
automatically. The next data sample is plotted on the left end of the top trace 
on the new page and the process described above is repeated until that page also 
become full. Then a new page is created, etc.

</para>





<section id="h41000">
<title>
Nearly unlimited plotting capacity

</title>




<para id="p1021">
You can cause the page size to be as large as you want up to the full size of 
the screen on your computer. You can create as many pages as you want and you 
can place as many traces on each page as you want.

</para>





<para id="p1022">
Other than the amount of memory that is available to the Java virtual 
machine, 

<emphasis id="em1007" effect="italics">
(and perhaps some limit on the number of 

<emphasis id="strong1016" effect="bold">
Page

</emphasis>
 
objects allowed by the operating system)

</emphasis>
, there is almost no limit to the 
number of pages that can be produced and the amount of data that can be plotted.

</para>





</section>
<section id="h41001">
<title>
Millions of data values plotted

</title>




<para id="p1023">
I have successfully plotted two million data values in 141 full screen pages 
on a modest laptop computer with no difficulty whatsoever. When I pushed that 
total up to eight million data values in 563 full screen pages, the plotting 
process slowed down, but I was still able to display and examine the plots. The 
practical limit on my computer seems to be somewhere between two million and 
eight million data values.

</para>





</section>
<section id="h41002">
<title>
Two sample pages

</title>




<para id="p1024">
<link id="a1117" target-id="Figure_1">

 Figure 1

</link>

 shows two pages that were physically removed from the stack and 
arranged with the page containing the earliest data above the page containing 
the latest data for publication in this module.

</para>





</section>
<section id="h41003">
<title>
Two overloaded constructors

</title>




<para id="p1025">
Two overloaded constructors are provided for the class. One constructor plots 
the data using a set of default plotting parameters. This constructor is 
provided for extreme ease of use. The only information that you must provide to 
this constructor is a string that becomes part of the title for each page.

</para>





<quote id="blockquote1001" display="block">

	

<para id="p1026">
<emphasis id="em1008" effect="italics">
(The pages in 

<link id="a1118" target-id="Figure_1">

 Figure 1

</link>

 were plotted using default plotting parameters 
	with a title string of "B". The amount of data that was fed to the plotting 
	object for 

<link id="a1119" target-id="Figure_1">

 Figure 1

</link>

 filled Page 0 and almost filled Page 1.)

</emphasis>
</para>





</quote>




</section>
<section id="h41004">
<title>
Can change default plotting parameters

</title>




<para id="p1027">
I coded the values of the default plotting parameters to make the results 
suitable for use in this narrow publication format. If you don't like my choice 
of default plotting parameters, you can change them to values that you find more 
useful. For example, you could cause the default size of the 

<emphasis id="strong1017" effect="bold">
Frame

</emphasis>
 
object to fill your screen, allowing you to plot quite a lot of data on each 
page.

</para>





</section>
<section id="h41005">
<title>
Control over the plotting parameters

</title>




<para id="p1028">
The other overloaded constructor takes seven parameters that allow you to 
control all aspects of the plotting format including:

</para>





<list id="ul1016" list-type="bulleted">

	

<item id="li1113">
Page title

</item>


	

<item id="li1114">
Frame width and hence plotted data width

</item>


	

<item id="li1115">
Frame height, spacing between traces, and hence the number of traces per 
	page

</item>


	

<item id="li1116">
Spacing between samples, number of traces per page, and hence the number 
	of samples per page

</item>


	

<item id="li1117">
Width and height of an oval that is used to mark each sample on the plot

</item>




</list>




<para id="p1029">
The plotted sample values are connected by a straight line. Each sample is 
marked with an oval. You can specify the width and the height of the oval in 
pixels. If you set the width and height to zero, the oval simply disappears from 
the plot.

</para>





</section>
<section id="h41006">
<title>
Default plotting parameters in 

<link id="a1120" target-id="Figure_1">

 Figure 1

</link>


</title>




<para id="p1030">
The plots in 

<link id="a1121" target-id="Figure_1">

 Figure 1

</link>

 were produced using the constructor that applies 
default plotting parameters. For example, the data was plotted using the default 
value of two pixels per sample. Hence the lines connecting the sample values in 


<link id="a1122" target-id="Figure_1">

 Figure 1

</link>

 are very short.

</para>





<para id="p1031">
The ovals in 

<link id="a1123" target-id="Figure_1">

 Figure 1

</link>

 had a default width and height of two pixels each. At 
this small size, the ovals end up looking more like plus characters than ovals.

</para>





<para id="p1032">
The overall parameters governing the plot in 

<link id="a1124" target-id="Figure_1">

 Figure 1

</link>

 were:

</para>





<code id="pre1000" display="block">Title: B
Frame width: 400
Frame height: 410
Page width: 392
Page height: 383
Trace spacing: 50
Sample spacing: 2
Traces per page: 7
Samples per page: 1372</code>




</section>
<section id="h41007">
<title>
Explanation of terms

</title>




<para id="p1033">
Some explanation of the terminology in the above list is probably in order. 
The 

<emphasis id="strong1018" effect="bold">
Frame width

</emphasis>
 and 

<emphasis id="strong1019" effect="bold">
Frame height

</emphasis>
 are the 
actual width and height of the 

<emphasis id="strong1020" effect="bold">
Frame

</emphasis>
 objects shown in 

<link id="a1125" target-id="Figure_1">

 Figure 1

</link>

.

</para>





<para id="p1034">
The 

<emphasis id="strong1021" effect="bold">
Page width

</emphasis>
 and 

<emphasis id="strong1022" effect="bold">
Page height

</emphasis>
 are the 
width and height of a 

<emphasis id="strong1023" effect="bold">
Canvas

</emphasis>
 object contained in the 

<emphasis id="strong1024" effect="bold">

Frame

</emphasis>
 object, upon which the plotting is performed. The width of the


<emphasis id="strong1025" effect="bold">
Canvas

</emphasis>
 actually controls the number of samples that can be 
plotted in each trace.

</para>





<para id="p1035">
The 

<emphasis id="strong1026" effect="bold">
Trace spacing

</emphasis>
 is the number of pixels that separate each 
of the horizontal axes on a page in 

<link id="a1126" target-id="Figure_1">

 Figure 1

</link>

.

</para>





<para id="p1036">
The 

<emphasis id="strong1027" effect="bold">
Sample spacing

</emphasis>
 specifies the number of pixels that are 
dedicated to each sample horizontally. In 

<link id="a1127" target-id="Figure_1">

 Figure 1

</link>

, that value is 2. This means 
that every other black pixel in 

<link id="a1128" target-id="Figure_1">

 Figure 1

</link>

 indicates the value of a data sample. 
The pixels in between are fillers.

</para>





<para id="p1037">
The 

<emphasis id="strong1028" effect="bold">
Traces per page

</emphasis>
 specifies the number of horizontal axes 
on each page against which the data values are plotted.

</para>





<para id="p1038">
The 

<emphasis id="strong1029" effect="bold">
Samples per page

</emphasis>
 gives the actual number of data values 
that are plotted on each page. This is determined from the values of 

<emphasis id="strong1030" effect="bold">

Traces per page

</emphasis>
, 

<emphasis id="strong1031" effect="bold">
Sample spacing

</emphasis>
, and 

<emphasis id="strong1032" effect="bold">
Page 
width

</emphasis>
.

</para>





</section>
<section id="h41008">
<title>
Location of the stack of plots

</title>




<para id="p1039">
There are also two overloaded versions of the method named 

<emphasis id="strong1033" effect="bold">
plotData

</emphasis>
. 
One version lets you specify the location of the upper left corner of the stack 
of pages relative to the upper left corner of the screen. The other version 
simply places the stack of pages in the upper left corner of the screen by 
default.

</para>





</section>
</section>
</section>
<section id="h21003">
<title>
<emphasis id="Sample_output_for_PlotALot02_class" effect="bold">

Sample output for PlotALot02 
class

</emphasis>

 

</title>




<para id="p1040">
The class named 

<emphasis id="strong1034" effect="bold">
PlotALot01

</emphasis>
 is designed for the plotting of 
large quantities of data from a single channel as described above. The classes 
named 

<emphasis id="strong1035" effect="bold">
PlotALot02

</emphasis>
 and 

<emphasis id="strong1036" effect="bold">
PlotALot03

</emphasis>
 are each 
designed to plot two channels of data. These two classes plot the two-channel 
data in different formats.

</para>





<section id="h31004">
<title>
<emphasis id="Superimposed_data" effect="bold">

Superimposed data

</emphasis>


</title>




<para id="p1041">
The class named 

<emphasis id="strong1037" effect="bold">
PlotALot02

</emphasis>
 provides all of the features 
described above for the class named 

<emphasis id="strong1038" effect="bold">
PlotALot01

</emphasis>
, such as 
overloaded constructors, overloaded 

<emphasis id="strong1039" effect="bold">
plotData

</emphasis>
 methods, etc. In 
addition, it provides the capability to superimpose two sets of data on the same 
axes with one set being plotted in black and the other being plotted in red. 
This is illustrated in 

<link id="a1129" target-id="Figure_2">

 Figure 2

</link>

.

</para>






<table id="table1001" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1001">
<row id="tr1002">
<entry id="th1001">



<emphasis id="Figure_2" effect="bold">

Figure 2.

</emphasis>

 Sample output for PlotALot02 class.

</entry>
</row>
</thead>


<tbody id="tbody1001">
<row id="tr1003">
<entry id="td1001">




<media id="media1001" alt="Missing Figure." display="block">
<image id="img1001" mime-type="image/jpeg" src="../../media/1492-fig02.jpg" width="237" height="724"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<section id="h41009">
<title>
Same data, different sign

</title>




<para id="p1042">
The plots in 

<link id="a1130" target-id="Figure_2">

 Figure 2

</link>

 were produced by plotting two versions of the same 
data. The algebraic sign of each of the data values was inverted in one set of 
data relative to the other. Thus, the red plot in 

<link id="a1131" target-id="Figure_2">

 Figure 2

</link>

 is an upside down 
version of the black plot. This makes it easy to confirm that both plotting 
processes are behaving the same way.

</para>





</section>
<section id="h41010">
<title>
Plotting parameters were controlled

</title>




<para id="p1043">
The plots in 

<link id="a1132" target-id="Figure_2">

 Figure 2

</link>

 were produced using the version of the constructor that 
allows the user to control the plotting parameters. The overall plotting 
parameters for 

<link id="a1133" target-id="Figure_2">

 Figure 2

</link>

 are shown below:

</para>





<code id="pre1001" display="block">Title: A
Frame width: 158
Frame height: 237
Page width: 150
Page height: 210
Trace spacing: 36
Sample spacing: 5
Traces per page: 5
Samples per page: 150</code>




</section>
<section id="h41011">
<title>
Larger ovals

</title>




<para id="p1044">
As you can see, the ovals that were used to mark the sample values in 

<link id="a1134" target-id="Figure_2">

 Figure 2

</link>

 
were larger than in 

<link id="a1135" target-id="Figure_1">

 Figure 1

</link>

. With a height and a width of four pixels, each 
oval turned out to be a circle centered on the sample value.

</para>





</section>
<section id="h41012">
<title>
Horizontal scaling was greater

</title>




<para id="p1045">
Also, the horizontal scaling in 

<link id="a1136" target-id="Figure_2">

 Figure 2

</link>

 was five pixels per sample as 
opposed to two pixels per sample in 

<link id="a1137" target-id="Figure_1">

 Figure 1

</link>

. As a result, the circles marking 
the samples were further apart, and the straight lines connecting the circles 
are often visible.

</para>





</section>
</section>
</section>
<section id="h21004">
<title>
<emphasis id="Sample_output_for_PlotALot03_class" effect="bold">

Sample output for PlotALot03 
class

</emphasis>

 

</title>




<para id="p1046">
The classes named 

<emphasis id="strong1040" effect="bold">
PlotALot02

</emphasis>
 and 

<emphasis id="strong1041" effect="bold">
PlotALot03

</emphasis>
 are each designed to plot two 
channels of data. These two classes plot the two-channel data in different 
formats. Whereas 

<emphasis id="strong1042" effect="bold">
PlotALot02

</emphasis>
 superimposes the two sets of data on the same 
horizontal axes using color to provide visual separation, 

<emphasis id="strong1043" effect="bold">
PlotALot03

</emphasis>
 plots the 
two sets of data on alternating horizontal axes as shown in 

<link id="a1138" target-id="Figure_3">

 Figure 3

</link>

. 

<emphasis id="strong1044" effect="bold">
PlotALot03

</emphasis>
 
also uses color to provide visual separation between the two sets of data. One 
set is plotted on the odd numbered axes in black. The other set is plotted on 
the even numbered axes in red.

</para>





<para id="p1047">
The class named 

<emphasis id="strong1045" effect="bold">
PlotALot03

</emphasis>
 also provides all of the general capabilities 
described earlier for the class named 

<emphasis id="strong1046" effect="bold">
PlotALot01

</emphasis>
 that are appropriate for a 
two-channel plotting system.

</para>






<table id="table1002" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1002">
<row id="tr1004">
<entry id="th1002">



<emphasis id="Figure_3" effect="bold">

Figure 3.

</emphasis>

 Sample output for PlotALot03 class.

</entry>
</row>
</thead>


<tbody id="tbody1002">
<row id="tr1005">
<entry id="td1002">




<media id="media1002" alt="Missing Figure." display="block">
<image id="img1002" mime-type="image/jpeg" src="../../media/1492-fig03.jpg" width="240" height="824"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<section id="h31005">
<title>
<emphasis id="Same_data_two_colors" effect="bold">

Same data, two colors

</emphasis>


</title>




<para id="p1048">
The two sets of data plotted in 

<link id="a1139" target-id="Figure_3">

 Figure 3

</link>

 consisted of exactly the same 
values. Thus, the plots on the even numbered axes look just like the plots on 
the odd numbered axes except that one plot is red and the other is black. Using 
the same values for each set of data makes it easy to confirm that both plotting 
processes are behaving the same way.

</para>





<section id="h41013">
<title>
The plotting parameters

</title>




<para id="p1049">
The overall plotting parameters for 

<link id="a1140" target-id="Figure_3">

 Figure 3

</link>

 are shown below:

</para>





<code id="pre1002" display="block">Title: A
Frame width: 158
Frame height: 270
Page width: 150
Page height: 243
Trace spacing: 36
Sample spacing: 5
Traces per page: 6
Samples per page: 90</code>




<para id="p1050">
Because 

<emphasis id="strong1047" effect="bold">
PlotALot03

</emphasis>
 doesn't superimpose the two sets of data, 
twice as many pages would be required for 

<emphasis id="strong1048" effect="bold">
PlotALot03

</emphasis>
 to plot a 
given amount of data as would be required by 

<emphasis id="strong1049" effect="bold">
PlotALot02

</emphasis>
 for the 
same Page size.

</para>





<para id="p1051">
PlotALot03 will refuse to plot data for a set of plotting parameters that 
result in an odd number of traces on the page.

</para>





</section>
</section>
</section>
<section id="h21005">
<title>
<emphasis id="Sample_output_for_PlotALot04_class" effect="bold">

Sample output for PlotALot04 
class

</emphasis>


</title>




<para id="p1052">
The class named 

<emphasis id="strong1050" effect="bold">
PlotALot04

</emphasis>
 plots three sets of data on separate horizontal 
axes as shown in 

<link id="a1141" target-id="Figure_4">

 Figure 4

</link>

. The first set of data is plotted in black. The second 
set of data is plotted in red. The third set of data is plotted in blue. This 
class is particularly useful for displaying the input, output, and error signals 
involved in adaptive signal processing, for example.

</para>





<para id="p1053">
The class named 

<emphasis id="strong1051" effect="bold">
PlotALot04

</emphasis>
 also provides all of the general capabilities 
described earlier for the class named 

<emphasis id="strong1052" effect="bold">
PlotALot01

</emphasis>
 that are appropriate for a 
three-channel plotting system.

</para>






<table id="table1003" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1003">
<row id="tr1006">
<entry id="th1003">



<emphasis id="Figure_4" effect="bold">

Figure 4.

</emphasis>

 Sample output for PlotALot04 class.

</entry>
</row>
</thead>


<tbody id="tbody1003">
<row id="tr1007">
<entry id="td1003">




<media id="media1003" alt="Missing Figure." display="block">
<image id="img1003" mime-type="image/jpeg" src="../../media/1492-fig04.jpg" width="238" height="821"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<section id="h31006">
<title>
<emphasis id="Same_data_three_colors" effect="bold">

Same data, three colors

</emphasis>


</title>




<para id="p1054">
The three sets of data plotted in 

<link id="a1142" target-id="Figure_4">

 Figure 4

</link>

 consisted of exactly the same 
values. Thus, the plots on the three different axes look just alike except that 
the first plot is black, the second plot is red and the third is blue. Using the 
same values for each set of data makes it easy to confirm that all three 
plotting processes are behaving the same way.

</para>





<section id="h41014">
<title>
The plotting parameters

</title>




<para id="p1055">
The overall plotting parameters for 

<link id="a1143" target-id="Figure_4">

 Figure 4

</link>

 are shown below:

</para>





<code id="pre1003" display="block">Title: A
Frame width: 158
Frame height: 270
Page width: 150
Page height: 243
Trace spacing: 36
Sample spacing: 5
Traces per page: 6
Samples per page: 60</code>




<para id="p1056">
<emphasis id="strong1053" effect="bold">
PlotALot04

</emphasis>
 will terminate if the number of traces per page 
is not evenly divisible by 3

</para>




	

</section>
</section>
</section>
</section>
<section id="h11003">
<title>
<emphasis id="Sample_Programs" effect="bold">

Sample programs

</emphasis>


</title>


	
	

<section id="h21006">
<title>
<emphasis id="The_class_named_PlotALot01" effect="bold">

The class named PlotALot01

</emphasis>


</title>




<para id="p1057">
Now that you know where we are heading, it's time to examine these four 
classes in detail. I will begin with the class named 

<emphasis id="strong1054" effect="bold">
PlotALot01

</emphasis>
.

</para>





<section id="h31007">
<title>
<emphasis id="Purpose_of_the_class" effect="bold">

Purpose of the class

</emphasis>


</title>




<para id="p1058">
This class is designed to plot large amounts of data for a single channel. 
The class is particularly useful for plotting time series data. Also, by 
carefully adjusting the plotting parameters, this class can be used to plot 
large quantities of spectral data in a 

<emphasis id="em1009" effect="italics">
waterfall

</emphasis>
 display with each new 
spectral estimate being plotted immediately below the previous estimate.

</para>





</section>
<section id="h31008">
<title>
<emphasis id="Usagezzzinformation" effect="bold">

Usage information

</emphasis>


</title>




<para id="p1059">
The class provides a 

<emphasis id="strong1055" effect="bold">
main

</emphasis>
 method so that the class can be 
run as an application to test itself. The 

<emphasis id="strong1056" effect="bold">
main

</emphasis>
 method also 
illustrates how to use the class.

</para>





<para id="p1060">
There are three steps involved in the use of this class for plotting large 
quantities of data:

</para>





<list id="ol1001" list-type="enumerated">

	

<item id="li1118">
Instantiate a plotting object of type 

<emphasis id="strong1057" effect="bold">
PlotALot01

</emphasis>
 using 
	one of two overloaded constructors.

</item>


	

<item id="li1119">
Feed the data that is to be plotted to the plotting object by calling 
	the 

<emphasis id="strong1058" effect="bold">
feedData

</emphasis>
 method once for each data value.

</item>


	

<item id="li1120">
Call one of two overloaded 

<emphasis id="strong1059" effect="bold">
plotData

</emphasis>
 methods on the 
	plotting object once all of the data has been fed to the object. This causes 
	all of the data to be plotted and causes the pages to be stacked in a 
	particular location on the screen with page 0 on the top of the stack.

</item>




</list>




</section>
<section id="h31009">
<title>
<emphasis id="Different_plotting_objects" effect="bold">

Different plotting objects

</emphasis>


</title>




<para id="p1061">
A program that uses this class for plotting can instantiate as many different 
plotting objects as are needed to plot all of the different sets of data that 
need to be plotted independently of one another.

</para>





<quote id="blockquote1002" display="block">

	

<para id="p1062">
<emphasis id="em1010" effect="italics">
(For example, a program that uses this class could instantiate one 
	plotting object to plot time series data and a different plotting object to 
	plot spectral data.)

</emphasis>
</para>





</quote>




<section id="h41015">
<title>
Can plot a large number of data values

</title>




<para id="p1063">
Each plotting object can be used to plot as many data values as needed 

<emphasis id="em1011" effect="italics">

(unless the program runs out of memory)

</emphasis>
.

</para>





<quote id="blockquote1003" display="block">

	

<para id="p1064">
<emphasis id="em1012" effect="italics">
(As mentioned earlier, I have successfully plotted two million data 
	values in 141 full screen pages on a modest laptop computer with no 
	difficulty whatsoever. When I pushed that total up to eight million data 
	values in 563 full screen pages, the plotting process slowed down, but I was 
	still able to display and examine the plots. The practical limit on my 
	computer seems to be somewhere between two million and eight million data 
	values.)

</emphasis>
</para>





</quote>




</section>
<section id="h41016">
<title>
Multiple Page objects

</title>




<para id="p1065">
A plotting object of type 

<emphasis id="strong1060" effect="bold">
PlotALot01

</emphasis>
 owns one or more


<emphasis id="strong1061" effect="bold">
Page

</emphasis>
 objects that extend the 

<emphasis id="strong1062" effect="bold">
Frame

</emphasis>
 class. The 
plotting object can own as many 

<emphasis id="strong1063" effect="bold">
Page

</emphasis>
 objects as are necessary 
to plot all of the data that is fed to the plotting object.

</para>





</section>
<section id="h41017">
<title>
A stack of Page objects

</title>




<para id="p1066">
The class produces a graphic output consisting of a stack of 

<emphasis id="strong1064" effect="bold">
Page

</emphasis>
 
objects on the screen, with the data plotted on a 

<emphasis id="strong1065" effect="bold">
Canvas

</emphasis>
 object 
contained in each 

<emphasis id="strong1066" effect="bold">
Page

</emphasis>
 object. The 

<emphasis id="strong1067" effect="bold">
Page

</emphasis>
 
showing the earliest data 

<emphasis id="em1013" effect="italics">
(page 0)

</emphasis>
 is on the top of the stack and the


<emphasis id="strong1068" effect="bold">
Page

</emphasis>
 showing the latest data is on the bottom of the stack.

</para>





<quote id="blockquote1004" display="block">

	

<para id="p1067">
<emphasis id="em1014" effect="italics">
(The 

<emphasis id="strong1069" effect="bold">
Page

</emphasis>
 objects on the top of the stack must be 
	physically moved in order to see the 

<emphasis id="strong1070" effect="bold">
Page

</emphasis>
 objects further 
	down in the stack.)

</emphasis>
</para>





</quote>




</section>
<section id="h41018">
<title>
Multiple traces on each Page object

</title>




<para id="p1068">
As shown in 

<link id="a1144" target-id="Figure_1">

 Figure 1

</link>

, each 

<emphasis id="strong1071" effect="bold">
Page

</emphasis>
 object contains one or more 
horizontal axes on which the data is plotted. The earliest data is plotted on 
the axis nearest the top of the 

<emphasis id="strong1072" effect="bold">
Page

</emphasis>
 moving from left to right 
across the 

<emphasis id="strong1073" effect="bold">
Page

</emphasis>
. Positive data values are plotted above the 
axis and negative values are plotted below the axis.

</para>





<para id="p1069">
When the right end of an axis is reached, the next data value is plotted on 
the left end of the axis immediately below it 

<emphasis id="em1015" effect="italics">
(sometimes referred to as wrap 
around)

</emphasis>
. When the right end of the last axis on the 

<emphasis id="strong1074" effect="bold">
Page

</emphasis>
 
is reached, a new 

<emphasis id="strong1075" effect="bold">
Page

</emphasis>
 object is automatically created and the 
next data value is plotted at the left end of the top axis on the new 

<emphasis id="strong1076" effect="bold">

Page

</emphasis>
 object.

</para>





</section>
<section id="h41019">
<title>
Two overloaded constructors

</title>




<para id="p1070">
There are two overloaded versions of the constructor for the 

<emphasis id="strong1077" effect="bold">

PlotALot01

</emphasis>
 class. One overloaded version accepts several incoming 
parameters allowing the user to control various aspects of the plotting format.


<emphasis id="em1016" effect="italics">
(An example of the use of this constructor is shown in 

<link id="a1145" target-id="Figure_5">

 Figure 5

</link>

.)

</emphasis>
 A 
second overloaded version accepts a title string only and sets all of the 
plotting parameters to default values. 

<emphasis id="em1017" effect="italics">
(An example of the use of this 
constructor is shown in 

<link id="a1146" target-id="Figure_1">

 Figure 1

</link>

.)

</emphasis>
</para>





<quote id="blockquote1005" display="block">

	

<para id="p1071">
<emphasis id="em1018" effect="italics">
(You can easily modify the default values and recompile the class if 
	you prefer different default values.)

</emphasis>
</para>





</quote>




</section>
<section id="h41020">
<title>
<emphasis id="Constructor_parameters" effect="bold">

Constructor parameters

</emphasis>


</title>




<para id="p1072">
The parameters for the version of the constructor that accepts plotting 
parameters are:

</para>





<list id="ul1017" list-type="bulleted">

	

<item id="li1121">
String title: Title for the Frame object. This title is concatenated 
	with the page number and the result appears in the banner at the top of the 
	Page as shown in 

<link id="a1147" target-id="Figure_1">

 Figure 1

</link>

.

</item>


	

<item id="li1122">
int frameWidth: The Frame width in pixels.

</item>


	

<item id="li1123">
int frameHeight: The Frame height in pixels.

</item>


	

<item id="li1124">
int traceSpacing: Distance between trace axes in pixels.

</item>


	

<item id="li1125">
int sampSpace: Number of pixels dedicated to each data sample in pixels 
	per sample. 

<emphasis id="em1019" effect="italics">
(Must be 1 or greater.)

</emphasis>
</item>


	

<item id="li1126">
int ovalWidth: Width of an oval that is used to mark the sample value on 
	the plot. 

<emphasis id="em1020" effect="italics">
(See 

<link id="a1148" target-id="Figure_5">

 Figure 5

</link>

 for a good example of the ovals. Set the oval 
	width and height parameters to zero to eliminate the ovals altogether.)

</emphasis>
</item>


	

<item id="li1127">
int ovalHeight: Height of an oval that is used to mark the sample value 
	on the plot.

</item>




</list>




</section>
<section id="h41021">
<title>
Two plotting objects for test purposes

</title>




<para id="p1073">
For self-test purposes, the 

<emphasis id="strong1078" effect="bold">
main

</emphasis>
 method instantiates and feeds 
two independent plotting objects. Plotting parameters are specified for the 
first plotting object and the stack of pages for this plotting object is located 
401 pixels to the right of the upper left corner of the screen. The output 
produced by this plotting object is shown in 

<link id="a1149" target-id="Figure_5">

 Figure 5

</link>

 below. 

<emphasis id="em1021" effect="italics">
(The two pages 
in the screen shot in 

<link id="a1150" target-id="Figure_5">

 Figure 5

</link>

 were manually relocated and positioned for 
reasons that I will explain later.)

</emphasis>
</para>





<table id="table1004" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1004">
<row id="tr1008">
<entry id="th1004">



<emphasis id="Figure_5" effect="bold">

Figure 5.

</emphasis>

 Self-test output for PlotALot01.


</entry>
</row>
</thead>


<tbody id="tbody1004">
<row id="tr1009">
<entry id="td1004">




<media id="media1004" alt="Missing Figure." display="block">
<image id="img1004" mime-type="image/jpeg" src="../../media/1492-fig05.jpg" width="546" height="673"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<para id="p1074">
Default plotting parameters are used for the second plotting object and the 
stack of pages is located in the default location at the upper left corner of 
the screen. The output produced by this plotting object was shown earlier in 


<link id="a1151" target-id="Figure_1">

 Figure 1

</link>

.

</para>





</section>
<section id="h41022">
<title>
The data to be plotted

</title>




<para id="p1075">
Most of the data that is fed to each plotting object is white random noise 
produced by a random noise generator. However, fifteen of the data values fed to 
the first plotting object are not random. 

</para>





</section>
<section id="h41023">
<title>
Transition from trace to trace on the same page

</title>




<para id="p1076">
Eight of the data values for the first plotting object are set to 
0,0,20,20,-20,-20,0,0. The result can be seen at the end of the first trace and 
the beginning of the second trace in Page 0 in 

<link id="a1152" target-id="Figure_5">

 Figure 5

</link>

. Note that the last four 
plotted points for the first trace have values of 0,0,20, and 20. Then note that 
the first four plotted points on the second trace have values of -20, -20, 0, 
and 0. This confirms the proper transition from one trace to the next on the 
same page with no loss of data values in the transition.

</para>





</section>
<section id="h41024">
<title>
Transition from page to page

</title>




<para id="p1077">
Seven of the values for the first plotting object are set to values of 
0,0,25,-25,25,0,0. The result can be seen at the end of the last trace on Page 0 
and the beginning of the first trace on Page 1 in 

<link id="a1153" target-id="Figure_5">

 Figure 5

</link>

. Note that the last 
three plotted points in the last trace on Page 0 have values of 0, 0, and 25. 
Then note that the first four plotted points in the first trace on Page 1 have 
values of -25, 25, 0, and 0. This confirms the proper transition from one page 
to the next with no loss of data in the transition.

</para>





<quote id="blockquote1006" display="block">

	

<para id="p1078">
<emphasis id="em1022" effect="italics">
(The two pages in 

<link id="a1154" target-id="Figure_5">

 Figure 5

</link>

 were manually arranged as shown before 
	capturing the screen shot to emphasize the transition of the data from one 
	page to the next. The large white rectangles in 

<link id="a1155" target-id="Figure_5">

 Figure 5

</link>

 are the result of 
	removing the background clutter in the image caused by icons on the 
	desktop.)

</emphasis>
</para>





</quote>




</section>
<section id="h41025">
<title>
Proper locations for AWT Frame under WinXP

</title>




<para id="p1079">
These specific values and the locations in the data where they are placed 
provide visible confirmation that the transitions mentioned above are handled 
correctly by the plotting object. These are the correct locations for an AWT


<emphasis id="strong1079" effect="bold">
Frame

</emphasis>
 object for Java running under WinXP. Note however that a


<emphasis id="strong1080" effect="bold">
Frame

</emphasis>
 may have different 

<emphasis id="em1023" effect="italics">
inset

</emphasis>
 values 

<emphasis id="em1024" effect="italics">
(border 
widths)

</emphasis>
 under other operating systems, which may cause these specific 
locations to fail to match up for that operating system. In that case, the 
values will be plotted but they won't necessarily occur at the same physical 
locations in order to confirm the proper transition.

</para>





<quote id="blockquote1007" display="block">

	

<emphasis id="em1025" effect="italics">
(They also match up properly for the Windows 7 Classic scheme, but not 
	for the other Windows 7 themes.)

</emphasis>
</quote>




</section>
<section id="h41026">
<title>
Information about plotting parameters

</title>




<para id="p1080">
Information about the plotting parameters for each plotting object is 
displayed on the command line screen when this class is used for plotting. The 
values shown below result from the execution of the main method of the 

<emphasis id="strong1081" effect="bold">

PlotALot01

</emphasis>
 class for self-test purposes. One of the plotting objects 
instantiated by the main method is titled "A" and 


<emphasis id="the_other_is_titled_B" effect="bold">

the other is titled "B"

</emphasis>

. 

</para>





<code id="pre1004" display="block">null</code>




<para id="p1081">
The graphic output produced for the object titled "A" is shown in 

<link id="a1156" target-id="Figure_5">

 Figure 5

</link>

. 
This output was based on plotting format parameters that were passed to the 
constructor. The graphic output produced for the object titled "B" is shown in 


<link id="a1157" target-id="Figure_1">

 Figure 1

</link>

. This output was based on default plotting parameters.

</para>





</section>
<section id="h41027">
<title>
Overloaded plotData method

</title>




<para id="p1082">
There are two overloaded versions of the 

<emphasis id="strong1082" effect="bold">
plotData

</emphasis>
 method. 
One version allows the user to specify the location on the screen where the 
stack of plotted pages will appear. This version requires two parameters, which 
are coordinate values in pixels. The first parameter specifies the horizontal 
coordinate of the upper left corner of the stack of pages relative to the upper 
left corner of the screen. The second parameter specifies the vertical 
coordinate of the upper left corner of the stack of pages relative to the upper 
left corner of the screen.

</para>





<quote id="blockquote1008" display="block">

	

<para id="p1083">
<emphasis id="em1026" effect="italics">
(Specifying coordinate values of 0,0 causes the stack to be located 
	in the upper left corner of the screen. Positive vertical coordinates 
	progress down the screen.)

</emphasis>
</para>





</quote>




<para id="p1084">
The other overloaded version of 

<emphasis id="strong1083" effect="bold">
plotData

</emphasis>
 places the stack of 
pages in the upper left corner of the screen by default.

</para>





</section>
<section id="h41028">
<title>
A WindowListener for program termination

</title>




<para id="p1085">
Each page has a 

<emphasis id="strong1084" effect="bold">
WindowListener

</emphasis>
 that will terminate the 
program if the user clicks the close button on the 

<emphasis id="strong1085" effect="bold">
Frame

</emphasis>
 

<emphasis id="em1027" effect="italics">

(the X-button in the upper-right corner)

</emphasis>
.

</para>





</section>
<section id="h41029">
<title>
J2SE 5.0 is required

</title>




<para id="p1086">
The class was tested using J2SE 5.0 and WinXP. J2SE 5.0 is required because 
the class uses generics with an ArrayList object. 

<emphasis id="em1028" effect="italics">
(More recently, it was 
re-tested using java version "1.8.0_60" under Windows 7.)

</emphasis>
</para>





</section>
<section id="h41030">
<title>
Let's see some code!

</title>




<para id="p1087">
I will present and explain this class in fragments. A complete listing of the 
class is provided in 

<link id="a1158" target-id="Listing_35">

 Listing 35

</link>

 near the end of the module. 

</para>





</section>
</section>
<section id="h31010">
<title>
<emphasis id="Beginning_of_the_class_named_PlotALot01" effect="bold">

Beginning of the class named PlotALot01

</emphasis>


</title>




<para id="p1088">
As mentioned earlier, this class contains a 

<emphasis id="strong1086" effect="bold">
main

</emphasis>
 method. The


<emphasis id="strong1087" effect="bold">
main

</emphasis>
 method is provided so that the class can be run as an 
application for self-test purposes, which is common practice in Java 
programming. The 

<emphasis id="strong1088" effect="bold">
main

</emphasis>
 method also 
illustrates the proper use of the class.

</para>





<para id="p1089">
The beginning of the class and the beginning of the 

<emphasis id="strong1089" effect="bold">
main

</emphasis>
 
method are shown in 

<link id="a1159" target-id="Listing_1">

 Listing 1

</link>

.

</para>





<table id="table1005" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1005">
<row id="tr1010">



<entry id="th1005">
<emphasis id="Listing_1" effect="bold">

Listing 1.

</emphasis>

 Beginning of the class named PlotALot01.


</entry>
</row>
</thead>


<tbody id="tbody1005">
<row id="tr1011">
<entry id="td1005">

		

<code id="pre1005" display="block">public class PlotALot01{
  public static void main(String[] args){
    PlotALot01 plotObjectA = 
            new PlotALot01("A",158,237,36,5,4,4);
    PlotALot01 plotObjectB = new PlotALot01("B");</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41031">
<title>
Instantiate two plotting objects

</title>




<para id="p1090">
<link id="a1160" target-id="Listing_1">

 Listing 1

</link>

 instantiates two independent plotting objects. The first plotting 
object, referred to by 

<emphasis id="strong1090" effect="bold">
plotObjectA

</emphasis>
 is instantiated by calling 
the constructor that accepts plotting parameters. A description of each of the 
constructor parameters was provided 

<link id="a1161" target-id="Constructor_parameters">

earlier

</link>

. 
You may find it useful to compare the values shown in 

<link id="a1162" target-id="Listing_1">

 Listing 1

</link>

 with the


<link id="a1163" target-id="Title_A">

overall plotting parameters

</link>

 listed earlier 
to confirm how they are related.

</para>





<para id="p1091">
The second plotting object, referred to by 

<emphasis id="strong1091" effect="bold">
plotObjectB

</emphasis>
 is 
instantiated by calling the constructor that accepts only the page title as a 
parameter and uses default values for all of the plotting parameters. You will 
see those default values later in the code.

</para>





</section>
</section>
<section id="h31011">
<title>
<emphasis id="Feed_the_plotting_object_titled_A" effect="bold">

Feed the plotting object titled "A"

</emphasis>


</title>




<para id="p1092">
<link id="a1164" target-id="Listing_2">

 Listing 2

</link>

 contains a 

<emphasis id="strong1092" effect="bold">
for

</emphasis>
 loop that feeds 275 values to the plotting object 
titled "A". Most of the code in 

<link id="a1165" target-id="Listing_2">

 Listing 2

</link>

 is required to set fifteen specific 
values to test for proper
transitions as described earlier. This code is straightforward and shouldn't 
require further explanation.

</para>





<quote id="blockquote1009" display="block">

	

<para id="p1093">
<emphasis id="em1029" effect="italics">
(I was able to determine the correct locations for these values by 
	knowing the size of the Frame, inset values for the Frame, the space between 
	traces, the number of pixels dedicated to each sample, etc.)

</emphasis>
</para>





</quote>





<table id="table1006" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1006">
<row id="tr1012">



<entry id="th1006">
<emphasis id="Listing_2" effect="bold">

Listing 2.

</emphasis>

 Feed the plotting object titled "A".


</entry>
</row>
</thead>


<tbody id="tbody1006">
<row id="tr1013">
<entry id="td1006">

		

<code id="pre1006" display="block">    for(int cnt = 0;cnt &lt; 275;cnt++){
      if(cnt == 147){
        plotObjectA.feedData(0);
      }else if(cnt == 148){
        plotObjectA.feedData(0);
      }else if(cnt == 149){
        plotObjectA.feedData(25);
      }else if(cnt == 150){
        plotObjectA.feedData(-25);
      }else if(cnt == 151){
        plotObjectA.feedData(25);
      }else if(cnt == 152){
        plotObjectA.feedData(0);
      }else if(cnt == 153){
        plotObjectA.feedData(0);
      }else if(cnt == 26){
        plotObjectA.feedData(0);
      }else if(cnt == 27){
        plotObjectA.feedData(0);
      }else if(cnt == 28){
        plotObjectA.feedData(20);
      }else if(cnt == 29){
        plotObjectA.feedData(20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20);
      }else if(cnt == 32){
        plotObjectA.feedData(0);
      }else if(cnt == 33){
        plotObjectA.feedData(0);
      }else{
        plotObjectA.feedData(
                       (Math.random() - 0.5)*25);
      }//end else
    }//end for loop</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41032">
<title>
White random noise

</title>




<para id="p1094">
The final statement in 

<link id="a1166" target-id="Listing_2">

 Listing 2

</link>

 uses a random number generator to feed white 
random noise to the plotting object for all data values other than the fifteen 
data values specified in the preceding statements. You can see the random values 
plotted and marked by round ovals in 

<link id="a1167" target-id="Figure_5">

 Figure 5

</link>

.

</para>





</section>
</section>
<section id="h31012">
<title>
<emphasis id="Plot_the_data" effect="bold">

Plot the data

</emphasis>


</title>




<para id="p1095">
The statement in 

<link id="a1168" target-id="Listing_3">

 Listing 3

</link>

 calls the overloaded 

<emphasis id="strong1093" effect="bold">
plotData

</emphasis>
 method to cause all 
of the pages belonging to the plotting object titled "A" to be stacked in a 
location where the upper left corner of the stack is 401 pixels to the right of 
the upper left corner of the screen.

</para>





<table id="table1007" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1007">
<row id="tr1014">



<entry id="th1007">
<emphasis id="Listing_3" effect="bold">

Listing 3.

</emphasis>

 Plot the data.


</entry>
</row>
</thead>


<tbody id="tbody1007">
<row id="tr1015">
<entry id="td1007">

		

<code id="pre1007" display="block">    plotObjectA.plotData(401,0);</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1096">
As described earlier, page 0 containing the earliest data fed to the plotting 
object is on the top of the stack. 

<link id="a1169" target-id="Figure_1">

 Figure 1

</link>

 shows the two pages belonging to 
this plotting object after they have been manually rearranged to make them both 
visible.

</para>





</section>
<section id="h31013">
<title>
<emphasis id="Feed_and_plot_the_object_titled_B" effect="bold">

Feed and plot the object titled "B"

</emphasis>


</title>




<para id="p1097">
<link id="a1170" target-id="Listing_4">

 Listing 4

</link>

 feeds 2600 random white noise values to the object titled "B" and 
displays the pages in the default location in the upper left corner of the 
screen. 

<link id="a1171" target-id="Listing_4">

 Listing 4

</link>

 also signals the end of the main method.

</para>





<table id="table1008" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1008">
<row id="tr1016">



<entry id="th1008">
<emphasis id="Listing_4" effect="bold">

Listing 4.

</emphasis>

 Feed and plot the object titled "B".


</entry>
</row>
</thead>


<tbody id="tbody1008">
<row id="tr1017">
<entry id="td1008">

		

<code id="pre1008" display="block">    for(int cnt = 0;cnt &lt; 2600;cnt++){
      plotObjectB.feedData(
                       (Math.random() - 0.5)*25);
    }//end for loop
    plotObjectB.plotData();
    
  }//end main</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1098">
<link id="a1172" target-id="Listing_4">

 Listing 4

</link>

 

<emphasis id="em1030" effect="italics">
(plus one of the statements in 

<link id="a1173" target-id="Listing_1">

 Listing 1

</link>

)

</emphasis>
 is much more 
typical of the amount of code required to use this plotting class than was the 
case with 

<link id="a1174" target-id="Listing_2">

 Listing 2

</link>

.

</para>





<quote id="blockquote1010" display="block">

	

<para id="p1099">
<emphasis id="em1031" effect="italics">
(Almost all of the code in 

<link id="a1175" target-id="Listing_2">

 Listing 2

</link>

 was required to set the special 
	data values used to test the transitions discussed earlier.)

</emphasis>
</para>





</quote>




<section id="h41033">
<title>
The three steps

</title>




<para id="p1100">
To recap, the three steps required to use this class for plotting nearly 
unlimited amounts of data are:

</para>





<list id="ol1002" list-type="enumerated">

	

<item id="li1128">
Instantiate a plotting object of the class named 

<emphasis id="strong1094" effect="bold">
PlotALot01

</emphasis>
, 
	as in 

<link id="a1176" target-id="Listing_1">

 Listing 1

</link>

.

</item>


	

<item id="li1129">
Call the 

<emphasis id="strong1095" effect="bold">
feedData

</emphasis>
 method once for each data value that 
	is to be plotted, as in 

<link id="a1177" target-id="Listing_4">

 Listing 4

</link>

.

</item>


	

<item id="li1130">
Call the 

<emphasis id="strong1096" effect="bold">
plotData

</emphasis>
 method on the plotting object after 
	all of the data has been fed to the plotting object, as in 

<link id="a1178" target-id="Listing_3">

 Listing 3

</link>

 or 
	

<link id="a1179" target-id="Listing_4">

 Listing 4

</link>

.

</item>




</list>




</section>
</section>
<section id="h31014">
<title>
<emphasis id="Some_instance_variables" effect="bold">

Some instance variables

</emphasis>


</title>




<para id="p1101">
Continuing with the class definition for the class named 

<emphasis id="strong1097" effect="bold">
PlotALot01

</emphasis>
, 

<link id="a1180" target-id="Listing_5">

 Listing 5

</link>

 
shows several instance variables that belong to a plotting object instantiated 
from this class.

</para>





<table id="table1009" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1009">
<row id="tr1018">



<entry id="th1009">
<emphasis id="Listing_5" effect="bold">

Listing 5.

</emphasis>

 Some instance variables.


</entry>
</row>
</thead>


<tbody id="tbody1009">
<row id="tr1019">
<entry id="td1009">

		

<code id="pre1009" display="block">  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1102">
The purpose of each of these instance variables is indicated by the name of 
the variable, and in some cases by the comments following the variable 
declaration. In addition, I will have more to say about some of these variables 
later when I discuss the code that uses them.

</para>





<quote id="blockquote1011" display="block">

	

<para id="p1103">
<emphasis id="em1032" effect="italics">
(Note the use of
	

<link id="a1181" url="http://cnx.org/contents/4acd2bdb-ed66-4d33-92e4-463bc9308dc3/Java4210-Getting-Started-with-">


	generics

</link>

 in the declaration and initialization of the variable named
	

<emphasis id="strong1098" effect="bold">
pageLinks

</emphasis>
. The use of generics dictates that this class 
	requires J2SE 5.0 or later.)

</emphasis>
</para>





</quote>




</section>
<section id="h31015">
<title>
<emphasis id="The_first_overloaded_constructor" effect="bold">

The first overloaded constructor

</emphasis>


</title>




<para id="p1104">
As mentioned earlier, there are two overloaded versions of the constructor 
for this class. The overloaded version that begins in 

<link id="a1182" target-id="Listing_6">

 Listing 6

</link>

 accepts several 
incoming parameters allowing the user to control various aspects of the plotting 
format.

</para>





<quote id="blockquote1012" display="block">

	

<para id="p1105">
<emphasis id="em1033" effect="italics">
(A different overloaded version, which I will discuss later, accepts a 
	title string only and sets all of the plotting parameters to default 
	values.)

</emphasis>
</para>





</quote>




<table id="table1010" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1010">
<row id="tr1020">



<entry id="th1010">
<emphasis id="Listing_6" effect="bold">

Listing 6.

</emphasis>

 The first overloaded constructor.


</entry>
</row>
</thead>


<tbody id="tbody1010">
<row id="tr1021">
<entry id="td1010">

		

<code id="pre1010" display="block">  PlotALot01(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor code continues here</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1106">
<link id="a1183" target-id="Listing_6">

 Listing 6

</link>

 shows the signature for this overloaded version of the constructor. 
The comments should make the code self explanatory.

</para>





</section>
<section id="h31016">
<title>
<emphasis id="Save_the_parameter_values" effect="bold">

Save the parameter values

</emphasis>


</title>




<para id="p1107">
With one exception, the code in 

<link id="a1184" target-id="Listing_7">

 Listing 7

</link>

 simply saves the incoming parameter 
values in instance variables to make those values available to other members of 
the class.

</para>





<table id="table1011" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1011">
<row id="tr1022">



<entry id="th1011">
<emphasis id="Listing_7" effect="bold">

Listing 7.

</emphasis>

 Save the parameter values.


</entry>
</row>
</thead>


<tbody id="tbody1011">
<row id="tr1023">
<entry id="td1011">

		

<code id="pre1011" display="block">    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41034">
<title>
The exception

</title>




<para id="p1108">
The exception has to do with the parameter named 

<emphasis id="strong1099" effect="bold">
sampSpace

</emphasis>
. 
This parameter is provided by the user in units of pixels per sample, because 
that seems to be the most natural way for a human to specify this plotting 
parameter. However, for computational purposes, it is better to have the value 
of the number of pixels between samples, which is one less than the number of 
pixels per sample. This conversion is made during the saving of this parameter 
in 

<link id="a1185" target-id="Listing_7">

 Listing 7

</link>

.

</para>





</section>
</section>
<section id="h31017">
<title>
<emphasis id="A_temporary_Page_object" effect="bold">

A temporary Page object

</emphasis>


</title>




<para id="p1109">
As you will see later, the 

<emphasis id="strong1100" effect="bold">
Page

</emphasis>
 class consists of a 

<emphasis id="strong1101" effect="bold">

Canvas

</emphasis>
 contained in an

<emphasis id="strong1102" effect="bold">
 AWT Frame

</emphasis>
. Because an 

<emphasis id="strong1103" effect="bold">

AWT Frame

</emphasis>
 takes on the look and feel of the operating system under 
which the program is running, it may be constructed differently under different 
operating systems. Many important plotting parameters depend on the size of the


<emphasis id="strong1104" effect="bold">
Canvas

</emphasis>
, which depends on the values of the 

<emphasis id="strong1105" effect="bold">
insets

</emphasis>



<emphasis id="em1034" effect="italics">
(border width)

</emphasis>
 for the 

<emphasis id="strong1106" effect="bold">
Frame

</emphasis>
 for that particular operating system.

</para>





<quote id="blockquote1013" display="block">

	

<para id="p1110">
<emphasis id="em1035" effect="italics">
(A good exercise would be for you to convert this class to Swing 
	using a look and feel that is independent of the operating system.)

</emphasis>
</para>





</quote>




<para id="p1111">
The code in 

<link id="a1186" target-id="Listing_8">

 Listing 8

</link>

 instantiates a temporary 

<emphasis id="strong1107" effect="bold">
Page

</emphasis>
 object solely for the 
purpose of obtaining information about the width and the height of the 

<emphasis id="strong1108" effect="bold">
Canvas

</emphasis>
 
object. This information is used later to compute a variety of other important 
parameter values.

</para>





<table id="table1012" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1012">
<row id="tr1024">



<entry id="th1012">
<emphasis id="Listing_8" effect="bold">

Listing 8.

</emphasis>

 A temporary Page object.


</entry>
</row>
</thead>


<tbody id="tbody1012">
<row id="tr1025">
<entry id="td1012">

		

<code id="pre1012" display="block">    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31018">
<title>
<emphasis id="Display_some_information" effect="bold">

Display some information

</emphasis>


</title>




<para id="p1112">
<link id="a1187" target-id="Listing_9">

 Listing 9

</link>

 gets and displays information about the plotting object on the 
command line screen. An example of this 
output was shown earlier.

</para>





<table id="table1013" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1013">
<row id="tr1026">



<entry id="th1013">
<emphasis id="Listing_9" effect="bold">

Listing 9.

</emphasis>

 Display some information.

</entry>
</row>
</thead>


<tbody id="tbody1013">
<row id="tr1027">
<entry id="td1013">

		

<code id="pre1013" display="block">    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41035">
<title>
Terminate on negative value for sampSpacing

</title>




<para id="p1113">
In addition, 

<link id="a1188" target-id="Listing_9">

 Listing 9

</link>

 tests to confirm that the number of pixels between 
samples is not a negative value. If it is a negative value, 

<link id="a1189" target-id="Listing_9">

 Listing 9

</link>

 terminates 
the program immediately after the number of pixels per sample has been displayed

</para>





</section>
</section>
<section id="h31019">
<title>
<emphasis id="Dispose_of_the_temporary_Page_object" effect="bold">

Dispose of the temporary Page 
object

</emphasis>


</title>




<para id="p1114">
Once the width and height of the 

<emphasis id="strong1109" effect="bold">
Canvas

</emphasis>
 has been determined, the temporary 


<emphasis id="strong1110" effect="bold">
Page

</emphasis>
 object is no longer needed. 

<link id="a1190" target-id="Listing_10">

 Listing 10

</link>

 disposes of that object freeing all 
of the resources dedicated to the object.

</para>





<table id="table1014" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1014">
<row id="tr1028">



<entry id="th1014">
<emphasis id="Listing_10" effect="bold">

Listing 10.

</emphasis>

 Dispose of the temporary Page object.


</entry>
</row>
</thead>


<tbody id="tbody1014">
<row id="tr1029">
<entry id="td1014">

		

<code id="pre1014" display="block">    tempPage.dispose();</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31020">
<title>
<emphasis id="Compute_and_display_the_remaining_plotting_parameters" effect="bold">

Compute and 
display the remaining plotting parameters

</emphasis>


</title>




<para id="p1115">
Having determined the width and height of the 

<emphasis id="strong1111" effect="bold">
Canvas

</emphasis>
, 


<link id="a1191" target-id="Listing_11">

 Listing 11

</link>

 computes and displays the remaining plotting parameters. The 
expressions used to compute these values are straightforward and shouldn't 
require further explanation.

</para>





<table id="table1015" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1015">
<row id="tr1030">



<entry id="th1015">
<emphasis id="Listing_11" effect="bold">

Listing 11.

</emphasis>

 Compute and display the remaining 
plotting parameters.

</entry>
</row>
</thead>


<tbody id="tbody1015">
<row id="tr1031">
<entry id="td1015">

		

<code id="pre1015" display="block">    tracesPerPage = 
                 (canvasHeight - traceSpacing/2)/
                                    traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
    if(tracesPerPage == 0){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    samplesPerPage = canvasWidth * tracesPerPage/
                               (sampSpacing + 1);
    System.out.println("Samples per page: "
                               + samplesPerPage);</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41036">
<title>
Terminate on zero traces per page

</title>




<para id="p1116">
In addition, 

<link id="a1192" target-id="Listing_11">

 Listing 11

</link>

 terminates the program if it is determined that the 
number of traces per page is equal to zero. The reason for this should be 
obvious to the reader. If termination does occur, it occurs immediately after 
the number of traces per page has been displayed.

</para>





</section>
</section>
<section id="h31021">
<title>
<emphasis id="Instantiate_first_usable_Page_object" effect="bold">

Instantiate first usable Page 
object

</emphasis>


</title>




<para id="p1117">
<link id="a1193" target-id="Listing_12">

 Listing 12

</link>

 instantiates the first usable Page object. (Recall that a 
temporary Page object was instantiated and disposed of earlier.) This Page 
object will be titled title Page: 0 as indicated in 

<link id="a1194" target-id="Figure_1">

 Figure 1

</link>

 and 

<link id="a1195" target-id="Figure_5">

 Figure 5

</link>

.

</para>





<table id="table1016" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1016">
<row id="tr1032">



<entry id="th1016">
<emphasis id="Listing_12" effect="bold">

Listing 12.

</emphasis>

 Instantiate first usable Page object.

</entry>
</row>
</thead>


<tbody id="tbody1016">
<row id="tr1033">
<entry id="td1016">

		

<code id="pre1016" display="block">    pageLinks.add(new Page(title));
  }//end constructor</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1118">
Note that a reference to this 

<emphasis id="strong1112" effect="bold">
Page

</emphasis>
 object 

<emphasis id="em1036" effect="italics">
(and all 
subsequently instantiated Page objects)

</emphasis>
 is saved in an object of type


<emphasis id="strong1113" effect="bold">
ArrayList

</emphasis>
 referred to by 

<emphasis id="strong1114" effect="bold">
pageLinks

</emphasis>
. 

</para>





<para id="p1119">
<link id="a1196" target-id="Listing_12">

 Listing 12

</link>

 also signals the end of this constructor for the PlotALot01 class.

</para>





</section>
<section id="h31022">
<title>
<emphasis id="The_other_overloaded_constructor" effect="bold">

The other overloaded constructor

</emphasis>


</title>




<para id="p1120">
A second overloaded constructor is provided for those who don't want to have 
to think about plotting parameters. This constructor, which is shown in its 
entirety in 

<link id="a1197" target-id="Listing_13">

 Listing 13

</link>

, establishes a set of default plotting parameters.

</para>





<quote id="blockquote1014" display="block">

	

<para id="p1121">
<emphasis id="em1037" effect="italics">
(In case you are unfamiliar with the use of the keyword 

<emphasis id="strong1115" effect="bold">
this

</emphasis>
 to cause one 
	constructor to call another constructor of the same class, you can learn 
	about that topic in my module titled 

</emphasis>

	

<link id="a1198" url="http://cnx.org/contents/3b385770-09eb-4afa-8b02-725b0f59c17e/Java1628-The-this-and-super-Ke">


	

<emphasis id="em1038" effect="italics">
The Essence of OOP using Java, The this and super Keywords

</emphasis>
</link>


<emphasis id="em1039" effect="italics">
.)

</emphasis>
</para>





</quote>




<table id="table1017" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1017">
<row id="tr1034">



<entry id="th1017">
<emphasis id="Listing_13" effect="bold">

Listing 13.

</emphasis>

  


<emphasis id="The_other_overloaded_constructor0" effect="bold">

The other overloaded constructor

</emphasis>

.


</entry>
</row>
</thead>


<tbody id="tbody1017">
<row id="tr1035">
<entry id="td1017">

		

<code id="pre1017" display="block">  PlotALot01(String title){
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41037">
<title>
The default plotting parameter values

</title>




<para id="p1122">
This is where the default plotting parameters are specified as having the 
following values:

</para>





<list id="ul1018" list-type="bulleted">

	

<item id="li1131">
frameWidth: 400

</item>


	

<item id="li1132">
frameHeight: 410

</item>


	

<item id="li1133">
traceSpacing: 50

</item>


	

<item id="li1134">
sampSpace: 2

</item>


	

<item id="li1135">
ovalWidth: 2

</item>


	

<item id="li1136">
ovalHeight: 2

</item>




</list>




<para id="p1123">
As mentioned earlier, these values were chosen mainly to be compatible with 
this narrow publication format. You should feel free to change the default 
values to a set of values that is more consistent with your needs. For example, 
if you plan to plot and examine very large amounts of data, you might want to 
consider setting the 

<emphasis id="strong1116" effect="bold">
frameWidth

</emphasis>
 and 

<emphasis id="strong1117" effect="bold">
frameHeight

</emphasis>
 
to completely fill the screen on your computer. Then you can examine large 
amounts of data without the need to skip from one page to the next.

</para>





</section>
</section>
<section id="h31023">
<title>
<emphasis id="The_feedData_method" effect="bold">

The feedData method

</emphasis>


</title>




<para id="p1124">
The 

<emphasis id="strong1118" effect="bold">
feedData

</emphasis>
 method must be called on the plotting object 
once for each data value that is to be plotted. This method is shown in its 
entirety in 

<link id="a1199" target-id="Listing_14">

 Listing 14

</link>

.

</para>





<table id="table1018" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1018">
<row id="tr1036">



<entry id="th1018">
<emphasis id="Listing_14" effect="bold">

Listing 14.

</emphasis>

 The feedData method.


</entry>
</row>
</thead>


<tbody id="tbody1018">
<row id="tr1037">
<entry id="td1018">

		

<code id="pre1018" display="block">  void feedData(double val){
    if((sampleCounter) == samplesPerPage){
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    pageLinks.get(pageCounter).putData(
                              val,sampleCounter);
    sampleCounter++;
  }//end feedData</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41038">
<title>
Scaling of data to be plotted

</title>




<para id="p1125">
The 

<emphasis id="strong1119" effect="bold">
feedData

</emphasis>
 method receives an incoming data value of type


<emphasis id="strong1120" effect="bold">
double

</emphasis>
. This is probably a good time to point out that the data 
must be properly scaled for plotting before it is passed to this method.

</para>





<para id="p1126">
The incoming 

<emphasis id="strong1121" effect="bold">
double

</emphasis>
 value will later be cast to type 

<emphasis id="strong1122" effect="bold">

int

</emphasis>
. As you should already know, if the double value is too large to 
fit in type 

<emphasis id="strong1123" effect="bold">
int

</emphasis>
, the value resulting from the cast will be 
indeterminate. 

</para>





<para id="p1127">
In reality, however, the cast shouldn't be a problem. I'm unaware of any 
computer monitor whose vertical dimension is greater than a few thousand pixels. 
Regardless of the size of the 

<emphasis id="strong1124" effect="bold">
Page

</emphasis>
 object, a data value whose 
magnitude is greater than a few thousand units will be completely off the screen 
when plotted. Therefore, depending on the resolution of the monitor, the maximum 
magnitudes of the incoming data values should probably have been scaled to 1000 
or less to be suitable for plotting. 

</para>





</section>
<section id="h41039">
<title>
Is the page full?

</title>




<para id="p1128">
<link id="a1200" target-id="Listing_14">

 Listing 14

</link>

 first checks to see if the current page is full before attempting 
to plot the new data value. If the page is full, 

<link id="a1201" target-id="Listing_14">

 Listing 14

</link>

 increments the page 
counter, resets the sample counter, and instantiates a new 

<emphasis id="strong1125" effect="bold">
Page

</emphasis>
 
object.

</para>





</section>
<section id="h41040">
<title>
Save the data value for plotting later

</title>




<para id="p1129">
All of the data values are stored in array objects of type 

<emphasis id="strong1126" effect="bold">
double

</emphasis>
 
as they are fed to the plotting object. Later, when it is time to display the 
plotted version of the data, an overridden 

<emphasis id="strong1127" effect="bold">
paint

</emphasis>
 method 
accesses that data and produces the plot.

</para>





</section>
</section>
<section id="h31024">
<title>
<emphasis id="The_MyCanvas_class_a_preview" effect="bold">

The MyCanvas class, 
a preview

</emphasis>


</title>




<para id="p1130">
Each 

<emphasis id="strong1128" effect="bold">
Page

</emphasis>
 object contains an object of a class named 

<emphasis id="strong1129" effect="bold">
MyCanvas

</emphasis>
, which extends 
the 

<emphasis id="strong1130" effect="bold">
Canvas

</emphasis>
 class. Each 

<emphasis id="strong1131" effect="bold">
MyCanvas

</emphasis>
 object owns an array object in which the 


<emphasis id="strong1132" effect="bold">
double

</emphasis>
 
data values to be plotted on that page are stored.

</para>





<para id="p1131">
The 

<emphasis id="strong1133" effect="bold">
MyCanvas

</emphasis>
 class overrides the 

<emphasis id="strong1134" effect="bold">
paint

</emphasis>
 method to cause it to plot the data 
stored in the array whenever the overridden version of the 

<emphasis id="strong1135" effect="bold">
paint

</emphasis>
 method is 
called.

</para>





<quote id="blockquote1015" display="block">

	

<para id="p1132">
<emphasis id="em1040" effect="italics">
(If you are familiar with graphics in Java, you will already know that 
	the overridden 

<emphasis id="strong1136" effect="bold">
paint

</emphasis>
 method can be called for a variety of reasons, such as 
	covering and later uncovering the page. If you are not familiar with 
	graphics in Java, I discuss the overriding of the 

<emphasis id="strong1137" effect="bold">
paint

</emphasis>
 method in numerous 
	earlier modules including several modules on 

</emphasis>

	

<link id="a1202" url="http://cnx.org/contents/37c297a2-3c8f-4aa2-b0a6-93dbc4761001/Obg0250-Fun-with-Java">


	

<emphasis id="em1041" effect="italics">
animation

</emphasis>
</link>


<emphasis id="em1042" effect="italics">
 in Java.)

</emphasis>
</para>





</quote>




<para id="p1133">
I will have much more to say about the class named 

<emphasis id="strong1138" effect="bold">
MyCanvas

</emphasis>
 later.

</para>





<section id="h41041">
<title>
Call the putData method to store the data value

</title>




<para id="p1134">
For now, simply be aware that the 

<emphasis id="strong1139" effect="bold">
feedData

</emphasis>
 method in 

<link id="a1203" target-id="Listing_14">

 Listing 14

</link>

 calls the 


<emphasis id="strong1140" effect="bold">
putData

</emphasis>
 method on the current 

<emphasis id="strong1141" effect="bold">
Page

</emphasis>
 object to cause the data value to be stored 
in the array object belonging to the corresponding 

<emphasis id="strong1142" effect="bold">
MyCanvas

</emphasis>
 object. The current 
value of the sample counter is also passed to the 

<emphasis id="strong1143" effect="bold">
putData

</emphasis>
 method to specify the 
array element into which the data value is to be stored.

</para>





<para id="p1135">
Finally, the 

<emphasis id="strong1144" effect="bold">
feedData

</emphasis>
 method increments the sample counter and returns to 
await being called to receive the next data sample.

</para>





</section>
</section>
<section id="h31025">
<title>
<emphasis id="The_plotData_method" effect="bold">

The plotData method

</emphasis>


</title>




<para id="p1136">
The 

<emphasis id="strong1145" effect="bold">
plotData

</emphasis>
 method must be called once when all of the data has been fed to 
the plotting object by way of the 

<emphasis id="strong1146" effect="bold">
feedData

</emphasis>
 method. The purpose of the 


<emphasis id="strong1147" effect="bold">
plotData

</emphasis>
 
method is to rearrange the 

<emphasis id="strong1148" effect="bold">
Page

</emphasis>
 objects in a stack on the screen with page 0 


<emphasis id="em1043" effect="italics">
(containing the earliest data)

</emphasis>
 on the top of the stack.

</para>





<para id="p1137">
Having rearranged the 

<emphasis id="strong1149" effect="bold">
Page

</emphasis>
 objects, the 

<emphasis id="strong1150" effect="bold">
plotData

</emphasis>
 method causes the object on 
the top of the stack to become visible. This, in turn, causes its overridden 


<emphasis id="strong1151" effect="bold">
paint

</emphasis>
 method belonging to that object to be called, thus causing the data to be plotted as shown in 

<link id="a1204" target-id="Figure_1">

 Figure 1

</link>

 and 


<link id="a1205" target-id="Figure_5">

 Figure 5

</link>

.

</para>





<section id="h41042">
<title>
Two overloaded versions

</title>




<para id="p1138">
There are two overloaded versions of the 

<emphasis id="strong1152" effect="bold">
plotData

</emphasis>
 method. One version allows 
the user to specify the location on the screen where the stack of plotted pages 
will appear. The other version places the stack in the upper left corner of the 
screen by default.

</para>





</section>
<section id="h41043">
<title>
Specify the location of the stack

</title>




<para id="p1139">
The version of the 

<emphasis id="strong1153" effect="bold">
plotData

</emphasis>
 method that allows the user to specify the 
location begins in 

<link id="a1206" target-id="Listing_15">

 Listing 15

</link>

. This version receives two incoming parameters. 
These parameters specify the coordinates of the upper left corner of the stack 
of 

<emphasis id="strong1154" effect="bold">
Page

</emphasis>
 objects relative to the upper left corner of the screen. The first 
parameter specifies the horizontal coordinate and the second parameter specifies 
the vertical coordinate, with positive vertical values going down the screen.

</para>





<quote id="blockquote1016" display="block">

	

<para id="p1140">
<emphasis id="em1044" effect="italics">
(Specifying both coordinate values as 0 will cause the stack to appear in 
	the upper left corner of the screen.)

</emphasis>
</para>





</quote>




<table id="table1019" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1019">
<row id="tr1038">



<entry id="th1019">
<emphasis id="Listing_15" effect="bold">

Listing 15.

</emphasis>

 Beginning of the plotData method.


</entry>
</row>
</thead>


<tbody id="tbody1019">
<row id="tr1039">
<entry id="td1019">

		

<code id="pre1019" display="block">  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41044">
<title>
Make certain that the last page is visible

</title>




<para id="p1141">
As you will see later, each of the pages are displayed on the screen as they 
are produced. It is possible that this method could be called before the 
operating system has completed the process of making the last page visible. The 


<emphasis id="strong1155" effect="bold">
plotData

</emphasis>
 method uses a 

<emphasis id="strong1156" effect="bold">
while

</emphasis>
 loop to delay until the last page has become visible on the screen.

</para>





<para id="p1142">
At this point, the pages appear on the screen with the last page on the top 
of the stack. This order needs to be reversed to cause the first page to be on 
the top of the stack.

</para>





</section>
</section>
<section id="h31026">
<title>
<emphasis id="Make_all_pages_invisible" effect="bold">

Make all pages invisible

</emphasis>


</title>




<para id="p1143">
The reversal of the order of the pages in the stack is accomplished by first 
making every page invisible, and then making them visible again in reverse 
order.

</para>





<para id="p1144">
The code in 

<link id="a1207" target-id="Listing_16">

 Listing 16

</link>

 iterates on the 

<emphasis id="strong1157" effect="bold">
ArrayList

</emphasis>
 object 
containing references to all of the pages. The reference to each 

<emphasis id="strong1158" effect="bold">
Page

</emphasis>
 
object is obtained from the list, and its visible property value is set to 
false.

</para>





<table id="table1020" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1020">
<row id="tr1040">



<entry id="th1020">
<emphasis id="Listing_16" effect="bold">

Listing 16.

</emphasis>

 Make all pages invisible.


</entry>
</row>
</thead>


<tbody id="tbody1020">
<row id="tr1041">
<entry id="td1020">

		

<code id="pre1020" display="block">    Page tempPage = null;
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31027">
<title>
<emphasis id="Make_the_pages_visible_in_reverse_order" effect="bold">

Make the pages visible in 
reverse order

</emphasis>


</title>




<para id="p1145">
The code in 

<link id="a1208" target-id="Listing_17">

 Listing 17

</link>

 iterates on the 

<emphasis id="strong1159" effect="bold">
ArrayList

</emphasis>
 object 
again, accessing the references to the 

<emphasis id="strong1160" effect="bold">
Page

</emphasis>
 objects in reverse 
order and setting the value of the visible property for each 

<emphasis id="strong1161" effect="bold">
Page

</emphasis>
 object to 
true. This results in page 0 

<emphasis id="em1045" effect="italics">
(the page with the earliest data)

</emphasis>
 being on the top 
of the stack.

</para>





<table id="table1021" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1021">
<row id="tr1042">



<entry id="th1021">
<emphasis id="Listing_17" effect="bold">

Listing 17.

</emphasis>

 Make the pages visible in reverse order.


</entry>
</row>
</thead>


<tbody id="tbody1021">
<row id="tr1043">
<entry id="td1021">

		

<code id="pre1021" display="block">    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41045">
<title>
Set the location of the stack

</title>




<para id="p1146">
In addition, the code in 

<link id="a1209" target-id="Listing_17">

 Listing 17

</link>

 sets the location property of each 


<emphasis id="strong1162" effect="bold">
Page

</emphasis>
 
object to the coordinate values received as incoming parameters to the 

<emphasis id="strong1163" effect="bold">
plotData

</emphasis>
 
method. This causes the stack of 

<emphasis id="strong1164" effect="bold">
Page

</emphasis>
 objects to appear in the specified 
location on the screen.

</para>





</section>
</section>
<section id="h31028">
<title>
<emphasis id="The_other_overloaded_version_of_the_plotData_method" effect="bold">

The other overloaded version of the plotData method

</emphasis>


</title>




<para id="p1147">
The other overloaded version of the 

<emphasis id="strong1165" effect="bold">
plotData

</emphasis>
 method is shown in its entirety 
in 

<link id="a1210" target-id="Listing_18">

 Listing 18

</link>

.

</para>





<table id="table1022" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1022">
<row id="tr1044">



<entry id="th1022">
<emphasis id="Listing_18" effect="bold">

Listing 18.

</emphasis>

 The other overloaded version of the plotData method.


</entry>
</row>
</thead>


<tbody id="tbody1022">
<row id="tr1045">
<entry id="td1022">

		

<code id="pre1022" display="block">  void plotData(){
    plotData(0,0);//call overloaded version
  }//end plotData()</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1148">
This version receives no incoming parameters. The body of the method simply 
calls the first overloaded version discussed above, passing coordinate values as 
0,0 as parameters. As explained earlier, this causes the stack of 

<emphasis id="strong1166" effect="bold">
Page

</emphasis>
 
objects to appear in the upper left corner of the screen.

</para>





</section>
<section id="h31029">
<title>
<emphasis id="The_Page_class" effect="bold">

The Page class

</emphasis>


</title>




<para id="p1149">
<emphasis id="em1046" effect="italics">
The Page class is a 

</emphasis>



<link id="a1211" url="http://cnx.org/contents/842d95ee-aee3-4265-8bf5-a3ba2d53b228/Java-OOP-Member-Classes">




<emphasis id="em1047" effect="italics">
member

</emphasis>
</link>


<emphasis id="em1048" effect="italics">
 class of the class named 

</emphasis>
<emphasis id="strong1167" effect="bold">
<emphasis id="em1049" effect="italics">
PlotALot01

</emphasis>
</emphasis>
<emphasis id="em1050" effect="italics">
. 
As such, methods belonging to objects of the 

</emphasis>
<emphasis id="strong1168" effect="bold">
<emphasis id="em1051" effect="italics">
Page

</emphasis>
</emphasis>
<emphasis id="em1052" effect="italics">
 
class have direct access to all of the other members of the enclosing 

</emphasis>



<emphasis id="strong1169" effect="bold">
<emphasis id="em1053" effect="italics">
PlotALot01

</emphasis>
</emphasis>
<emphasis id="em1054" effect="italics">
 object, including instance variables 
belonging to the 

</emphasis>
<emphasis id="strong1170" effect="bold">
<emphasis id="em1055" effect="italics">
PlotALot01

</emphasis>
</emphasis>
<emphasis id="em1056" effect="italics">
 object.

</emphasis>
</para>





<quote id="blockquote1017" display="block">

	

<para id="p1150">
<emphasis id="em1057" effect="italics">
(If you are unfamiliar with member classes, see the module titled
	

</emphasis>

	

<link id="a1212" url="http://cnx.org/contents/842d95ee-aee3-4265-8bf5-a3ba2d53b228/Java-OOP-Member-Classes">


	

<emphasis id="em1058" effect="italics">
The Essence of OOP using Java, Member Classes

</emphasis>
</link>


<emphasis id="em1059" effect="italics">
.)

</emphasis>
</para>





</quote>




<section id="h41046">
<title>
Potentially many Page objects...

</title>




<para id="p1151">
A 

<emphasis id="strong1171" effect="bold">
PlotALot01

</emphasis>
 object may own as many 

<emphasis id="strong1172" effect="bold">
Page

</emphasis>
 
objects as are required to plot all of the data values that are fed to it.

</para>





<quote id="blockquote1018" display="block">

	

<para id="p1152">
<emphasis id="em1060" effect="italics">
(The reference to each 

<emphasis id="strong1173" effect="bold">
Page

</emphasis>
 object is stored in an
	

<emphasis id="strong1174" effect="bold">
ArrayList

</emphasis>
 object belonging to the 

<emphasis id="strong1175" effect="bold">
PlotALot01

</emphasis>
 
	object.)

</emphasis>
</para>





</quote>




<para id="p1153">
The 

<emphasis id="strong1176" effect="bold">
Page

</emphasis>
 class, which extends the 

<emphasis id="strong1177" effect="bold">
Frame

</emphasis>
 
class begins, in 

<link id="a1213" target-id="Listing_19">

 Listing 19

</link>

. The constructor for the 

<emphasis id="strong1178" effect="bold">
Page

</emphasis>
 class 
also begins in 

<link id="a1214" target-id="Listing_19">

 Listing 19

</link>

.

</para>





<table id="table1023" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1023">
<row id="tr1046">



<entry id="th1023">
<emphasis id="Listing_19" effect="bold">

Listing 19.

</emphasis>

 Beginning of the class named Page.


</entry>
</row>
</thead>


<tbody id="tbody1023">
<row id="tr1047">
<entry id="td1023">

		

<code id="pre1023" display="block">  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1154">
The 

<emphasis id="strong1179" effect="bold">
Page

</emphasis>
 class begins by declaring two instance variables. 
The instance variable named 

<emphasis id="strong1180" effect="bold">
canvas

</emphasis>
 will hold a reference to an 
object of the 

<emphasis id="strong1181" effect="bold">
MyCanvas

</emphasis>
 class upon which the data will actually 
be plotted.

</para>





<para id="p1155">
The other instance variable will hold the value of a sample counter.

</para>





</section>
<section id="h41047">
<title>
The constructor for the Page class

</title>




<para id="p1156">
The constructor that begins in 

<link id="a1215" target-id="Listing_19">

 Listing 19

</link>

 instantiates an object of a member 
class named 

<emphasis id="strong1182" effect="bold">
MyCanvas

</emphasis>
 and stores its reference in the reference 
variable named 

<emphasis id="strong1183" effect="bold">
canvas

</emphasis>
. Then it adds the 

<emphasis id="strong1184" effect="bold">
MyCanvas

</emphasis>
 
object to the default center location of the 

<emphasis id="strong1185" effect="bold">
Page

</emphasis>
 

<emphasis id="em1061" effect="italics">
(

<emphasis id="strong1186" effect="bold">
Frame

</emphasis>
)

</emphasis>
.

</para>





<para id="p1157">
Following this, the constructor accesses the variables named 

<emphasis id="strong1187" effect="bold">

frameWidth

</emphasis>
 and 

<emphasis id="strong1188" effect="bold">
frameHeight

</emphasis>
 belonging to the enclosing


<emphasis id="strong1189" effect="bold">
PlotALot01

</emphasis>
 object and uses those values to set the size of the


<emphasis id="strong1190" effect="bold">
Page

</emphasis>
.

</para>





<para id="p1158">
Then the constructor accesses the 

<emphasis id="strong1191" effect="bold">
title

</emphasis>
 and 

<emphasis id="strong1192" effect="bold">

pageCounter

</emphasis>
 variables belonging to the enclosing 

<emphasis id="strong1193" effect="bold">
PlotALot01

</emphasis>
 
object and uses those values to set the title for the 

<emphasis id="strong1194" effect="bold">
Page

</emphasis>
 
object.

</para>





<para id="p1159">
Finally, the code in 

<link id="a1216" target-id="Listing_19">

 Listing 19

</link>

 causes the 

<emphasis id="strong1195" effect="bold">
Page

</emphasis>
 object to 
become visible on the screen.

</para>





</section>
</section>
<section id="h31030">
<title>
<emphasis id="An_anonymous_terminator_for_the_Page_class" effect="bold">

An anonymous terminator 
for the Page class

</emphasis>


</title>




<para id="p1160">
Still inside the constructor, 

<link id="a1217" target-id="Listing_20">

 Listing 20

</link>

 instantiates an object of an 

<emphasis id="em1062" effect="italics">
anonymous 
inner class

</emphasis>
 to 
terminate the program when the user clicks on the close button on the Page 

<emphasis id="em1063" effect="italics">

(the X-button in the upper-right corner)

</emphasis>
.

</para>





<quote id="blockquote1019" display="block">

	

<para id="p1161">
<emphasis id="em1064" effect="italics">
(In case you are unfamiliar with anonymous inner classes, see my module titled
	

</emphasis>

	

<link id="a1218" url="http://cnx.org/contents/f0f81fa4-4b34-4c81-90eb-8fd9089724ef/Java-OOP-Anonymous-Classes">


	

<emphasis id="em1065" effect="italics">
The Essence of OOP using Java, Anonymous Classes

</emphasis>
</link>


<emphasis id="em1066" effect="italics">
.)

</emphasis>
</para>





</quote>




<table id="table1024" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1024">
<row id="tr1048">



<entry id="th1024">
<emphasis id="Listing_20" effect="bold">

Listing 20.

</emphasis>

 An anonymous terminator for the Page class.


</entry>
</row>
</thead>


<tbody id="tbody1024">
<row id="tr1049">
<entry id="td1024">

		

<code id="pre1024" display="block">      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
    }//end constructor</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1162">
<link id="a1219" target-id="Listing_20">

 Listing 20

</link>

 also signals the end of the constructor for the 

<emphasis id="strong1196" effect="bold">
Page

</emphasis>
 
class.

</para>





</section>
<section id="h31031">
<title>
<emphasis id="The_putData_method_of_the_Page_class" effect="bold">

The putData method of the 
Page class

</emphasis>


</title>




<para id="p1163">
This method, which is shown in its entirety in 

<link id="a1220" target-id="Listing_21">

 Listing 21

</link>

, receives a sample 
value of type 

<emphasis id="strong1197" effect="bold">
double

</emphasis>
 and also receives the sample counter associated with that 
data value. It uses the value of the sample counter to store the data value in 
an array object belonging to the 

<emphasis id="strong1198" effect="bold">
MyCanvas

</emphasis>
 object.

</para>





<table id="table1025" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1025">
<row id="tr1050">



<entry id="th1025">
<emphasis id="Listing_21" effect="bold">

Listing 21.

</emphasis>

 The putData method of the Page class.



</entry>
</row>
</thead>


<tbody id="tbody1025">
<row id="tr1051">
<entry id="td1025">

		

<code id="pre1025" display="block">    void putData(double sampleValue,
                 int sampleCounter){
      canvas.data[sampleCounter] = sampleValue;
      this.sampleCounter = sampleCounter;
    }//end putData</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1164">
In addition, the 

<emphasis id="strong1199" effect="bold">
putData

</emphasis>
 method saves the sample counter 
value in an instance variable to make it available to the overridden 

<emphasis id="strong1200" effect="bold">

paint

</emphasis>
 method later. This value is needed by the 

<emphasis id="strong1201" effect="bold">
paint

</emphasis>
 
method so it will know how many samples to plot on the final page which probably 
won't be full.

</para>





</section>
<section id="h31032">
<title>
<emphasis id="The_MyCanvas_class" effect="bold">

The MyCanvas class

</emphasis>


</title>




<para id="p1165">
The MyCanvas class, which begins in 

<link id="a1221" target-id="Listing_22">

 Listing 22

</link>

, is a member class of the Page 
class. As such, methods belonging to an object of the MyCanvas class have direct 
access to the other members of the enclosing Page object, including instance 
variables of the Page object. In addition, methods belonging to an object of the 
MyCanvas class have direct access to the other members, including instance 
variables, of the enclosing PlotALot01 object.

</para>





<table id="table1026" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1026">
<row id="tr1052">



<entry id="th1026">
<emphasis id="Listing_22" effect="bold">

Listing 22.

</emphasis>

 Beginning of the MyCanvas class.



</entry>
</row>
</thead>


<tbody id="tbody1026">
<row id="tr1053">
<entry id="td1026">

		

<code id="pre1026" display="block">    class MyCanvas extends Canvas{
      double [] data = 
                      new double[samplesPerPage];</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1166">
This class definition begins by creating a new array object of type 

<emphasis id="strong1202" effect="bold">

double

</emphasis>
 that will be used to store the data values belonging to the 
page. The size of the array is specified by the value of 

<emphasis id="strong1203" effect="bold">
samplesPerPage

</emphasis>
.

</para>





</section>
<section id="h31033">
<title>
<emphasis id="The_overridden_paint_method" effect="bold">

The overridden paint method

</emphasis>


</title>




<para id="p1167">
The overridden 

<emphasis id="strong1204" effect="bold">
paint

</emphasis>
 method of the 

<emphasis id="strong1205" effect="bold">
MyCanvas

</emphasis>
 
class begins in 

<link id="a1222" target-id="Listing_23">

 Listing 23

</link>

.

</para>





<table id="table1027" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1027">
<row id="tr1054">



<entry id="th1027">
<emphasis id="Listing_23" effect="bold">

Listing 23.

</emphasis>

 Beginning of the overridden paint 
method.


</entry>
</row>
</thead>


<tbody id="tbody1027">
<row id="tr1055">
<entry id="td1027">

		

<code id="pre1027" display="block">      public void paint(Graphics g){
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41048">
<title>
Draw the horizontal axes

</title>




<para id="p1168">
The code in 

<link id="a1223" target-id="Listing_23">

 Listing 23

</link>

 draws a set of horizontal axes on the 

<emphasis id="strong1206" effect="bold">
MyCanvas

</emphasis>
 
object, one for each trace that will be plotted on the object. These horizontal 
axes are shown in 

<link id="a1224" target-id="Figure_1">

 Figure 1

</link>

 and 

<link id="a1225" target-id="Figure_5">

 Figure 5

</link>

.

</para>





</section>
</section>
<section id="h31034">
<title>
<emphasis id="Plot_the_points" effect="bold">

Plot the points

</emphasis>


</title>




<para id="p1169">
<link id="a1226" target-id="Listing_24">

 Listing 24

</link>

 shows the beginning of the code that is used to plot the data 
values stored in the array that was created in 

<link id="a1227" target-id="Listing_22">

 Listing 22

</link>

.

</para>





<table id="table1028" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1028">
<row id="tr1056">



<entry id="th1028">
<emphasis id="Listing_24" effect="bold">

Listing 24.

</emphasis>

 Beginning of code to plot the points.

</entry>
</row>
</thead>


<tbody id="tbody1028">
<row id="tr1057">
<entry id="td1028">

		

<code id="pre1028" display="block">        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
            //Compute a vertical offset
            int yOffset = 
                   (1 + cnt*(sampSpacing + 1)/
                   this.getWidth())*traceSpacing;</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1170">
<link id="a1228" target-id="Listing_24">

 Listing 24

</link>

 begins by testing the value of the sample counter to make certain 
that there are some points to be plotted. If so, it enters a 

<emphasis id="strong1207" effect="bold">
for

</emphasis>
 
loop to plot each data value stored in the array. Because it uses the value of 
the sample counter to terminate the 

<emphasis id="strong1208" effect="bold">
for

</emphasis>
 loop, only those data 
values that have been stored in the array object will be plotted, even if the 
array object isn't full.

</para>





<section id="h41049">
<title>
A vertical offset

</title>




<para id="p1171">
The data values in the array are to be plotted on one or more horizontal axes 
on the page. Therefore, it is necessary to first determine where on the page 
each data value is to be plotted. The code in 

<link id="a1229" target-id="Listing_24">

 Listing 24

</link>

 uses various pieces of 
information to determine the vertical location of the axis against which each 
data value will be plotted.

</para>





</section>
</section>
<section id="h31035">
<title>
<emphasis id="Draw_an_oval" effect="bold">

Draw an oval

</emphasis>


</title>




<para id="p1172">
The code in 

<link id="a1230" target-id="Listing_25">

 Listing 25

</link>

 draws an oval centered on the sample value to mark the 
sample on the plot. It is best if the dimensions of the oval are evenly 
divisible by 2 for centering purposes. Otherwise, the ovals may appear to be a 
little off center.

</para>





<table id="table1029" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1029">
<row id="tr1058">



<entry id="th1029">
<emphasis id="Listing_25" effect="bold">

Listing 25.

</emphasis>

 Draw an oval.


</entry>
</row>
</thead>


<tbody id="tbody1029">
<row id="tr1059">
<entry id="td1029">

		

<code id="pre1029" display="block">            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)data[cnt] - ovalHeight/2,
              ovalWidth,
              ovalHeight);</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41050">
<title>
Is positive vertical up or down?

</title>




<para id="p1173">
Normally vertical coordinates increase going down the screen in Java 
graphics. However, this isn't what most of us are accustomed to seeing when we 
plot data. We prefer to see increasing vertical coordinates going up the page. 
The code in 

<link id="a1231" target-id="Listing_25">

 Listing 25

</link>

 reverses the sign on the data values to cause positive 
data values to be plotted above the axis and negative data values to be plotted 
below the axis. Increasing values go up. Decreasing values go down.

</para>





</section>
</section>
<section id="h31036">
<title>
<emphasis id="Connect_the_points_with_straight_lines" effect="bold">

Connect the points with 
straight lines

</emphasis>


</title>




<para id="p1174">
The code in 

<link id="a1232" target-id="Listing_26">

 Listing 26

</link>

 connects the sample values with straight lines. Care 
is taken to avoid drawing a line from the last sample value on one trace to the 
first sample value on the next trace. That would really be ugly.

</para>





<table id="table1030" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1030">
<row id="tr1060">



<entry id="th1030">
<emphasis id="Listing_26" effect="bold">

Listing 26.

</emphasis>

 Connect the points with straight lines.


</entry>
</row>
</thead>


<tbody id="tbody1030">
<row id="tr1061">
<entry id="td1030">

		

<code id="pre1030" display="block">            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)data[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)data[cnt]);
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot01</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31037">
<title>
<emphasis id="End_of_the_PlotALot01_class" effect="bold">

End of the PlotALot01 class

</emphasis>


</title>




<para id="p1175">
<link id="a1233" target-id="Listing_26">

 Listing 26

</link>

 also signals the end of the overridden 

<emphasis id="strong1209" effect="bold">
paint

</emphasis>
 
method, the end of the 

<emphasis id="strong1210" effect="bold">
MyCanvas

</emphasis>
 class, the end of the 

<emphasis id="strong1211" effect="bold">

Page

</emphasis>
 class, and the end of the 

<emphasis id="strong1212" effect="bold">
PlotALot01

</emphasis>
 class. In 
short, 

<link id="a1234" target-id="Listing_26">

 Listing 26

</link>

 signals the end of the class under discussion.

</para>





</section>
</section>
<section id="h21007">
<title>
<emphasis id="The_class_named_PlotALot02" effect="bold">

The class named PlotALot02

</emphasis>


</title>




<para id="p1176">
Much of the code in this class is very similar to the code in the class named 


<emphasis id="strong1213" effect="bold">
PlotALot01

</emphasis>
. Therefore, the discussion of this class will be much briefer than 
the earlier discussion of the class named 

<emphasis id="strong1214" effect="bold">
PlotALot01

</emphasis>
.

</para>





<section id="h31038">
<title>
<emphasis id="Designed_for_two-channel_data" effect="bold">

Designed for two-channel data

</emphasis>


</title>




<para id="p1177">
This class is an update to the class named 

<emphasis id="strong1215" effect="bold">
PlotALot01

</emphasis>
. This class is designed 
to plot large amounts of data for two channels on the same axes as shown in 


<link id="a1235" target-id="Figure_2">

 Figure 2

</link>

. One set of data is plotted using the color black. The other set of 
data is plotted using the color red.

</para>





<para id="p1178">
As is the case for the class named 

<emphasis id="strong1216" effect="bold">
PlotALot01

</emphasis>
, this class provides a 


<emphasis id="strong1217" effect="bold">
main

</emphasis>
 method so that the class can be run as an application in 
self-test mode.

</para>





<section id="h41051">
<title>
Three steps to use the class

</title>




<para id="p1179">
As before, there are three steps involved in the use of this class for 
plotting data:

</para>





<list id="ol1003" list-type="enumerated">

	

<item id="li1137">
Instantiate a plotting object of type 

<emphasis id="strong1218" effect="bold">
PlotALot02

</emphasis>
.

</item>


	

<item id="li1138">
Feed pairs of data values to the plotting object by calling the 

<emphasis id="strong1219" effect="bold">
feedData

</emphasis>
 
	method once for each pair of data values. The first value in the pair will 
	be plotted in black. The second value in the pair will be plotted in red.

</item>


	

<item id="li1139">
Call the 

<emphasis id="strong1220" effect="bold">
plotData

</emphasis>
 method on the plotting object after all of the data 
	has been fed to the object. This causes all of the data to be plotted. It 
	also causes the pages to be rearranged placing page 0 on the top of the 
	stack.

</item>




</list>




</section>
<section id="h41052">
<title>
A stack of Page objects

</title>




<para id="p1180">
The class produces a graphic output consisting of a stack of 

<emphasis id="strong1221" effect="bold">
Page

</emphasis>
 objects on 
the screen. Each 

<emphasis id="strong1222" effect="bold">
Page

</emphasis>
 object contains one or more horizontal axes on which the 
data is plotted as shown in 

<link id="a1236" target-id="Figure_2">

 Figure 2

</link>

. The two data sets are superimposed on the 
same axes with the data from one data set being plotted in black and the data 
from the other data set being plotted in red.

</para>





</section>
<section id="h41053">
<title>
Testing with the main method

</title>




<para id="p1181">
For test purposes, the 

<emphasis id="strong1223" effect="bold">
main

</emphasis>
 method instantiates a single plotting object and 
feeds two data sets to that plotting object. As before, the data that is fed to 
the plotting object is white random noise. One of the data sets is the sequence 
of values obtained from a random number generator. The other data set is the 
same as the first except that the sign of each data values is reversed.

</para>





</section>
<section id="h41054">
<title>
Some data is not random

</title>




<para id="p1182">
Also as before, and for the same reason, fifteen of the data values for each 
data set are not random. The non-random data values are the same as in the 


<emphasis id="strong1224" effect="bold">
main

</emphasis>
 
method for the class named 

<emphasis id="strong1225" effect="bold">
PlotALot01

</emphasis>
. 

<link id="a1237" target-id="Figure_2">

 Figure 2

</link>

 illustrates how these fifteen 
specific values are used to confirm the proper transition from the end of one 
trace to the beginning of the next trace, and also to confirm the proper 
transition from the end of one page to the beginning of the next page.

</para>





</section>
</section>
<section id="h31039">
<title>
<emphasis id="The_class_named_PlotALot02_and_the_main_method" effect="bold">

The class named PlotALot02 and the main method

</emphasis>


</title>




<para id="p1183">
As before, I will discuss this class in fragments. A complete listing of the 
class is provided in 

<link id="a1238" target-id="Listing_36">

 Listing 36

</link>

 near the end of the module. However, because 
much of the code in this class is very similar to code that I explained for the 
class named 

<emphasis id="strong1226" effect="bold">
PlotALot01

</emphasis>
, this discussion of the code will be much briefer. I will 
highlight those aspects of this code that are different from the code in 


<emphasis id="strong1227" effect="bold">
PlotALot01

</emphasis>
.

</para>





<para id="p1184">
The beginning of the class and an abbreviated version of the 

<emphasis id="strong1228" effect="bold">
main

</emphasis>
 method is 
provided in 

<link id="a1239" target-id="Listing_27">

 Listing 27

</link>

. Much of the code has been deleted from 

<link id="a1240" target-id="Listing_27">

 Listing 27

</link>

 for 
brevity.

</para>





<table id="table1031" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1031">
<row id="tr1062">



<entry id="th1031">
<emphasis id="Listing_27" effect="bold">

Listing 27.

</emphasis>

 The class named PlotALot02 and the main method.


</entry>
</row>
</thead>


<tbody id="tbody1031">
<row id="tr1063">
<entry id="td1031">

		

<code id="pre1031" display="block">public class PlotALot02{
  public static void main(String[] args){
    PlotALot02 plotObjectA = 
            new PlotALot02("A",158,237,36,5,4,4);
    
    for(int cnt = 0;cnt &lt; 275;cnt++){
      double valBlack = (Math.random() - 0.5)*25;
      double valRed = -valBlack;
      //Feed pairs of values to the plotting
      // object by calling the feedData method
      // once for each pair of data values.
      if(cnt == 147){
        plotObjectA.feedData(0,0);

      //...code deleted for brevity

      }else{
        plotObjectA.feedData(valBlack,valRed);
      }//end else
    }//end for loop
    //Cause the data to be plotted in the default
    // screen location.
    plotObjectA.plotData();
  }//end main</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41055">
<title>
Two data values are required

</title>




<para id="p1185">
The important thing to note in 

<link id="a1241" target-id="Listing_27">

 Listing 27

</link>

 is that two data values must be 
passed to the 

<emphasis id="strong1229" effect="bold">
feedData

</emphasis>
 method each time it is called. This 
consists of one data value from each channel of data being plotted.

</para>





</section>
</section>
<section id="h31040">
<title>
<emphasis id="ThefeedDatamethod" effect="bold">

The feedData method

</emphasis>


</title>




<para id="p1186">
The modified 

<emphasis id="strong1230" effect="bold">
feedData

</emphasis>
 method is shown in its entirety in 

<link id="a1242" target-id="Listing_28">

 Listing 28

</link>

.

</para>





<table id="table1032" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1032">
<row id="tr1064">



<entry id="th1032">
<emphasis id="Listing_28" effect="bold">

Listing 28.

</emphasis>

 The feedData method.


</entry>
</row>
</thead>


<tbody id="tbody1032">
<row id="tr1065">
<entry id="td1032">

		

<code id="pre1032" display="block">  void feedData(double valBlack,double valRed){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample values in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample values pass through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                  valBlack,valRed,sampleCounter);
    sampleCounter++;
  }//end feedData</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1187">
The most significant things to note about the modified version of the 

<emphasis id="strong1231" effect="bold">

feedData

</emphasis>
 method are:

</para>





<list id="ul1019" list-type="bulleted">

	

<item id="li1140">
The method receives two incoming data values as parameters instead of 
	just one.

</item>


	

<item id="li1141">
The method passes the two data values, along with the sample counter 
	value to the 

<emphasis id="strong1232" effect="bold">
putData

</emphasis>
 method of the 

<emphasis id="strong1233" effect="bold">
PlotALot02

</emphasis>
 
	class. Thus, the 

<emphasis id="strong1234" effect="bold">
putData

</emphasis>
 method has also been modified to 
	require two incoming data values.

</item>




</list>




</section>
<section id="h31041">
<title>
<emphasis id="The_putData_method" effect="bold">

The putData method

</emphasis>


</title>




<para id="p1188">
The modified putData method is shown in its entirety in 

<link id="a1243" target-id="Listing_29">

 Listing 29

</link>

. This 
modified version of the method receives a pair of data values and stores each of 
the data values in a different array object belonging to the MyCanvas object.

</para>





<table id="table1033" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1033">
<row id="tr1066">



<entry id="th1033">
<emphasis id="Listing_29" effect="bold">

Listing 29.

</emphasis>

 The putData method.


</entry>
</row>
</thead>


<tbody id="tbody1033">
<row id="tr1067">
<entry id="td1033">

		

<code id="pre1033" display="block">    void putData(double valBlack,double valRed,
                              int sampleCounter){
      canvas.blackData[sampleCounter] = valBlack;
      canvas.redData[sampleCounter] = valRed;
      this.sampleCounter = sampleCounter;
    }//end putData</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31042">
<title>
<emphasis id="TheMyCanvasclass" effect="bold">

The MyCanvas class

</emphasis>


</title>




<para id="p1189">
The modified version of the 

<emphasis id="strong1235" effect="bold">
MyCanvas

</emphasis>
 class begins in 

<link id="a1244" target-id="Listing_30">

 Listing 30

</link>

.

</para>





<table id="table1034" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1034">
<row id="tr1068">



<entry id="th1034">
<emphasis id="Listing_30" effect="bold">

Listing 30.

</emphasis>

 Beginning of the MyCanvas class.


</entry>
</row>
</thead>


<tbody id="tbody1034">
<row id="tr1069">
<entry id="td1034">

		

<code id="pre1034" display="block">    class MyCanvas extends Canvas{
      double [] blackData = 
                      new double[samplesPerPage];
      double [] redData = 
                      new double[samplesPerPage];</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1190">
The class begins by creating two different array objects in which incoming 
data is stored instead of just one array object. These are the objects that are 
populated by the 

<emphasis id="strong1236" effect="bold">
putData

</emphasis>
 method in 

<link id="a1245" target-id="Listing_29">

 Listing 29

</link>

.

</para>





</section>
<section id="h31043">
<title>
<emphasis id="Theoverriddenpaintmethod" effect="bold">

The overridden paint method

</emphasis>


</title>




<para id="p1191">
The modified version of the overridden paint method begins in 

<link id="a1246" target-id="Listing_31">

 Listing 31

</link>

. 
Most of the code was deleted for brevity from 

<link id="a1247" target-id="Listing_31">

 Listing 31

</link>

 because it is very 
similar to the code in the overridden paint method in the class named 
PlotALot01.

</para>





<table id="table1035" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1035">
<row id="tr1070">



<entry id="th1035">
<emphasis id="Listing_31" effect="bold">

Listing 31.

</emphasis>

 Beginning of the overridden paint method.



</entry>
</row>
</thead>


<tbody id="tbody1035">
<row id="tr1071">
<entry id="td1035">

		

<code id="pre1035" display="block">      public void paint(Graphics g){
        //Draw horizontal axes
        //... code deleted for brevity
        
        //Plot the points.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
            //Compute a vertical offset.
            //...code deleted for brevity

            //Begin by plotting the values from
            // the blackData array object.
            //Draw an oval.
            g.setColor(Color.BLACK);
            //...code deleted for brevity
            
            //Connect the sample values with
            // straight lines.
            //...code deleted for brevity</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41056">
<title>
Setting the drawing color

</title>




<para id="p1192">
The most significant thing in 

<link id="a1248" target-id="Listing_31">

 Listing 31

</link>

 is the call to the 

<emphasis id="strong1237" effect="bold">
setColor

</emphasis>
 method of the Graphics class to set the drawing color to 
black. Otherwise, the code is essentially the same as the code in the overridden


<emphasis id="strong1238" effect="bold">
paint

</emphasis>
 method in 

<emphasis id="strong1239" effect="bold">
PlotALot01

</emphasis>
. The code in 


<link id="a1249" target-id="Listing_31">

 Listing 31

</link>

 draws the black traces shown in 

<link id="a1250" target-id="Figure_2">

 Figure 2

</link>

.

</para>





</section>
</section>
<section id="h31044">
<title>
<emphasis id="New_code_in_the_overridden_paint_method" effect="bold">

New code in the overridden 
paint method

</emphasis>


</title>




<para id="p1193">
The overridden version of the paint 

<emphasis id="strong1240" effect="bold">
method

</emphasis>
 continues in 


<link id="a1251" target-id="Listing_32">

 Listing 32

</link>

. The code in 

<link id="a1252" target-id="Listing_32">

 Listing 32

</link>

 is essentially all new code that was created 
to plot the second data set in red. However, the only real difference between 
this code and code that I explained earlier with respect to the class named 


<emphasis id="strong1241" effect="bold">
PlotALot01

</emphasis>
 is:

</para>





<list id="ul1020" list-type="bulleted">

	

<item id="li1142">
The drawing color has been set to red instead of the default color of 
	black.

</item>


	

<item id="li1143">
The data being plotted is the second set of data. This data is stored in 
	the array object referred to by 

<emphasis id="strong1242" effect="bold">
redData

</emphasis>
.

</item>




</list>




<para id="p1194">
Otherwise, this code is essentially the same as the code that was used to 
plot the single data set in the overridden paint method in the class named 


<emphasis id="strong1243" effect="bold">
PlotALot01

</emphasis>
.

</para>





<table id="table1036" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1036">
<row id="tr1072">



<entry id="th1036">
<emphasis id="Listing_32" effect="bold">

Listing 32.

</emphasis>

 New code in the overridden paint method.



</entry>
</row>
</thead>


<tbody id="tbody1036">
<row id="tr1073">
<entry id="td1036">

		

<code id="pre1036" display="block">            //Now plot the data stored in the
            // redData array object.
            g.setColor(Color.RED);
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)redData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt]);
                
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot02</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1195">
The code in 

<link id="a1253" target-id="Listing_32">

 Listing 32

</link>

 draws the red traces shown in 

<link id="a1254" target-id="Figure_2">

 Figure 2

</link>

.

</para>





<section id="h41057">
<title>
End of class PlotALot02

</title>




<para id="p1196">
<link id="a1255" target-id="Listing_32">

 Listing 32

</link>

 signals the end of the overridden 

<emphasis id="strong1244" effect="bold">
paint

</emphasis>
 method, 
the 

<emphasis id="strong1245" effect="bold">
MyCanvas

</emphasis>
 class, the 

<emphasis id="strong1246" effect="bold">
Page

</emphasis>
 class, and the


<emphasis id="strong1247" effect="bold">
PlotALot02

</emphasis>
 class.

</para>





</section>
</section>
</section>
<section id="h21008">
<title>
<emphasis id="The_class_named_PlotALot03" effect="bold">

The class named PlotALot03

</emphasis>


</title>




<para id="p1197">
I will discuss the class named 

<emphasis id="strong1248" effect="bold">
PlotALot03

</emphasis>
 in fragments. A 
complete listing of the class is provided in 

<link id="a1256" target-id="Listing_37">

 Listing 37

</link>

 near the end of the 
module. 

</para>





<para id="p1198">
Much of the code in the class named 

<emphasis id="strong1249" effect="bold">
PlotALot03

</emphasis>
 is very 
similar to the code in 

<emphasis id="strong1250" effect="bold">
PlotALot02

</emphasis>
. Therefore, this discussion 
will be brief, simply highlighting the differences between the two classes. 

</para>





<section id="h31045">
<title>
<emphasis id="Two-channel_data_on_alternating_axes_" effect="bold">

Two-channel data on 
alternating axes 

</emphasis>


</title>




<para id="p1199">
This class is an update to the class named 

<emphasis id="strong1251" effect="bold">
PlotALot02

</emphasis>
. This 
class is designed to plot large amounts of data for two channels on alternating 
horizontal axes. One set of data is plotted using the color black. The other set 
of data is plotted using the color red. 

</para>





<section id="h41058">
<title>
Three steps for using the class 

</title>




<para id="p1200">
As before, there are three steps involved in the use of this class for 
plotting two-channel data:

</para>





<list id="ol1004" list-type="enumerated">

	

<item id="li1144">
Instantiate a plotting object of type 

<emphasis id="strong1252" effect="bold">
PlotALot03

</emphasis>
.

</item>


	

<item id="li1145">
Feed pairs of data values to the plotting object by calling the 

<emphasis id="strong1253" effect="bold">

	feedData

</emphasis>
 method once for each pair of data values. The first value 
	in the pair will be plotted in black on one axis. The second value in the 
	pair will be plotted in red on an axis below that one.

</item>


	

<item id="li1146">
Call the 

<emphasis id="strong1254" effect="bold">
plotData

</emphasis>
 method on the plotting object when 
	all of the data has been fed to the object. This causes all of the data to 
	be plotted and also causes the 

<emphasis id="strong1255" effect="bold">
Page

</emphasis>
 objects to be 
	rearranged so that page 0 is on the top of the stack.

</item>




</list>




</section>
<section id="h41059">
<title>
A stack of Page objects 

</title>




<para id="p1201">
The class produces a graphic output consisting of a stack of 

<emphasis id="strong1256" effect="bold">
Page

</emphasis>
 
objects on the screen, with the data plotted on a 

<emphasis id="strong1257" effect="bold">
Canvas

</emphasis>
 object 
contained in the 

<emphasis id="strong1258" effect="bold">
Page

</emphasis>
 object. 

</para>





<para id="p1202">
Each 

<emphasis id="strong1259" effect="bold">
Page

</emphasis>
 object contains two or more horizontal axes on 
which the data is plotted. The class will terminate if the number of axes on the 
page is an odd number. 

</para>





</section>
<section id="h41060">
<title>
Alternating axes 

</title>




<para id="p1203">
The two data sets are plotted on alternating axes as shown in 

<link id="a1257" target-id="Figure_3">

 Figure 3

</link>

 with 
the data from one data set being plotted in black on one axis and the data from 
the other data set being plotted in red on the axis below that axis. 

</para>





<para id="p1204">
The earliest data is plotted on the pair of axes nearest the top of the page 
moving from left to right across the page. Positive data values are plotted 
above the axis and negative values are plotted below the axis. 

</para>





<para id="p1205">
When the right end of an axis is reached, the next data value is plotted on 
the left end of the second axis below it skipping one axis in the process. When 
the right end of the last pair of axes on the page is reached, a new 

<emphasis id="strong1260" effect="bold">

Page

</emphasis>
 object is created and the next pair of data values are plotted at 
the left end of the top pair of axes on that new page. 

</para>





</section>
<section id="h41061">
<title>
Testing with the main method 

</title>




<para id="p1206">
For self-test purposes, the 

<emphasis id="strong1261" effect="bold">
main

</emphasis>
 method instantiates a 
single plotting object and feeds two data sets to that plotting object. The data 
that is fed to the plotting object is white random noise. One of the data sets 
is the sequence of values obtained from a random number generator. The other 
data set is the same as the first. Thus, the pairs of black and red data sets 
that are plotted should have the same shape making it easy to confirm that the 
process of plotting the two data sets is behaving the same in both cases. 

</para>





</section>
<section id="h41062">
<title>
Some data is not random 

</title>




<para id="p1207">
Fifteen of the data values for each data set are not random for the same 
reasons discussed earlier. 

<link id="a1258" target-id="Figure_3">

 Figure 3

</link>

 shows how these specific values confirm 
proper transition from one trace to the next on the same page and confirm the 
proper transition from one page to the next. 

</para>





</section>
</section>
<section id="h31046">
<title>
<emphasis id="Modified_constructor_code" effect="bold">

Modified constructor code

</emphasis>


</title>




<para id="p1208">
The first code that I will highlight as being different from the code in the 
class named 

<emphasis id="strong1262" effect="bold">
PlotALot02

</emphasis>
 is shown in 

<link id="a1259" target-id="Listing_33">

 Listing 33

</link>

. This code 
appears in the modified constructor for the 

<emphasis id="strong1263" effect="bold">
PlotALot03

</emphasis>
 class.

</para>





<table id="table1037" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1037">
<row id="tr1074">



<entry id="th1037">
<emphasis id="Listing_33" effect="bold">

Listing 33.

</emphasis>

 Modified constructor code.


</entry>
</row>
</thead>


<tbody id="tbody1037">
<row id="tr1075">
<entry id="td1037">

		

<code id="pre1037" display="block">    if((tracesPerPage == 0) || 
                        (tracesPerPage%2 != 0) ){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if

    samplesPerPage = canvasWidth * tracesPerPage/
                             (sampSpacing + 1)/2;</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1209">
The 

<emphasis id="strong1264" effect="bold">
if

</emphasis>
 statement in 

<link id="a1260" target-id="Listing_33">

 Listing 33

</link>

 confirms that the number of 
traces per page is evenly divisible by two. If not, the program terminates.

</para>





<para id="p1210">
The last statement in 

<link id="a1261" target-id="Listing_33">

 Listing 33

</link>

 computes the value of 

<emphasis id="strong1265" effect="bold">
samplesPerPage

</emphasis>
 
taking into account that only half as many samples from each data set can be 
plotted on a page as is the case when the plots of the two data sets are 
superimposed on the same axes in the class named 

<emphasis id="strong1266" effect="bold">
PlotALot02

</emphasis>
.

</para>





</section>
<section id="h31047">
<title>
<emphasis id="Thezoverriddenzpaintzmethod" effect="bold">

The overridden paint method

</emphasis>


</title>




<para id="p1211">
Additional code that I will highlight as being different is in the overridden 


<emphasis id="strong1267" effect="bold">
paint

</emphasis>
 method of the 

<emphasis id="strong1268" effect="bold">
MyCanvas

</emphasis>
 class. This code 
is shown in 

<link id="a1262" target-id="Listing_34">

 Listing 34

</link>

.

</para>





<table id="table1038" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1038">
<row id="tr1076">



<entry id="th1038">
<emphasis id="Listing_34" effect="bold">

Listing 34.

</emphasis>

 The overridden paint method.


</entry>
</row>
</thead>


<tbody id="tbody1038">
<row id="tr1077">
<entry id="td1038">

		

<code id="pre1038" display="block">      public void paint(Graphics g){
        //Draw horizontal axes
        //...code deleted for brevity
        
        //Plot the points
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
                                            
            //Plot values from the blackData 
            // array object.
            g.setColor(Color.BLACK);
            
            //Compute a vertical offset to locate
            // the black data on the odd numbered
            // axes on the page.
            int yOffset = 
               ((1 + cnt*(sampSpacing + 1)/
                this.getWidth())*2*traceSpacing)
                                  - traceSpacing;

            //Draw an oval
            //...code deleted for brevity
            //Connect the sample values with
            // straight lines.
            //...code deleted for brevity
            
            //Plot the data stored in the
            // redData array object.
            g.setColor(Color.RED);
            //Compute a vertical offset to locate
            // the red data on the even numbered
            // axes on the page.
            yOffset = (1 + cnt*(sampSpacing + 1)/
                 this.getWidth())*2*traceSpacing;
            
            //Draw the ovals
            //...code deleted for brevity
            //Connect the sample values with
            // straight lines
            //...code deleted for brevity

          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot02</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41063">
<title>
Some code was deleted for brevity

</title>




<para id="p1212">
Most of the code in the overridden 

<emphasis id="strong1269" effect="bold">
paint

</emphasis>
 method is the same 
as the code that I discussed earlier and was deleted from 

<link id="a1263" target-id="Listing_34">

 Listing 34

</link>

 for 
brevity.

</para>





<para id="p1213">
The code that is different is the code that computes the vertical offset 
values to locate the black data on the odd numbered axes and to locate the red 
data on the even numbered axes as shown in 

<link id="a1264" target-id="Figure_3">

 Figure 3

</link>

. I will let you work through 
the expressions in 

<link id="a1265" target-id="Listing_34">

 Listing 34

</link>

 on your own and convince yourself that the code is 
correct.

</para>





</section>
<section id="h41064">
<title>
End of class PlotALot03

</title>




<para id="p1214">
<link id="a1266" target-id="Listing_34">

 Listing 34

</link>

 signals the end of the overridden 

<emphasis id="strong1270" effect="bold">
paint

</emphasis>
 method, 
the 

<emphasis id="strong1271" effect="bold">
MyCanvas

</emphasis>
 class, the 

<emphasis id="strong1272" effect="bold">
Page

</emphasis>
 class, and the


<emphasis id="strong1273" effect="bold">
PlotALot03

</emphasis>
 class.

</para>





</section>
</section>
</section>
<section id="h21009">
<title>
<emphasis id="The_class_named_PlotALot04" effect="bold">

The class named PlotALot04

</emphasis>


</title>




<para id="p1215">
This class is an update to the class named 

<emphasis id="strong1274" effect="bold">
PlotALot03

</emphasis>
. This 
class is designed to plot large amounts of three-channel data on separate 
horizontal axes. One set of data is plotted using the color black. The second 
set of data is plotted using the color red. The third set of data is plotted 
using the color blue.

</para>





<para id="p1216">
The class provides a 

<emphasis id="strong1275" effect="bold">
main

</emphasis>
 method so that the class can be 
run as an application to test itself. 

</para>





<section id="h31048">
<title>
<emphasis id="Three_steps_for_using_the_class" effect="bold">

Three steps for using the class

</emphasis>


</title>




<para id="p1217">
There are three steps involved in the use of this class for plotting data:

</para>





<list id="ul1021" list-type="bulleted">

	

<item id="li1147">
Instantiate a plotting object of type 

<emphasis id="strong1276" effect="bold">
PlotALot04

</emphasis>
.

</item>


	

<item id="li1148">
Feed triplets of data values to the plotting object by calling the
	

<emphasis id="strong1277" effect="bold">
feedData

</emphasis>
 method once for each triplet of data values. The 
	first value in the triplet will be plotted in black on one axis. The second 
	value in the triplet will be plotted in red on an axis below that axis. The 
	third value in the triplet will be plotted in blue on an axis below that 
	one.

</item>


	

<item id="li1149">
Call the 

<emphasis id="strong1278" effect="bold">
plotData

</emphasis>
 method on the plotting object when 
	all of the data has been fed to the object.

</item>




</list>




<section id="h41065">
<title>
A stack of Page objects

</title>




<para id="p1218">
The class produces a graphic output consisting of a stack of 

<emphasis id="strong1279" effect="bold">
Page

</emphasis>
 
objects on the screen, with the data plotted on a 

<emphasis id="strong1280" effect="bold">
Canvas

</emphasis>
 object 
contained in the 

<emphasis id="strong1281" effect="bold">
Page

</emphasis>
 object. The page showing the earliest 
data is on the top of the stack and the page showing the latest data is on the 
bottom of the stack.

</para>





<para id="p1219">
Each 

<emphasis id="strong1282" effect="bold">
Page

</emphasis>
 object contains three or more horizontal axes on 
which the data is plotted. The class will terminate if the number of axes on the 
page is not evenly divisible by 3.

</para>





<para id="p1220">
The three data sets are plotted on separate axes as shown in 

<link id="a1267" target-id="Figure_4">

 Figure 4

</link>

 with 
the data from one data set being plotted in black on one axis, the data from the 
second data set being plotted in red on the axis below that axis, and the data 
from the third data set being plotted in blue on the axis below that axis.

</para>





</section>
<section id="h41066">
<title>
Testing with the main method

</title>




<para id="p1221">
For test purposes, the 

<emphasis id="strong1283" effect="bold">
main

</emphasis>
 method instantiates a single 
plotting object and feeds three data sets to that plotting object producing the 
graphic output shown in 

<link id="a1268" target-id="Figure_4">

 Figure 4

</link>

.

</para>





<para id="p1222">
Won't discuss the code

</para>





<para id="p1223">
The code in this class is so similar to the code in the class named 
PlotALot03 that I'm not going to discuss the code. You will find a complete 
listing of the class in 

<link id="a1269" target-id="Listing_38">

 Listing 38

</link>

 near the end of the module.

</para>






</section>
</section>
</section>
</section>
<section id="h11004">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the programs

</emphasis>


</title>





<para id="p1224">
I encourage you to copy, compile, and run the programs that you will find in 


<link id="a1270" target-id="Listing_35">

 Listing 35

</link>

 through 

<link id="a1271" target-id="Listing_38">

 Listing 38

</link>

 below. 

</para>





<para id="p1225">
Modify the programs and experiment with them in order to learn as much as you 
can about the use of Java for plotting large quantities of data. For example, 
you might want to modify the default plotting parameters to a different set of 
plotting parameters that are more to your liking. One possibility is to cause 
the default Page size to fill the entire screen on your computer.

</para>





<para id="p1226">
Another good exercise would be for you to convert this class to Swing using a 
look and feel that is independent of the operating system.

</para>





</section>
<section id="h11005">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1227">
In this module, I presented and explained four self-testing classes for 
plotting large quantities of data. One class plots a nearly unlimited amount of 
single-channel data using multiple traces on multiple pages.

</para>





<quote id="blockquote1020" display="block">

	

<para id="p1228">
<emphasis id="em1067" effect="italics">
(I have successfully plotted two million data values in 141 full 
	screen pages on a modest laptop computer with no difficulty whatsoever. When 
	I pushed that total up to eight million data values in 563 full screen 
	pages, the plotting process slowed down, but I was still able to display and 
	examine the plots. The practical limit on my computer seems to be somewhere 
	between two million and eight million data values.)

</emphasis>
</para>





</quote>




<para id="p1229">
A second class plots a large quantity of two-channel data superimposing the 
two data sets on the same axes with the plot of one data set being colored black 
and the plot of the other data set being colored red.

</para>





<para id="p1230">
A third class also plots a large quantity of two-channel data, but with this 
class, the two sets of data are plotted on alternating horizontal axes. Again, 
one set of data is colored black and the other set is colored red.

</para>





<para id="p1231">
A fourth class plots a large quantity of three-channel data on separate axes. 
In this case, one set is colored black, the second set is colored red, and the 
third set is colored blue. 

</para>





</section>
<section id="h11006">
<title>
<emphasis id="Complete_program_listings" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1232">
Complete listings of the four programs that I explained in this module are 
provided in 

<link id="a1272" target-id="Listing_35">

 Listing 35

</link>

 through 

<link id="a1273" target-id="Listing_38">

 Listing 38

</link>

 below.

</para>









<table id="table1039" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1039">
<row id="tr1078">



<entry id="th1039">
<emphasis id="Listing_35" effect="bold">

Listing 35.

</emphasis>

 PlotALot01.java.


</entry>
</row>
</thead>


<tbody id="tbody1039">
<row id="tr1079">
<entry id="td1039">

		

<code id="pre1039" display="block">/*File PlotALot01.java 
Copyright 2005, R.G.Baldwin
This program is designed to plot large amounts of
time-series data for a single channel.  See
PlotALot02.java for a two-channel program.

Note that by carefully adjusting the plotting
parameters, this program could also be used to
plot large quantities of spectral data in a
waterfall display.

The class provides a main method so that the
class can be run as an application to test
itself.

There are three steps involved in the use of this
class for plotting time series data:
1. Instantiate a plotting object of type 
   PlotALot01 using one of two overloaded 
   constructors.
2. Feed data that is to be plotted to the 
   plotting object by calling the feedData 
   method once for each data value.
3. call one of two overloaded plotData methods 
   on the plotting object once all of the data 
   has been fed to the object.  This causes all
   of the data to be plotted.
   
A using program can instantiate as many 
plotting objects as are needed to plot all of the
different time series that need to be plotted.
Each plotting object can be used to plot as many
data values as need be plotted until the program
runs out of available memory.

The plotting object of type PlotALot01 owns one 
or more Page objects that extend the Frame class.
The plotting object can own as many Page objects 
as are necessary to plot all of the data that is 
fed to that plotting object.

The program produces a graphic output consisting 
of a stack of Page objects on the screen, with 
the data plotted on a Canvas object contained by 
the Page object.  The Page showing the earliest 
data is on the top of the stack and the Page 
showing the latest data is on the bottom of the 
stack.  The Page objects on the top of the stack 
must be physically moved in order to see the 
Page objects on the bottom of the stack.

Each Page object contains one or more horizontal 
axes on which the data is plotted.  The earliest 
data is plotted on the axis nearest the top of 
the Page moving from left to right across the 
axis.  Positive data values are plotted above
the axis and negative values are plotted below
the axis.  When the right end of an axis is 
reached, the next data value is plotted on the 
left end of the axis immediately below it.  When 
the right end of the last axis on the Page is 
reached, a new Page object is created and the 
next data value is plotted at the left end of the
top axis on that Page object.

A mentioned above, there are two overloaded 
versions of the constructor for the PlotALot01
class. One overloaded version accepts several 
incoming parameters allowing the user to control
various aspects of the plotting format. A second 
overloaded version accepts a title string only 
and sets all of the plotting parameters to 
default values. You can easily modify these
default values and recompile the class if you
prefer different default values.

The parameters for the version of the constructor
that accepts plotting format information are:

String title: Title for the Frame object. This
 title is concatenated with the page number and 
 the result appears in the banner at the top of 
 the Frame.
int frameWidth:The Frame width in pixels.
int frameHeight: The Frame height in pixels.
int traceSpacing: Distance between trace axes in
 pixels.
int sampSpace: Number of pixels dedicated to each
 data sample in pixels per sample.  Must be 1 or
 greater.
int ovalWidth: Width of an oval that is used to 
 mark the sample value on the plot.
int ovalHeight: Height of an oval that is used to
 mark the sample value on the plot.

For test purposes, the main method instantiates 
and feeds two independent plotting objects. 
Plotting parameters are specified for the first 
plotting object. Default plotting parameters are 
accepted for the second plotting object.
 
The data that is fed to each plotting object is 
white random noise. However, for the first
plotting object, fifteen of the data values are 
not random.  Rather, seven of the values are set
to values of 0,0,25,-25,25,0,0 to confirm the 
proper transition from the end of one page to the
beginning of the next page. In addition, eight of
the values are set to 0,0,20,20,-20,-20,0,0 in
order to confirm the proper transition from one 
trace to the next trace on the same page.

These specific values and the locations in the 
data where they are placed provide visible 
confirmation that the transitions mentioned above
are handled correctly. Note, however that these 
are the correct locations for an AWT Frame object
under WinXP. A Frame may have different inset 
values under other operating systems, which may 
cause these specific locations to be incorrect 
for that operating system.  In that case, the 
values will be plotted but they won't confirm 
the proper transition.

The following information about the plotting 
parameters for each plotting object is displayed 
on the command line screen when the class is used
for plotting.  The values shown below result from
the execution of the main method of the class for
test purposes. One of the plotting objects 
instantiated by the main method is titled "A" 
and the other is titled "B".

Title: A
Frame width: 158
Frame height: 237
Page width: 150
Page height: 210
Trace spacing: 36
Sample spacing: 5
Traces per page: 5
Samples per page: 150

Title: B
Frame width: 400
Frame height: 410
Page width: 392
Page height: 383
Trace spacing: 50
Sample spacing: 2
Traces per page: 7
Samples per page: 1372

There are two overloaded versions of the plotData
method. One version allows the user to specify 
the location on the screen where the stack of 
plotted pages will appear. This version requires 
two parameters, which are coordinate values in 
pixels.  The first parameter specifies the 
horizontal coordinate of the upper left corner of
the stack of pages relative to the upper left 
corner of the screen.  The second parameter 
specifies the vertical coordinate of the upper 
left corner of the stack of pages relative to the
upper left corner of the screen. Specifying 
coordinate values of 0,0 causes the stack to be 
located in the upper left corner of the screen.  

The other overloaded version of plotData places 
the stack of pages in the upper left corner of 
the screen by default.
 
Each page has a WindowListener that will 
terminate the program if the user clicks the 
close button on the Frame.

The program was tested using J2SE 5.0 and WinXP.
Requires J2SE 5.0 to support generics.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class PlotALot01{
  //This main method is provided so that the
  // class can be run as an application to test
  // itself.
  public static void main(String[] args){
    //Instantiate two independent plotting
    // objects.  Control plotting parameters for
    // the first object.  Accept default plotting
    // parameters for the second object.
    PlotALot01 plotObjectA = 
            new PlotALot01("A",158,237,36,5,4,4);
    PlotALot01 plotObjectB = new PlotALot01("B");
    
    //Feed the data to the first plotting object.
    for(int cnt = 0;cnt &lt; 275;cnt++){
      //Plot some white random noise in the first
      // object using specified plotting
      // parameters. Note, that fifteen of the
      // following values are not random.  Seven
      // values are set to 0,0,25,-25,25,0,0
      // specifically to confirm the proper
      // transition from the end of one page to
      // the beginning of the next page.  Eight
      // values are set to 0,0,20,20,-20,-20,0,0
      // to confirm the proper transition from
      // one trace to the next trace on the same
      // page.  Note that these are the correct
      // values for an AWT Frame object under
      // WinXP.  However, a Frame may have 
      // different inset values on other
      // operating systems, which may cause these
      // specific values to be incorrect.
      if(cnt == 147){
        plotObjectA.feedData(0);
      }else if(cnt == 148){
        plotObjectA.feedData(0);
      }else if(cnt == 149){
        plotObjectA.feedData(25);
      }else if(cnt == 150){
        plotObjectA.feedData(-25);
      }else if(cnt == 151){
        plotObjectA.feedData(25);
      }else if(cnt == 152){
        plotObjectA.feedData(0);
      }else if(cnt == 153){
        plotObjectA.feedData(0);
      }else if(cnt == 26){
        plotObjectA.feedData(0);
      }else if(cnt == 27){
        plotObjectA.feedData(0);
      }else if(cnt == 28){
        plotObjectA.feedData(20);
      }else if(cnt == 29){
        plotObjectA.feedData(20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20);
      }else if(cnt == 32){
        plotObjectA.feedData(0);
      }else if(cnt == 33){
        plotObjectA.feedData(0);
      }else{
        plotObjectA.feedData(
                       (Math.random() - 0.5)*25);
      }//end else
    }//end for loop
    //Cause the data to be plotted.
    plotObjectA.plotData(401,0);
    
    //Plot white random noise in the second
    // plotting object using default plotting
    // parameters.
    //Feed the data to the second plotting
    // object.
    for(int cnt = 0;cnt &lt; 2600;cnt++){
      plotObjectB.feedData(
                       (Math.random() - 0.5)*25);
    }//end for loop
    //Cause the data to be plotted.
    plotObjectB.plotData();
    
  }//end main
  //-------------------------------------------//

  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();
  
  //There are two overloaded versions of the
  // constructor for this class.  This
  // overloaded version accepts several incoming
  // parameters allowing the user to control
  // various aspects of the plotting format. A
  // different overloaded version accepts a title
  // string only and sets all of the plotting
  // parameters to default values.
  PlotALot01(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor
    //Specify sampSpace as pixels per sample.
    // Should never be less than 1.  Convert to
    // pixels between samples for purposes of
    // computation.
    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;

    //The following object is instantiated solely
    // to provide information about the width and
    // height of the canvas. This information is
    // used to compute a variety of other
    // important values.
    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();
    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if
    //Get rid of this temporary page.
    tempPage.dispose();
    //Now compute the remaining important values.
    tracesPerPage = 
                 (canvasHeight - traceSpacing/2)/
                                    traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
    if(tracesPerPage == 0){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    samplesPerPage = canvasWidth * tracesPerPage/
                               (sampSpacing + 1);
    System.out.println("Samples per page: "
                               + samplesPerPage);
    //Now instantiate the first usable Page
    // object and store its reference in the
    // list.
    pageLinks.add(new Page(title));
  }//end constructor
  //-------------------------------------------//
  
  PlotALot01(String title){
    //call the other overloaded constructor
    // passing default values for all but the
    // title.
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor
  //-------------------------------------------//
  
  //call this method for each point to be
  // plotted.
  void feedData(double val){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample value in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample value passes through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                              val,sampleCounter);
    sampleCounter++;
  }//end feedData
  //-------------------------------------------//
  
  //There are two overloaded versions of the
  // plotData method.  One version allows the
  // user to specify the location on the screen
  // where the stack of plotted pages will
  // appear.  The other version places the stack
  // in the upper left corner of the screen.
  
  //call one of the overloaded versions of
  // this method once when all of the data has
  // been fed to the plotting object in order to
  // rearrange the order of the pages with
  // page 0 at the top of the stack on the
  // screen.
  
  //For this overloaded version, specify xCoor
  // and yCoor to control the location of the
  // stack on the screen.  Values of 0,0 will
  // place the stack at the upper left corner of
  // the screen.  Also see the other overloaded
  // version, which places the stack at the upper
  // left corner of the screen by default.
  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    //Delay until last page becomes visible.
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop
    
    Page tempPage = null;
    //Make all pages invisible
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop
    
    //Now make all pages visible in reverse order
    // so that page 0 will be on top of the
    // stack on the screen.
    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)
  //-------------------------------------------//
  
  //This overloaded version of the method causes
  // the stack to be located in the upper left
  // corner of the screen by default
  void plotData(){
    plotData(0,0);//call overloaded version
  }//end plotData()
  //-------------------------------------------//

  //Inner class.  A PlotALot01 object may
  // have as many Page objects as are required
  // to plot all of the data values.  The 
  // reference to each Page object is stored
  // in an ArrayList object belonging to the
  // PlotALot01 object.
  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);
      
      //---------------------------------------//
      //Anonymous inner class to terminate the
      // program when the user clicks the close
      // button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
      //---------------------------------------//
    }//end constructor
    //=========================================//
  
    //This method receives a sample value of type
    // double and stores it in an array object
    // belonging to the MyCanvas object.
    void putData(double sampleValue,
                 int sampleCounter){
      canvas.data[sampleCounter] = sampleValue;
      //Save the sample counter in an instance
      // variable to make it available to the
      // overridden paint method. This value is
      // needed by the paint method so it will
      // know how many samples to plot on the
      // final page which probably won't be full.
      this.sampleCounter = sampleCounter;
    }//end putData
    
    //=========================================//
    //Inner class
    class MyCanvas extends Canvas{
      double [] data = 
                      new double[samplesPerPage];
      
      //Override the paint method
      public void paint(Graphics g){
        //Draw horizontal axes, one for each
        // trace.
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop
        
        //Plot the points if there are any to be
        // plotted.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
            //Compute a vertical offset to locate
            // the data on a particular trace.
            int yOffset = 
                   (1 + cnt*(sampSpacing + 1)/
                   this.getWidth())*traceSpacing;
            //Draw an oval centered on the sample
            // value to mark the sample.  It is 
            // best if the dimensions of the oval
            // are evenly divisible by 2 for 
            // centering purposes.
            //Reverse the sign on sample value to
            // cause positive sample values to go
            // up on the screen
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)data[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines.  Do not draw a
            // line connecting the last sample in
            // one trace to the first sample in
            // the next trace.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)data[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)data[cnt]);
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot01
//=============================================//</code>




</entry>
</row>
</tbody>


</tgroup>
</table>








<table id="table1040" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1040">
<row id="tr1080">



<entry id="th1040">
<emphasis id="Listing_36" effect="bold">

Listing 36.

</emphasis>

 PlotALot02.java.


</entry>
</row>
</thead>


<tbody id="tbody1040">
<row id="tr1081">
<entry id="td1040">

		

<code id="pre1040" display="block">/*File PlotALot02.java 
Copyright 2005, R.G.Baldwin
This program is an update to the program named 
PlotALot01.  This program is designed to plot 
large amounts of time-series data for two 
channels on the same axes.  One set of data is 
plotted using the color black.  The other set of 
data is plotted using the color red.  See
PlotALot01.java for a one-channel program.

Note that by carefully adjusting the plotting
parameters, this program could also be used to
plot large quantities of spectral data in a
waterfall display.

The class provides a main method so that the
class can be run as an application to test
itself.

There are three steps involved in the use of this
class for plotting time series data:
1. Instantiate a plotting object of type 
   PlotALot02 using one of two overloaded 
   constructors.
2. Feed pairs of data values that are to be 
   plotted to the plotting object by calling the
   feedData method once for each pair of data 
   values.  The first value in the pair will be 
   plotted in black.  The second value in the 
   pair will be plotted in red.
3. call one of two overloaded plotData methods 
   on the plotting object once all of the data 
   has been fed to the object.  This causes all
   of the data to be plotted.
   
A using program can instantiate as many plotting 
objects as are needed to plot all of the
different pairs of time series that need to be 
plotted.  Each plotting object can be used to 
plot as many pairs of data values as need be 
plotted until the program runs out of available 
memory.

The plotting object of type PlotALot02 owns one 
or more Page objects that extend the Frame class.
The plotting object can own as many Page objects 
as are necessary to plot all of the pairs of data
that are fed to that plotting object.

The program produces a graphic output consisting 
of a stack of Page objects on the screen, with 
the data plotted on a Canvas object contained by 
the Page object.  The Page showing the earliest 
data is on the top of the stack and the Page 
showing the latest data is on the bottom of the 
stack.  The Page objects on the top of the stack 
must be physically moved in order to see the 
Page objects on the bottom of the stack.

Each Page object contains one or more horizontal 
axes on which the data is plotted.  The two time 
series are superimposed on the same axes with the
data from one time series being plotted in black 
and the data from the other time series being 
plotted in red.

The earliest data is plotted on the axis nearest 
the top of  the Page moving from left to right 
across the horizontal axis.  Positive data values
are plotted above the axis and negative values 
are plotted below the axis.  When the right end 
of an axis is reached, the next data value is 
plotted on the left end of the axis immediately 
below it.  When the right end of the last axis on
the Page is reached, a new Page object is created
and the next data value is plotted at the left 
end of the top axis on that new Page object.

A mentioned above, there are two overloaded 
versions of the constructor for the PlotALot02
class. One overloaded version accepts several 
incoming parameters allowing the user to control
various aspects of the plotting format. A second 
overloaded version accepts a title string only 
and sets all of the plotting parameters to 
default values. You can easily modify these
default values and recompile the class if you
prefer different default values.

The parameters for the version of the constructor
that accepts plotting format information are:

String title: Title for the Frame object. This
 title is concatenated with the page number and 
 the result appears in the banner at the top of 
 the Frame.
int frameWidth:The Frame width in pixels.
int frameHeight: The Frame height in pixels.
int traceSpacing: Distance between trace axes in
 pixels.
int sampSpace: Number of pixels dedicated to each
 data sample in pixels per sample.  Must be 1 or
 greater.
int ovalWidth: Width of an oval that is used to 
 mark each sample value on the plot.
int ovalHeight: Height of an oval that is used to
 mark each sample value on the plot.

For test purposes, the main method instantiates a
single plotting object and feeds two time series 
to that plotting object.  Plotting parameters are
specified for the plotting object by using the 
overloaded version of the constructor that 
accepts plotting parameters.

The data that is fed to the plotting object is 
white random noise. One of the time series is 
the sequence of values obtained from a random 
number generator.  The other time series is the 
same as the first except that the sign of each 
data values are reversed.  

Fifteen of the data values for each time series 
are not random.  Seven of the values for the 
first time series are set to values of 0,0,25,-25,
25,0,0.  The corresponding seven values for the 
second time series are set to the same values 
with sign reversal.  This is done to confirm the 
proper transition from the end of one page to the
beginning of the next page.

In addition, eight of the values for the first 
time series are set to 0,0,20,20,-20,-20,0,0.  
The corresponding values for the second time 
series are set to the same values with sign 
reversal.  This is done in order to confirm the 
proper transition from one trace to the next 
trace on the same page.

These specific values and the locations in the 
data where they are placed provide visible 
confirmation that the transitions mentioned above
are handled correctly. Note, however that these 
are the correct locations for an AWT Frame object
under WinXP. A Frame may have different inset 
values under other operating systems, which may 
cause these specific locations to be incorrect 
for that operating system.  In that case, the 
values will be plotted but they won't confirm 
the proper transition.

The following information about the plotting 
parameters is displayed on the command line 
screen when the class is used for plotting.  The 
values shown below result from the execution of 
the main method of the class for test purposes.

Title: A
Frame width: 158
Frame height: 237
Page width: 150
Page height: 210
Trace spacing: 36
Sample spacing: 5
Traces per page: 5
Samples per page: 150

There are two overloaded versions of the plotData
method. One version allows the user to specify 
the location on the screen where the stack of 
plotted pages will appear. This version requires 
two parameters, which are coordinate values in 
pixels.  The first parameter specifies the 
horizontal coordinate of the upper left corner of
the stack of pages relative to the upper left 
corner of the screen.  The second parameter 
specifies the vertical coordinate of the upper 
left corner of the stack of pages relative to the
upper left corner of the screen. Specifying 
coordinate values of 0,0 causes the stack to be 
located in the upper left corner of the screen.  

The other overloaded version of plotData places 
the stack of pages in the upper left corner of 
the screen by default.  The main method in this 
class uses the second version causing the stack 
of pages to appear in the upper left corner of 
the screen by default.
 
Each page has a WindowListener that will 
terminate the program if the user clicks the 
close button on the Frame.

The program was tested using J2SE 5.0 and WinXP.
Requires J2SE 5.0 to support generics.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class PlotALot02{
  //This main method is provided so that the
  // class can be run as an application to test
  // itself.
  public static void main(String[] args){
    //Instantiate a plotting object using the
    // version of the constructor that allows for
    // controlling the plotting parameters.
    PlotALot02 plotObjectA = 
            new PlotALot02("A",158,237,36,5,4,4);
    
    //Feed pairs of data values to the plotting
    // object.
    for(int cnt = 0;cnt &lt; 275;cnt++){
      //Plot some white random noise Note that
      // fifteen of the values for each time
      // series are not random.  See the opening
      // comments for a discussion of the reasons
      // why.  Cause the values for the second
      // time series to be the negative of the
      // values for the first time series.
      double valBlack = (Math.random() - 0.5)*25;
      double valRed = -valBlack;
      //Feed pairs of values to the plotting
      // object by calling the feedData method
      // once for each pair of data values.
      if(cnt == 147){
        plotObjectA.feedData(0,0);
      }else if(cnt == 148){
        plotObjectA.feedData(0,0);
      }else if(cnt == 149){
        plotObjectA.feedData(25,-25);
      }else if(cnt == 150){
        plotObjectA.feedData(-25,25);
      }else if(cnt == 151){
        plotObjectA.feedData(25,-25);
      }else if(cnt == 152){
        plotObjectA.feedData(0,0);
      }else if(cnt == 153){
        plotObjectA.feedData(0,0);
      }else if(cnt == 26){
        plotObjectA.feedData(0,0);
      }else if(cnt == 27){
        plotObjectA.feedData(0,0);
      }else if(cnt == 28){
        plotObjectA.feedData(20,-20);
      }else if(cnt == 29){
        plotObjectA.feedData(20,-20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20,20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20,20);
      }else if(cnt == 32){
        plotObjectA.feedData(0,0);
      }else if(cnt == 33){
        plotObjectA.feedData(0,0);
      }else{
        plotObjectA.feedData(valBlack,valRed);
      }//end else
    }//end for loop
    //Cause the data to be plotted in the default
    // screen location.
    plotObjectA.plotData();
  }//end main
  //-------------------------------------------//

  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();
  
  //There are two overloaded versions of the
  // constructor for this class.  This
  // overloaded version accepts several incoming
  // parameters allowing the user to control
  // various aspects of the plotting format. A
  // different overloaded version accepts a title
  // string only and sets all of the plotting
  // parameters to default values.
  PlotALot02(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor
    //Specify sampSpace as pixels per sample.
    // Should never be less than 1.  Convert to
    // pixels between samples for purposes of
    // computation.
    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;

    //The following object is instantiated solely
    // to provide information about the width and
    // height of the canvas. This information is
    // used to compute a variety of other
    // important values.
    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();
    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if
    //Get rid of this temporary page.
    tempPage.dispose();
    //Now compute the remaining important values.
    tracesPerPage = 
                 (canvasHeight - traceSpacing/2)/
                                    traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
    if(tracesPerPage == 0){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    samplesPerPage = canvasWidth * tracesPerPage/
                               (sampSpacing + 1);
    System.out.println("Samples per page: "
                               + samplesPerPage);
    //Now instantiate the first usable Page
    // object and store its reference in the
    // list.
    pageLinks.add(new Page(title));
  }//end constructor
  //-------------------------------------------//
  
  PlotALot02(String title){
    //call the other overloaded constructor
    // passing default values for all but the
    // title.
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor
  //-------------------------------------------//
  
  //call this method once for each pair of data
  // values to be plotted.
  void feedData(double valBlack,double valRed){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample values in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample values pass through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                  valBlack,valRed,sampleCounter);
    sampleCounter++;
  }//end feedData
  //-------------------------------------------//
  
  //There are two overloaded versions of the
  // plotData method.  One version allows the
  // user to specify the location on the screen
  // where the stack of plotted pages will
  // appear.  The other version places the stack
  // in the upper left corner of the screen.
  
  //call one of the overloaded versions of
  // this method once when all data has been fed
  // to the plotting object in order to rearrange
  // the order of the pages with page 0 at the
  // top of the stack on the screen.
  
  //For this overloaded version, specify xCoor
  // and yCoor to control the location of the
  // stack on the screen.  Values of 0,0 will
  // place the stack at the upper left corner of
  // the screen.  Also see the other overloaded
  // version, which places the stack at the upper
  // left corner of the screen by default.
  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    //Delay until last page becomes visible.
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop
    
    Page tempPage = null;
    //Make all pages invisible
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop
    
    //Now make all pages visible in reverse order
    // so that page 0 will be on top of the
    // stack on the screen.
    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)
  //-------------------------------------------//
  
  //This overloaded version of the method causes
  // the stack to be located in the upper left
  // corner of the screen by default
  void plotData(){
    plotData(0,0);//call overloaded version
  }//end plotData()
  //-------------------------------------------//

  //Inner class.  A PlotALot02 object may
  // have as many Page objects as are required
  // to plot all of the data values.  The 
  // reference to each Page object is stored
  // in an ArrayList object belonging to the
  // PlotALot02 object.
  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);
      
      //---------------------------------------//
      //Anonymous inner class to terminate the
      // program when the user clicks the close
      // button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
      //---------------------------------------//
    }//end constructor
    //=========================================//
  
    //This method receives a pair of sample
    // values of type double and stores each of
    // them in a separate array object belonging
    // to the MyCanvas object.
    void putData(double valBlack,double valRed,
                              int sampleCounter){
      canvas.blackData[sampleCounter] = valBlack;
      canvas.redData[sampleCounter] = valRed;
      //Save the sample counter in an instance
      // variable to make it available to the
      // overridden paint method. This value is
      // needed by the paint method so it will
      // know how many samples to plot on the
      // final page which probably won't be full.
      this.sampleCounter = sampleCounter;
    }//end putData
    
    //=========================================//
    //Inner class
    class MyCanvas extends Canvas{
      double [] blackData = 
                      new double[samplesPerPage];
      double [] redData = 
                      new double[samplesPerPage];
                      
      //Override the paint method
      public void paint(Graphics g){
        //Draw horizontal axes, one for each
        // trace.
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop
        
        //Plot the points if there are any to be
        // plotted.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
            //Compute a vertical offset to locate
            // the data on a particular trace.
            int yOffset = 
                   (1 + cnt*(sampSpacing + 1)/
                   this.getWidth())*traceSpacing;
            //Begin by plotting the values from
            // the blackData array object.
            //Draw an oval centered on the sample
            // value to mark the sample in the
            // plot. It is best if the dimensions
            // of the oval are evenly divisible
            // by 2 for  centering purposes.
            //Reverse the sign of the sample
            // value to cause positive sample
            // values to be plotted above the
            // axis.
            g.setColor(Color.BLACK);
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)blackData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines.  Do not draw a
            // line connecting the last sample in
            // one trace to the first sample in
            // the next trace.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt]);
            }//end if
            
            //Now plot the data stored in the
            // redData array object.
            g.setColor(Color.RED);
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)redData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt]);
                
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot02
//=============================================//</code>




</entry>
</row>
</tbody>


</tgroup>
</table>








<table id="table1041" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1041">
<row id="tr1082">



<entry id="th1041">
<emphasis id="Listing_37" effect="bold">

Listing 37.

</emphasis>

 PlotALot03.java.


</entry>
</row>
</thead>


<tbody id="tbody1041">
<row id="tr1083">
<entry id="td1041">

		

<code id="pre1041" display="block">/*File PlotALot03.java 
Copyright 2005, R.G.Baldwin
This program is an update to the program named 
PlotALot02.  This program is designed to plot 
large amounts of time-series data for two 
channels on alternating horizontal axes.  One set
of data is plotted using the color black.  The 
other set of data is plotted using the color red.

See PlotALot02 for a class that plots two 
channels of data in black and red superimposed on
the same axes.  See PlotALot01.java for a 
one-channel program.

Note that by carefully adjusting the plotting
parameters, this program could also be used to
plot large quantities of spectral data in a
waterfall display.

The class provides a main method so that the
class can be run as an application to test
itself.

There are three steps involved in the use of this
class for plotting time series data:
1. Instantiate a plotting object of type 
   PlotALot03 using one of two overloaded 
   constructors.
2. Feed pairs of data values that are to be 
   plotted to the plotting object by calling the
   feedData method once for each pair of data 
   values.  The first value in the pair will be 
   plotted in black on one axis.  The second 
   value in the pair will be plotted in red on an
   axis below that axis.
3. call one of two overloaded plotData methods 
   on the plotting object once all of the data 
   has been fed to the object.  This causes all
   of the data to be plotted.
   
A using program can instantiate as many plotting 
objects as are needed to plot all of the
different pairs of time series that need to be 
plotted.  Each plotting object can be used to 
plot as many pairs of data values as need be 
plotted until the program runs out of available 
memory.

The plotting object of type PlotALot03 owns one 
or more Page objects that extend the Frame class.
The plotting object can own as many Page objects 
as are necessary to plot all of the pairs of data
that are fed to that plotting object.

The program produces a graphic output consisting 
of a stack of Page objects on the screen, with 
the data plotted on a Canvas object contained by 
the Page object.  The Page showing the earliest 
data is on the top of the stack and the Page 
showing the latest data is on the bottom of the 
stack.  The Page objects on the top of the stack 
must be physically moved in order to see the 
Page objects on the bottom of the stack.

Each Page object contains two or more horizontal 
axes on which the data is plotted.  The program 
will terminate if the number of axes on the page 
is an odd number.

The two time series are plotted on alternating 
axes with the data from one time series being 
plotted in black on one axis and the data from 
the other time series being plotted in red on 
the axis below that axis.

The earliest data is plotted on the pair of axes 
nearest the top of the Page moving from left to 
right across the page.  Positive data values
are plotted above the axis and negative values 
are plotted below the axis.  When the right end 
of an axis is reached, the next data value is 
plotted on the left end of the second axis  
below it skipping one axis in the process.  When 
the right end of the last pair of axes on the 
Page is reached, a new Page object is created and
the next pair of data values are plotted at the 
left end of the top pair of axes on that new Page
object.

A mentioned above, there are two overloaded 
versions of the constructor for the PlotALot03
class. One overloaded version accepts several 
incoming parameters allowing the user to control
various aspects of the plotting format. A second 
overloaded version accepts a title string only 
and sets all of the plotting parameters to 
default values. You can easily modify these
default values and recompile the class if you
prefer different default values.

The parameters for the version of the constructor
that accepts plotting format information are:

String title: Title for the Frame object. This
 title is concatenated with the page number and 
 the result appears in the banner at the top of 
 the Frame.
int frameWidth:The Frame width in pixels.
int frameHeight: The Frame height in pixels.
int traceSpacing: Distance between trace axes in
 pixels.
int sampSpace: Number of pixels dedicated to each
 data sample in pixels per sample.  Must be 1 or
 greater.
int ovalWidth: Width of an oval that is used to 
 mark each sample value on the plot.
int ovalHeight: Height of an oval that is used to
 mark each sample value on the plot.

For test purposes, the main method instantiates a
single plotting object and feeds two time series 
to that plotting object.  Plotting parameters are
specified for the plotting object by using the 
overloaded version of the constructor that 
accepts plotting parameters.

The data that is fed to the plotting object is 
white random noise. One of the time series is 
the sequence of values obtained from a random 
number generator.  The other time series is the 
same as the first.  Thus, the pairs of black and 
red time series that are plotted should have the 
same shape making it easy to confirm that the
process of plotting the two time series is
behaving the same in both cases.

Fifteen of the data values for each time series 
are not random.  Seven of the values for each of 
the time series are set to values of 0,0,25,-25,
25,0,0.  This is done to confirm the proper 
transition from the end of one page to the
beginning of the next page.

In addition, eight of the values for each time 
series are set to 0,0,20,20,-20,-20,0,0.  This 
is done in order to confirm the proper transition
from one trace to the next trace on the same 
page.

These specific values and the locations in the 
data where they are placed provide visible 
confirmation that the transitions mentioned above
are handled correctly. Note, however that these 
are the correct locations for an AWT Frame object
under WinXP. A Frame may have different inset 
values under other operating systems, which may 
cause these specific locations to be incorrect 
for that operating system.  In that case, the 
values will be plotted but they won't confirm 
the proper transition.

The following information about the plotting 
parameters is displayed on the command line 
screen when the class is used for plotting.  The 
values shown below result from the execution of 
the main method of the class for test purposes.

Title: A
Frame width: 158
Frame height: 270
Page width: 150
Page height: 243
Trace spacing: 36
Sample spacing: 5
Traces per page: 6
Samples per page: 90

There are two overloaded versions of the plotData
method. One version allows the user to specify 
the location on the screen where the stack of 
plotted pages will appear. This version requires 
two parameters, which are coordinate values in 
pixels.  The first parameter specifies the 
horizontal coordinate of the upper left corner of
the stack of pages relative to the upper left 
corner of the screen.  The second parameter 
specifies the vertical coordinate of the upper 
left corner of the stack of pages relative to the
upper left corner of the screen. Specifying 
coordinate values of 0,0 causes the stack to be 
located in the upper left corner of the screen.  

The other overloaded version of plotData places 
the stack of pages in the upper left corner of 
the screen by default.  The main method in this 
class uses the second version causing the stack 
of pages to appear in the upper left corner of 
the screen by default.
 
Each page has a WindowListener that will 
terminate the program if the user clicks the 
close button on the Frame.

The program was tested using J2SE 5.0 and WinXP.
Requires J2SE 5.0 to support generics.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class PlotALot03{
  //This main method is provided so that the
  // class can be run as an application to test
  // itself.
  public static void main(String[] args){
    //Instantiate a plotting object using the
    // version of the constructor that allows for
    // controlling the plotting parameters.
    PlotALot03 plotObjectA = 
            new PlotALot03("A",158,270,36,5,4,4);
    
    //Feed pairs of data values to the plotting
    // object.
    for(int cnt = 0;cnt &lt; 175;cnt++){
      //Plot some white random noise Note that
      // fifteen of the values for each time
      // series are not random.  See the opening
      // comments for a discussion of the reasons
      // why.  Cause the values for the second
      // time series to be the same as the
      // values for the first time series.
      double valBlack = (Math.random() - 0.5)*25;
      double valRed = valBlack;
      //Feed pairs of values to the plotting
      // object by calling the feedData method
      // once for each pair of data values.
      if(cnt == 87){
        plotObjectA.feedData(0,0);
      }else if(cnt == 88){
        plotObjectA.feedData(0,0);
      }else if(cnt == 89){
        plotObjectA.feedData(25,25);
      }else if(cnt == 90){
        plotObjectA.feedData(-25,-25);
      }else if(cnt == 91){
        plotObjectA.feedData(25,25);
      }else if(cnt == 92){
        plotObjectA.feedData(0,0);
      }else if(cnt == 93){
        plotObjectA.feedData(0,0);
      }else if(cnt == 26){
        plotObjectA.feedData(0,0);
      }else if(cnt == 27){
        plotObjectA.feedData(0,0);
      }else if(cnt == 28){
        plotObjectA.feedData(20,20);
      }else if(cnt == 29){
        plotObjectA.feedData(20,20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20,-20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20,-20);
      }else if(cnt == 32){
        plotObjectA.feedData(0,0);
      }else if(cnt == 33){
        plotObjectA.feedData(0,0);
      }else{
        plotObjectA.feedData(valBlack,valRed);
      }//end else
    }//end for loop
    //Cause the data to be plotted in the default
    // screen location.
    plotObjectA.plotData();
  }//end main
  //-------------------------------------------//

  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();
  
  //There are two overloaded versions of the
  // constructor for this class.  This
  // overloaded version accepts several incoming
  // parameters allowing the user to control
  // various aspects of the plotting format. A
  // different overloaded version accepts a title
  // string only and sets all of the plotting
  // parameters to default values.
  PlotALot03(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor
    //Specify sampSpace as pixels per sample.
    // Should never be less than 1.  Convert to
    // pixels between samples for purposes of
    // computation.
    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;

    //The following object is instantiated solely
    // to provide information about the width and
    // height of the canvas. This information is
    // used to compute a variety of other
    // important values.
    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();
    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if
    //Get rid of this temporary page.
    tempPage.dispose();
    //Now compute the remaining important values.
    tracesPerPage = canvasHeight/traceSpacing - 
                     traceSpacing/2/traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
    if((tracesPerPage == 0) || 
                        (tracesPerPage%2 != 0) ){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    samplesPerPage = canvasWidth * tracesPerPage/
                             (sampSpacing + 1)/2;
    System.out.println("Samples per page: "
                               + samplesPerPage);
    //Now instantiate the first usable Page
    // object and store its reference in the
    // list.
    pageLinks.add(new Page(title));
  }//end constructor
  //-------------------------------------------//
  
  PlotALot03(String title){
    //call the other overloaded constructor
    // passing default values for all but the
    // title.
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor
  //-------------------------------------------//
  
  //call this method once for each pair of data
  // values to be plotted.
  void feedData(double valBlack,double valRed){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample values in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample values pass through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                  valBlack,valRed,sampleCounter);
    sampleCounter++;
  }//end feedData
  //-------------------------------------------//
  
  //There are two overloaded versions of the
  // plotData method.  One version allows the
  // user to specify the location on the screen
  // where the stack of plotted pages will
  // appear.  The other version places the stack
  // in the upper left corner of the screen.
  
  //call one of the overloaded versions of
  // this method once when all data has been fed
  // to the plotting object in order to rearrange
  // the order of the pages with page 0 at the
  // top of the stack on the screen.
  
  //For this overloaded version, specify xCoor
  // and yCoor to control the location of the
  // stack on the screen.  Values of 0,0 will
  // place the stack at the upper left corner of
  // the screen.  Also see the other overloaded
  // version, which places the stack at the upper
  // left corner of the screen by default.
  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    //Delay until last page becomes visible.
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop
    
    Page tempPage = null;
    //Make all pages invisible
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop
    
    //Now make all pages visible in reverse order
    // so that page 0 will be on top of the
    // stack on the screen.
    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)
  //-------------------------------------------//
  
  //This overloaded version of the method causes
  // the stack to be located in the upper left
  // corner of the screen by default
  void plotData(){
    plotData(0,0);//call overloaded version
  }//end plotData()
  //-------------------------------------------//

  //Inner class.  A PlotALot03 object may
  // have as many Page objects as are required
  // to plot all of the data values.  The 
  // reference to each Page object is stored
  // in an ArrayList object belonging to the
  // PlotALot03 object.
  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);
      
      //---------------------------------------//
      //Anonymous inner class to terminate the
      // program when the user clicks the close
      // button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
      //---------------------------------------//
    }//end constructor
    //=========================================//
  
    //This method receives a pair of sample
    // values of type double and stores each of
    // them in a separate array object belonging
    // to the MyCanvas object.
    void putData(double valBlack,double valRed,
                              int sampleCounter){
      canvas.blackData[sampleCounter] = valBlack;
      canvas.redData[sampleCounter] = valRed;
      //Save the sample counter in an instance
      // variable to make it available to the
      // overridden paint method. This value is
      // needed by the paint method so it will
      // know how many samples to plot on the
      // final page which probably won't be full.
      this.sampleCounter = sampleCounter;
    }//end putData
    
    //=========================================//
    //Inner class
    class MyCanvas extends Canvas{
      double [] blackData = 
                      new double[samplesPerPage];
      double [] redData = 
                      new double[samplesPerPage];
                      
      //Override the paint method
      public void paint(Graphics g){
        //Draw horizontal axes, one for each
        // trace.
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop
        
        //Plot the points if there are any to be
        // plotted.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
                                            
            //Begin by plotting the values from
            // the blackData array object.
            g.setColor(Color.BLACK);
            
            //Compute a vertical offset to locate
            // the black data on the odd numbered
            // axes on the page.
            int yOffset = 
               ((1 + cnt*(sampSpacing + 1)/
                this.getWidth())*2*traceSpacing)
                                  - traceSpacing;

            //Draw an oval centered on the sample
            // value to mark the sample in the
            // plot. It is best if the dimensions
            // of the oval are evenly divisible
            // by 2 for  centering purposes.
            //Reverse the sign of the sample
            // value to cause positive sample
            // values to be plotted above the
            // axis.

            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)blackData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines.  Do not draw a
            // line connecting the last sample in
            // one trace to the first sample in
            // the next trace.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt]);
            }//end if
            
            //Now plot the data stored in the
            // redData array object.
            g.setColor(Color.RED);
            //Compute a vertical offset to locate
            // the red data on the even numbered
            // axes on the page.
            yOffset = (1 + cnt*(sampSpacing + 1)/
                 this.getWidth())*2*traceSpacing;
            
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)redData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt]);
                
            }//end if
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot03
//=============================================//</code>




</entry>
</row>
</tbody>


</tgroup>
</table>








<table id="table1042" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1042">
<row id="tr1084">



<entry id="th1042">
<emphasis id="Listing_38" effect="bold">

Listing 38.

</emphasis>

 PlotALot04.java.


</entry>
</row>
</thead>


<tbody id="tbody1042">
<row id="tr1085">
<entry id="td1042">

		

<code id="pre1042" display="block">/*File PlotALot04.java 
Copyright 2005, R.G.Baldwin
This program is an update to the program named 
PlotALot03.  This program is designed to plot 
large amounts of time-series data for three 
channels on separate horizontal axes.  One set
of data is plotted using the color black.  The 
second set of data is plotted using the color 
red.  The third set of data is plotted using the
color blue.

See PlotALot03 for a class that plots two
channels of data in black and red on alternating
axes.

See PlotALot02 for a class that plots two 
channels of data in black and red superimposed on
the same axes.  

See PlotALot01.java for a one-channel program.

The class provides a main method so that the
class can be run as an application to test
itself.

There are three steps involved in the use of this
class for plotting time series data:
1. Instantiate a plotting object of type 
   PlotALot04 using one of two overloaded 
   constructors.
2. Feed triplets of data values that are to be 
   plotted to the plotting object by calling the
   feedData method once for each triplet of data 
   values.  The first value in the triplet will 
   be plotted in black on one axis.  The second 
   value in the triplet will be plotted in red on
   an axis below that axis.  The third value in
   the triplet will be plotted in blue on an axis
   below that one.
3. call one of two overloaded plotData methods 
   on the plotting object once all of the data 
   has been fed to the object.  This causes all
   of the data to be plotted.
   
A using program can instantiate as many plotting 
objects as are needed to plot all of the
different triplets of data that need to be 
plotted.  Each plotting object can be used to 
plot as many triplets of data values as need be 
plotted until the program runs out of available 
memory.

The plotting object of type PlotALot04 owns one 
or more Page objects that extend the Frame class.
The plotting object can own as many Page objects 
as are necessary to plot all of the triplets of 
data that are fed to that plotting object.

The program produces a graphic output consisting 
of a stack of Page objects on the screen, with 
the data plotted on a Canvas object contained by 
the Page object.  The Page showing the earliest 
data is on the top of the stack and the Page 
showing the latest data is on the bottom of the 
stack.  The Page objects on the top of the stack 
must be physically moved in order to see the 
Page objects on the bottom of the stack.

Each Page object contains three or more 
horizontal axes on which the data is plotted. The
program will terminate if the number of axes on 
the page is not evenly divisible by 3.

The three time series are plotted on separate 
axes with the data from one time series being 
plotted in black on one axis, the data from 
the second time series being plotted in red on 
the axis below that axis, and the data from the
third time series being plotted in blue on the
axis below that axis.

The earliest data is plotted on the three axes 
nearest the top of the Page moving from left to 
right across the page.  Positive data values
are plotted above the axis and negative values 
are plotted below the axis.  When the right end 
of an axis is reached, the next data value is 
plotted on the left end of the third axis  
below it skipping two axes in the process.  When 
the right end of the last triplet of axes on the 
Page is reached, a new Page object is created and
the next triplet of data values are plotted at 
the left end of the top three axes on that new 
Page object.

A mentioned above, there are two overloaded 
versions of the constructor for the PlotALot04
class. One overloaded version accepts several 
incoming parameters allowing the user to control
various aspects of the plotting format. A second 
overloaded version accepts a title string only 
and sets all of the plotting parameters to 
default values. You can easily modify these
default values and recompile the class if you
prefer different default values.

The parameters for the version of the constructor
that accepts plotting format information are:

String title: Title for the Frame object. This
 title is concatenated with the page number and 
 the result appears in the banner at the top of 
 the Frame.
int frameWidth:The Frame width in pixels.
int frameHeight: The Frame height in pixels.
int traceSpacing: Distance between trace axes in
 pixels.
int sampSpace: Number of pixels dedicated to each
 data sample in pixels per sample.  Must be 1 or
 greater.
int ovalWidth: Width of an oval that is used to 
 mark each sample value on the plot.
int ovalHeight: Height of an oval that is used to
 mark each sample value on the plot.

For test purposes, the main method instantiates a
single plotting object and feeds three time 
series to that plotting object.  Plotting 
parameters are specified for the plotting object 
by using the overloaded version of the 
constructor that accepts plotting parameters.

The data that is fed to the plotting object is 
white random noise. One of the time series is 
the sequence of values obtained from a random 
number generator.  The other two time series are
the same as the first.  Thus, the triplets of 
black, red, and blue time series that are plotted
should have the same shape making it easy to 
confirm that the process of plotting the three 
time series is behaving the same in all three
cases.

Fifteen of the data values for each time series 
are not random.  Seven of the values for each of 
the time series are set to values of 0,0,25,-25,
25,0,0.  This is done to confirm the proper 
transition from the end of one page to the
beginning of the next page.

In addition, eight of the values for each time 
series are set to 0,0,20,20,-20,-20,0,0.  This 
is done in order to confirm the proper transition
from one trace to the next trace on the same 
page.

These specific values and the locations in the 
data where they are placed provide visible 
confirmation that the transitions mentioned above
are handled correctly. Note, however that these 
are the correct locations for an AWT Frame object
under WinXP. A Frame may have different inset 
values under other operating systems, which may 
cause these specific locations to be incorrect 
for that operating system.  In that case, the 
values will be plotted but they won't confirm 
the proper transition.

The following information about the plotting 
parameters is displayed on the command line 
screen when the class is used for plotting.  The 
values shown below result from the execution of 
the main method of the class for test purposes.

Title: A
Frame width: 158
Frame height: 270
Page width: 150
Page height: 243
Trace spacing: 36
Sample spacing: 5
Traces per page: 6
Samples per page: 60

There are two overloaded versions of the plotData
method. One version allows the user to specify 
the location on the screen where the stack of 
plotted pages will appear. This version requires 
two parameters, which are coordinate values in 
pixels.  The first parameter specifies the 
horizontal coordinate of the upper left corner of
the stack of pages relative to the upper left 
corner of the screen.  The second parameter 
specifies the vertical coordinate of the upper 
left corner of the stack of pages relative to the
upper left corner of the screen. Specifying 
coordinate values of 0,0 causes the stack to be 
located in the upper left corner of the screen.  

The other overloaded version of plotData places 
the stack of pages in the upper left corner of 
the screen by default.  The main method in this 
class uses the second version causing the stack 
of pages to appear in the upper left corner of 
the screen by default.
 
Each page has a WindowListener that will 
terminate the program if the user clicks the 
close button on the Frame.

The program was tested using J2SE 5.0 and WinXP.
Requires J2SE 5.0 to support generics.
************************************************/

import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class PlotALot04{
  //This main method is provided so that the
  // class can be run as an application to test
  // itself.
  public static void main(String[] args){
    //Instantiate a plotting object using the
    // version of the constructor that allows for
    // controlling the plotting parameters.
    PlotALot04 plotObjectA = 
            new PlotALot04("A",158,270,36,5,4,4);
    
    //Feed triplets of data values to the 
    // plotting object.
    for(int cnt = 0;cnt &lt; 115;cnt++){
      //Plot some white random noise. Note that
      // fifteen of the values for each time
      // series are not random.  See the opening
      // comments for a discussion of the reasons
      // why.
      double valBlack = (Math.random() - 0.5)*25;
      double valRed = valBlack;
      double valBlue = valBlack;
      //Feed triplets of values to the plotting
      // object by calling the feedData method
      // once for each triplet of data values.
      if(cnt == 57){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 58){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 59){
        plotObjectA.feedData(25,25,25);
      }else if(cnt == 60){
        plotObjectA.feedData(-25,-25,-25);
      }else if(cnt == 61){
        plotObjectA.feedData(25,25,25);
      }else if(cnt == 62){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 63){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 26){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 27){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 28){
        plotObjectA.feedData(20,20,20);
      }else if(cnt == 29){
        plotObjectA.feedData(20,20,20);
      }else if(cnt == 30){
        plotObjectA.feedData(-20,-20,-20);
      }else if(cnt == 31){
        plotObjectA.feedData(-20,-20,-20);
      }else if(cnt == 32){
        plotObjectA.feedData(0,0,0);
      }else if(cnt == 33){
        plotObjectA.feedData(0,0,0);
      }else{
        plotObjectA.feedData(valBlack,
                             valRed,
                             valBlue);
      }//end else
    }//end for loop
    //Cause the data to be plotted in the default
    // screen location.
    plotObjectA.plotData();
  }//end main
  //-------------------------------------------//

  String title;
  int frameWidth;
  int frameHeight;
  int traceSpacing;//pixels between traces
  int sampSpacing;//pixels between samples
  int ovalWidth;//width of sample marking oval
  int ovalHeight;//height of sample marking oval
  
  int tracesPerPage;
  int samplesPerPage;
  int pageCounter = 0;
  int sampleCounter = 0;
  ArrayList &lt;Page&gt; pageLinks = 
                           new ArrayList&lt;Page&gt;();
  
  //There are two overloaded versions of the
  // constructor for this class.  This
  // overloaded version accepts several incoming
  // parameters allowing the user to control
  // various aspects of the plotting format. A
  // different overloaded version accepts a title
  // string only and sets all of the plotting
  // parameters to default values.
  PlotALot04(String title,//Frame title
             int frameWidth,//in pixels
             int frameHeight,//in pixels
             int traceSpacing,//in pixels
             int sampSpace,//in pixels per sample
             int ovalWidth,//sample marker width
             int ovalHeight)//sample marker hite
  {//constructor
    //Specify sampSpace as pixels per sample.
    // Should never be less than 1.  Convert to
    // pixels between samples for purposes of
    // computation.
    this.title = title;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.traceSpacing = traceSpacing;
    //Convert to pixels between samples.
    this.sampSpacing = sampSpace - 1;
    this.ovalWidth = ovalWidth;
    this.ovalHeight = ovalHeight;

    //The following object is instantiated solely
    // to provide information about the width and
    // height of the canvas. This information is
    // used to compute a variety of other
    // important values.
    Page tempPage = new Page(title);
    int canvasWidth = tempPage.canvas.getWidth();
    int canvasHeight = 
                     tempPage.canvas.getHeight();
    //Display information about this plotting
    // object.
    System.out.println("\nTitle: " + title);
    System.out.println(
          "Frame width: " + tempPage.getWidth());
    System.out.println(
        "Frame height: " + tempPage.getHeight());
    System.out.println(
                   "Page width: " + canvasWidth);
    System.out.println(
                 "Page height: " + canvasHeight);
    System.out.println(
               "Trace spacing: " + traceSpacing);
    System.out.println(
         "Sample spacing: " + (sampSpacing + 1));
    if(sampSpacing &lt; 0){
      System.out.println("Terminating");
      System.exit(0);
    }//end if
    //Get rid of this temporary page.
    tempPage.dispose();
    //Now compute the remaining important values.
    tracesPerPage = canvasHeight/traceSpacing -
                     traceSpacing/2/traceSpacing;
    System.out.println("Traces per page: "
                                + tracesPerPage);
    if((tracesPerPage == 0) || 
                        (tracesPerPage%3 != 0) ){
      System.out.println("Terminating program");
      System.exit(0);
    }//end if
    samplesPerPage = canvasWidth * tracesPerPage/
                             (sampSpacing + 1)/3;
    System.out.println("Samples per page: "
                               + samplesPerPage);
    //Now instantiate the first usable Page
    // object and store its reference in the
    // list.
    pageLinks.add(new Page(title));
  }//end constructor
  //-------------------------------------------//
  
  PlotALot04(String title){
    //call the other overloaded constructor
    // passing default values for all but the
    // title.
    this(title,400,410,50,2,2,2);
  }//end overloaded constructor
  //-------------------------------------------//
  
  //call this method once for each triplet of 
  // data values to be plotted.
  void feedData(double valBlack,
                double valRed,
                double valBlue){
    if((sampleCounter) == samplesPerPage){
      //if the page is full, increment the page
      // counter, create a new empty page, and
      // reset the sample counter.
      pageCounter++;
      sampleCounter = 0;
      pageLinks.add(new Page(title));
    }//end if
    //Store the sample values in the MyCanvas
    // object to be used later to paint the
    // screen.  Then increment the sample
    // counter.  The sample values pass through
    // the page object into the current MyCanvas
    // object.
    pageLinks.get(pageCounter).putData(
                                  valBlack,
                                  valRed,
                                  valBlue,
                                  sampleCounter);
    sampleCounter++;
  }//end feedData
  //-------------------------------------------//
  
  //There are two overloaded versions of the
  // plotData method.  One version allows the
  // user to specify the location on the screen
  // where the stack of plotted pages will
  // appear.  The other version places the stack
  // in the upper left corner of the screen.
  
  //call one of the overloaded versions of
  // this method once when all data has been fed
  // to the plotting object in order to rearrange
  // the order of the pages with page 0 at the
  // top of the stack on the screen.
  
  //For this overloaded version, specify xCoor
  // and yCoor to control the location of the
  // stack on the screen.  Values of 0,0 will
  // place the stack at the upper left corner of
  // the screen.  Also see the other overloaded
  // version, which places the stack at the upper
  // left corner of the screen by default.
  void plotData(int xCoor,int yCoor){
    Page lastPage = 
             pageLinks.get(pageLinks.size() - 1);
    //Delay until last page becomes visible.
    while(!lastPage.isVisible()){
      //Loop until last page becomes visible
    }//end while loop
    
    Page tempPage = null;
    //Make all pages invisible
    for(int cnt = 0;cnt &lt; (pageLinks.size());
                                          cnt++){
      tempPage = pageLinks.get(cnt);
      tempPage.setVisible(false);
    }//end for loop
    
    //Now make all pages visible in reverse order
    // so that page 0 will be on top of the
    // stack on the screen.
    for(int cnt = pageLinks.size() - 1;cnt &gt;= 0;
                                          cnt--){
      tempPage = pageLinks.get(cnt);
      tempPage.setLocation(xCoor,yCoor);
      tempPage.setVisible(true);
    }//end for loop

  }//end plotData(int xCoor,int yCoor)
  //-------------------------------------------//
  
  //This overloaded version of the method causes
  // the stack to be located in the upper left
  // corner of the screen by default
  void plotData(){
    plotData(0,0);//call overloaded version
  }//end plotData()
  //-------------------------------------------//

  //Inner class.  A PlotALot04 object may
  // have as many Page objects as are required
  // to plot all of the data values.  The 
  // reference to each Page object is stored
  // in an ArrayList object belonging to the
  // PlotALot04 object.
  class Page extends Frame{
    MyCanvas canvas;
    int sampleCounter;

    Page(String title){//constructor
      canvas = new MyCanvas();
      add(canvas);
      setSize(frameWidth,frameHeight);    
      setTitle(title + " Page: " + pageCounter);
      setVisible(true);
      
      //---------------------------------------//
      //Anonymous inner class to terminate the
      // program when the user clicks the close
      // button on the Frame.
      addWindowListener(
        new WindowAdapter(){
          public void windowClosing(
                                  WindowEvent e){
            System.exit(0);//terminate program
          }//end windowClosing()
        }//end WindowAdapter
      );//end addWindowListener
      //---------------------------------------//
    }//end constructor
    //=========================================//
  
    //This method receives a triplet of sample
    // values of type double and stores each of
    // them in a separate array object belonging
    // to the MyCanvas object.
    void putData(double valBlack,
                 double valRed,
                 double valBlue,
                 int sampleCounter){
      canvas.blackData[sampleCounter] = valBlack;
      canvas.redData[sampleCounter] = valRed;
      canvas.blueData[sampleCounter] = valBlue;
      //Save the sample counter in an instance
      // variable to make it available to the
      // overridden paint method. This value is
      // needed by the paint method so it will
      // know how many samples to plot on the
      // final page which probably won't be full.
      this.sampleCounter = sampleCounter;
    }//end putData
    
    //=========================================//
    //Inner class
    class MyCanvas extends Canvas{
      double [] blackData = 
                      new double[samplesPerPage];
      double [] redData = 
                      new double[samplesPerPage];
      double [] blueData = 
                      new double[samplesPerPage];
                      
      //Override the paint method
      public void paint(Graphics g){
        //Draw horizontal axes, one for each
        // trace.
        for(int cnt = 0;cnt &lt; tracesPerPage;
                                          cnt++){
          g.drawLine(0,
                     (cnt+1)*traceSpacing,
                     this.getWidth(),
                     (cnt+1)*traceSpacing);
        }//end for loop
        
        //Plot the points if there are any to be
        // plotted.
        if(sampleCounter &gt; 0){
          for(int cnt = 0;cnt &lt;= sampleCounter;
                                          cnt++){
                                            
            //Begin by plotting the values from
            // the blackData array object.
            g.setColor(Color.BLACK);
            
            //Compute a vertical offset to locate
            // the black data on every third axis
            // on the page.
            int yOffset = 
               ((1 + cnt*(sampSpacing + 1)/
                this.getWidth())*3*traceSpacing)
                                - 2*traceSpacing;

            //Draw an oval centered on the sample
            // value to mark the sample in the
            // plot. It is best if the dimensions
            // of the oval are evenly divisible
            // by 2 for  centering purposes.
            //Reverse the sign of the sample
            // value to cause positive sample
            // values to be plotted above the
            // axis.

            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)blackData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines.  Do not draw a
            // line connecting the last sample in
            // one trace to the first sample in
            // the next trace.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blackData[cnt]);
            }//end if

            //Now plot the data stored in the
            // redData array object.
            g.setColor(Color.RED);
            //Compute a vertical offset to locate
            // the red data on every third axis
            // on the page.
            yOffset = (1 + cnt*(sampSpacing + 1)/
                  this.getWidth())*3*traceSpacing
                                  - traceSpacing;
            
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)redData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)redData[cnt]);
                
            }//end if
          

            //Now plot the data stored in the
            // blueData array object.
            g.setColor(Color.BLUE);
            //Compute a vertical offset to locate
            // the blue data on every third axis
            // on the page.
            yOffset = (1 + cnt*(sampSpacing + 1)/
                 this.getWidth())*3*traceSpacing;
            
            //Draw the ovals as described above.
            g.drawOval(cnt*(sampSpacing + 1)%
                   this.getWidth() - ovalWidth/2,
              yOffset - (int)blueData[cnt] 
                                  - ovalHeight/2,
              ovalWidth,
              ovalHeight);
            
            //Connect the sample values with
            // straight lines as described above.
            if(cnt*(sampSpacing + 1)%
                               this.getWidth() &gt;=
                                sampSpacing + 1){
              g.drawLine(
                (cnt - 1)*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blueData[cnt-1],
                cnt*(sampSpacing + 1)%
                                 this.getWidth(),
                yOffset - (int)blueData[cnt]);
            }//end if          
          }//end for loop
        }//end if for sampleCounter &gt; 0
      }//end overridden paint method
    }//end inner class MyCanvas
  }//end inner class Page
}//end class PlotALot04
//=============================================//</code>




</entry>
</row>
</tbody>


</tgroup>
</table>






	

</section>
<section id="h11007">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1233">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1000" type="">


		


			


				

<emphasis id="strong1284" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1022" list-type="bulleted">

					

<item id="li1150">
Module name: Java1492-Plotting Large Quantities of Data 
					using Java

</item>


					

<item id="li1151">
File: Java1492.htm

</item>


					

<item id="li1152">
Published: 08/23/15

</item>



				

</list>




<para id="p1234">
Learn how to use Java to plot millions of multi-channel data values in an easy-to-view format with very little programming effort. 

</para>



				

</note>





	

<note id="note1001" type="">


		


			


				

<emphasis id="strong1285" effect="bold">
Disclaimers:

</emphasis>
<para id="p1235">
<emphasis id="strong1286" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>



				

<para id="p1236">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>



				

<para id="p1237">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>



				

<para id="p1238">
<emphasis id="strong1287" effect="bold">
Affiliation

</emphasis>
: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>




</note>



	




<para id="p1239">
-end- 

</para>







</section>
</content>




</document>