<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Java1482-Spectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT Algorithm</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m49796</md:content-id>
  <md:title>Java1482-Spectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT Algorithm</md:title>
  <md:abstract>Baldwin explains several different programs used for spectral analysis including a DFT program and an FFT program.  He also explains the impact of the sampling frequency and the Nyquist folding frequency on spectral analysis.</md:abstract>
  <md:uuid>201ece7a-a2bf-4576-9528-4c3c4e5322c9</md:uuid>
</metadata>

<content>






<quote id="blockquote1000" display="block">



<para id="p1000">
Revised: Fri Oct 16 23:17:43 CDT 2015

</para>





<para id="p1001">
This page is included in the following books:

</para>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">
<link id="a1000" url="http://cnx.org/contents/98d253c0-8044-4e22-a707-7b8d819bc8a7">


        Digital Signal Processing - DSP

</link>

 

</item>




</list>




</quote>











<section id="h11000">
<title>
<emphasis id="Table_of_contents" effect="bold">

Table of contents

</emphasis>


</title>





<list id="ul1001" list-type="bulleted">
<item id="li1001">
<link id="a1001" target-id="Table_of_contents">

Table of contents

</link>




</item>


<item id="li1002">
<link id="a1002" target-id="Preface">

Preface

</link>




<list id="ul1002" list-type="bulleted">
<item id="li1003">
<link id="a1003" target-id="Viewing_tip">

Viewing tip

</link>




<list id="ul1003" list-type="bulleted">
<item id="li1004">
<link id="a1004" target-id="Figures">

Figures

</link>




</item>


<item id="li1005">
<link id="a1005" target-id="Listings">

Listings

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1006">
<link id="a1006" target-id="Preview">

Preview

</link>




</item>


<item id="li1007">
<link id="a1007" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>




<list id="ul1004" list-type="bulleted">
<item id="li1008">
<link id="a1008" target-id="Sampling_frequency_and_the_Nyquist_folding_frequency">

Sampling 
frequency and the Nyquist folding frequency

</link>




<list id="ul1005" list-type="bulleted">
<item id="li1009">
<link id="a1009" target-id="Display_sinusoids">

Display sinusoids

</link>




</item>


<item id="li1010">
<link id="a1010" target-id="The_plotting_program_named_Graph06">

The plotting program named Graph06

</link>




</item>


<item id="li1011">
<link id="a1011" target-id="The_Nyquist_folding_frequency">

The Nyquist folding frequency

</link>




</item>


<item id="li1012">
<link id="a1012" target-id="One_more_example">

One more example

</link>




</item>


<item id="li1013">
<link id="a1013" target-id="Beginning_of_the_class_named_Dsp029">

Beginning of the class named Dsp029

</link>




</item>


<item id="li1014">
<link id="a1014" target-id="The_getNmbr_method">

The getNmbr method

</link>




</item>


<item id="li1015">
<link id="a1015" target-id="The_method_named_f1">

The method named f1

</link>




</item>


<item id="li1016">
<link id="a1016" target-id="The_program_named_Graph06">

The program named Graph06

</link>




</item>


</list>


</item>


<item id="li1017">
<link id="a1017" target-id="Spectral_Analysis_using_a_DFT_Algorithm0">

Spectral Analysis using a 
DFT Algorithm

</link>




<list id="ul1006" list-type="bulleted">
<item id="li1018">
<link id="a1018" target-id="The_spectral_analysis_output">

The spectral analysis output

</link>




</item>


<item id="li1019">
<link id="a1019" target-id="Another_DFT_example">

Another DFT example

</link>




</item>


<item id="li1020">
<link id="a1020" target-id="The_program_named_Dsp028">

The program named Dsp028

</link>




</item>


<item id="li1021">
<link id="a1021" target-id="Beginning_of_the_class_named_Dsp028">

Beginning of the class named 
Dsp028

</link>




</item>


<item id="li1022">
<link id="a1022" target-id="The_program_named_Graph03">

The program named Graph03

</link>




</item>


<item id="li1023">
<link id="a1023" target-id="The_transform_method_of_the_ForwardRealToComplex01_class">

The 
transform method of the ForwardRealToComplex01 class

</link>




</item>


<item id="li1024">
<link id="a1024" target-id="The_beginning_of_the_transform_method">

The beginning of the transform method

</link>




</item>


</list>


</item>


<item id="li1025">
<link id="a1025" target-id="Spectral_analysis_using_an_FFT_algorithm">

Spectral analysis using 
an FFT algorithm

</link>




<list id="ul1007" list-type="bulleted">
<item id="li1026">
<link id="a1026" target-id="The_program_named_Dsp030">

The program named Dsp030

</link>




</item>


<item id="li1027">
<link id="a1027" target-id="The_ForwardRealToComplexFFT01_class">

The ForwardRealToComplexFFT01 
class

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1028">
<link id="a1028" target-id="Run_the_program">

Run the programs

</link>




</item>


<item id="li1029">
<link id="a1029" target-id="Summary">

Summary

</link>




</item>


<item id="li1030">
<link id="a1030" target-id="Whats_next">

What's next?

</link>




</item>


<item id="li1031">
<link id="a1031" target-id="Complete_program_listings">

Complete program listings

</link>




</item>


<item id="li1032">
<link id="a1032" target-id="Miscellaneous">

Miscellaneous

</link>




</item>


</list>



	
	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	
	

<para id="p1002">
<emphasis id="strong1000" effect="bold">
<emphasis id="em1000" effect="italics">
The how and the why of spectral analysis

</emphasis>
</emphasis>
</para>





<para id="p1003">
A previous module titled


<link id="a1033" url="http://cnx.org/contents/9fdb2951-7fca-47a1-83fc-d3d3d15d6ff1/Java1478-Fun-with-Java-How-and">


Fun with Java, How and Why Spectral Analysis Works

</link>

 explained how and why 
spectral analysis works. An understanding of that module is a prerequisite to 
understanding this module. 

</para>





<para id="p1004">
<emphasis id="strong1001" effect="bold">
<emphasis id="em1001" effect="italics">
Programs to perform spectral analysis

</emphasis>
</emphasis>
</para>





<para id="p1005">
In this module I will provide and explain different programs used for 
performing spectral analysis. The first program is a very general program that 
implements a 

<emphasis id="em1002" effect="italics">
Discrete Fourier Transform (DFT)

</emphasis>
 algorithm. I will explain 
this program in detail.

</para>





<para id="p1006">
The second program is a less general, but much faster program that implements 
a 

<emphasis id="em1003" effect="italics">
Fast Fourier Transform (FFT)

</emphasis>
 algorithm. I will defer an explanation 
of this program until a future module. I am providing it here so that you can 
use it and compare it with the DFT program in terms of speed and flexibility.

</para>





<para id="p1007">
<emphasis id="strong1002" effect="bold">
<emphasis id="em1004" effect="italics">
Fundamental aspects of spectral analysis

</emphasis>
</emphasis>
</para>





<para id="p1008">
I will use the DFT program to illustrate several fundamental aspects of 
spectral analysis that center around the sampling frequency and the Nyquist 
folding frequency.

</para>





<para id="p1009">
<emphasis id="strong1003" effect="bold">
<emphasis id="em1005" effect="italics">
Visual illustration of sampling

</emphasis>
</emphasis>
</para>





<para id="p1010">
I will also provide and explain a program that produces a visual illustration 
of the impact of the sampling frequency and the Nyquist folding frequency.

</para>





<para id="p1011">
<emphasis id="strong1004" effect="bold">
<emphasis id="em1006" effect="italics">
Plotting programs

</emphasis>
</emphasis>
</para>





<para id="p1012">
Finally, I will provide, but will not explain two different programs used for 
display purposes. These are newer versions of graphics display programs that I 
explained in the module titled


<link id="a1034" url="http://cnx.org/contents/b5a14d3a-c54c-4239-b414-bae75d1e8cda/Java1468-Plotting-Engineering-">


Plotting Engineering and Scientific Data using Java

</link>

.

</para>



	
	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1013">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Figures 
and Listings while you are reading about them.

</para>



	

<section id="h31000">
<title>
<emphasis id="Figures" effect="bold">

Figures

</emphasis>


</title>





<list id="ul1008" list-type="bulleted">



<item id="li1033">
<link id="a1035" target-id="Figure_1">

Figure 1.

</link>


 Required parameters.

</item>




<item id="li1034">
<link id="a1036" target-id="Figure_2">

Figure 2.

</link>


 Actual parameter values.

</item>




<item id="li1035">
<link id="a1037" target-id="Figure_3">

Figure 3.

</link>


 Program output for five sinusoids.

</item>




<item id="li1036">
<link id="a1038" target-id="Figure_4">

Figure 4.

</link>


 A new set of frequency values.

</item>




<item id="li1037">
<link id="a1039" target-id="Figure_5">

Figure 5.

</link>


 Program output for five sinusoids.

</item>




<item id="li1038">
<link id="a1040" target-id="Figure_6">

Figure 6.

</link>


 One more example.

</item>




<item id="li1039">
<link id="a1041" target-id="Figure_7">

Figure 7.

</link>


 Program output for five sinusoids.

</item>




<item id="li1040">
<link id="a1042" target-id="Figure_8">

Figure 8.

</link>


 Parameters for spectral analysis.

</item>




<item id="li1041">
<link id="a1043" target-id="Figure_9">

Figure 9.

</link>


 Spectral analysis of five sinusoids.

</item>




<item id="li1042">
<link id="a1044" target-id="Figure_10">

Figure 10.

</link>


 The input parameters.

</item>




<item id="li1043">
<link id="a1045" target-id="Figure_11">

Figure 11.

</link>


 Spectral analysis of five sinusoids.

</item>




<item id="li1044">
<link id="a1046" target-id="Figure_12">

Figure 12.

</link>


 Required input parameters for Dsp028.

</item>




<item id="li1045">
<link id="a1047" target-id="Figure_13">

Figure 13.

</link>


 Contents of Dsp028.txt file.

</item>




<item id="li1046">
<link id="a1048" target-id="Figure_14">

Figure 14.

</link>


 Output from Graph03.

</item>




<item id="li1047">
<link id="a1049" target-id="Figure_15">

Figure 15.

</link>


  Spectral transform expressions.

</item>




<item id="li1048">
<link id="a1050" target-id="Figure_16">

Figure 16.

</link>


 Required input parameters for Dsp030.

</item>




<item id="li1049">
<link id="a1051" target-id="Figure_17">

Figure 17.

</link>


 Example input parameters.

</item>




<item id="li1050">
<link id="a1052" target-id="Figure_18">

Figure 18.

</link>


 FFT of five sinusoids.

</item>




<item id="li1051">
<link id="a1053" target-id="Figure_19">

Figure 19.

</link>


 Parameters for A matching DFT spectral analysis.

</item>




<item id="li1052">
<link id="a1054" target-id="Figure_20">

Figure 20.

</link>


 DFT of five sinusoids.

</item>




</list>



	

</section>
<section id="h31001">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>





<list id="ul1009" list-type="bulleted">



<item id="li1053">
<link id="a1055" target-id="Listing_1">

Listing 1.

</link>


 Beginning of the class named Dsp029.

</item>




<item id="li1054">
<link id="a1056" target-id="Listing_2">

Listing 2.

</link>


 Create array objects to hold sinusoidal data.

</item>




<item id="li1055">
<link id="a1057" target-id="Listing_3">

Listing 3.

</link>


 Get the parameters.

</item>




<item id="li1056">
<link id="a1058" target-id="Listing_4">

Listing 4.

</link>


 Create the sinusoidal data.

</item>




<item id="li1057">
<link id="a1059" target-id="Listing_5">

Listing 5.

</link>


 The code for GraphIntfc01.

</item>




<item id="li1058">
<link id="a1060" target-id="Listing_6">

Listing 6.

</link>


 The getNmbr method.

</item>




<item id="li1059">
<link id="a1061" target-id="Listing_7">

Listing 7.

</link>


 The method named f1.

</item>




<item id="li1060">
<link id="a1062" target-id="Listing_8">

Listing 8.

</link>


 Beginning of the class named Dsp028.

</item>




<item id="li1061">
<link id="a1063" target-id="Listing_9">

Listing 9.

</link>


 Declare array variables.

</item>




<item id="li1062">
<link id="a1064" target-id="Listing_10">

Listing 10.

</link>


 Beginning of the constructor.

</item>




<item id="li1063">
<link id="a1065" target-id="Listing_11">

Listing 11.

</link>


 Create the raw sinusoidal data.

</item>




<item id="li1064">
<link id="a1066" target-id="Listing_12">

Listing 12.

</link>


 Perform the spectral analysis.

</item>




<item id="li1065">
<link id="a1067" target-id="Listing_13">

Listing 13.

</link>


 The method named f1.

</item>




<item id="li1066">
<link id="a1068" target-id="Listing_14">

Listing 14.

</link>


 The beginning of the transform method.

</item>




<item id="li1067">
<link id="a1069" target-id="Listing_15">

Listing 15.

</link>


 The remainder of the method and the class.

</item>




<item id="li1068">
<link id="a1070" target-id="Listing_16">

Listing 16.

</link>


 Dsp029.java.

</item>




<item id="li1069">
<link id="a1071" target-id="Listing_17">

Listing 17.

</link>


 GraphIntfc01.java.

</item>




<item id="li1070">
<link id="a1072" target-id="Listing_18">

Listing 18.

</link>


 Graph06.java.

</item>




<item id="li1071">
<link id="a1073" target-id="Listing_19">

Listing 19.

</link>


 Dsp028.java.

</item>




<item id="li1072">
<link id="a1074" target-id="Listing_20">

Listing 20.

</link>


 Graph03.java.

</item>




<item id="li1073">
<link id="a1075" target-id="Listing_21">

Listing 21.

</link>


 ForwardRealToComplex01.java.

</item>




<item id="li1074">
<link id="a1076" target-id="Listing_22">

Listing 22.

</link>


 Dsp030.java.

</item>




<item id="li1075">
<link id="a1077" target-id="Listing_23">

Listing 23.

</link>


 ForwardRealToComplexFFT01.java.

</item>




</list>







</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="Preview" effect="bold">

Preview

</emphasis>


</title>




<para id="p1014">
Before I get into the technical details, here is a preview of the programs 
and their purposes that I will present and explain in this module:

</para>





<list id="ul1010" list-type="bulleted">

	

<item id="li1076">
Dsp029 - Provides a visual illustration of the impact of the sampling 
	frequency and the Nyquist folding frequency.

</item>


	

<item id="li1077">
Dsp028 - Driver program for doing spectral analysis using a DFT 
	algorithm.

</item>


	

<item id="li1078">
ForwardRealToComplex01 - Class that implements the DFT algorithm.

</item>


	

<item id="li1079">
Dsp030 - Driver program for doing spectral analysis using an FFT 
	algorithm.

</item>


	

<item id="li1080">
ForwardRealToComplexFFT01 - Class that implements the FFT algorithm 
	(will defer explanation until a future module).

</item>


	

<item id="li1081">
Graph03 - Used to display results of spectral analysis. 

<emphasis id="em1007" effect="italics">
(The 
	concepts were explained in the earlier module titled 

</emphasis>

	

<link id="a1078" url="http://cnx.org/contents/b5a14d3a-c54c-4239-b414-bae75d1e8cda/Java1468-Plotting-Engineering-">


	

<emphasis id="em1008" effect="italics">
Plotting Engineering and Scientific Data using Java

</emphasis>
</link>


<emphasis id="em1009" effect="italics">
.)

</emphasis>
</item>


	

<item id="li1082">
Graph06 - Used to display the impact of sampling frequency and the 
	Nyquist folding frequency. Also used to display the results of spectral 
	analysis. 

<emphasis id="em1010" effect="italics">
(The concepts were explained in the earlier module titled 

</emphasis>

	

<link id="a1079" url="http://cnx.org/contents/b5a14d3a-c54c-4239-b414-bae75d1e8cda/Java1468-Plotting-Engineering-">


	

<emphasis id="em1011" effect="italics">
Plotting Engineering and Scientific Data using Java

</emphasis>
</link>


<emphasis id="em1012" effect="italics">
.)

</emphasis>
</item>




</list>


	
	

</section>
<section id="h11003">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	
	

<para id="p1015">
This will be a long module involving lots of code and lots of 
	explanations, so fill your cup with java and let's get started.

</para>





<section id="h21001">
<title>
<emphasis id="Sampling_frequency_and_the_Nyquist_folding_frequency" effect="bold">

Sampling 
frequency and the Nyquist folding frequency

</emphasis>


</title>




<para id="p1016">
I will begin the discussion with the program named 

<emphasis id="strong1005" effect="bold">
Dsp029

</emphasis>
, 
which provides a visual illustration of the impact of the sampling frequency and 
the Nyquist folding frequency. A complete listing of this program is shown in 


<link id="a1080" target-id="Listing_16">

 Listing 16

</link>

 near the end of the module.

</para>





<section id="h31002">
<title>
<emphasis id="Display_sinusoids" effect="bold">

Display sinusoids

</emphasis>


</title>




<para id="p1017">
This program generates and displays up to five sinusoids having the same 
sampling frequency but having different sinusoidal frequencies and amplitudes. 
The program provides a visual illustration of the way in which frequencies above 
one-half the sampling frequency fold back into the area bounded by zero and 
one-half the sampling frequency.

</para>





<quote id="blockquote1001" display="block">

	

<para id="p1018">
<emphasis id="em1013" effect="italics">
(The frequency at one-half the sampling frequency is known as the 
	Nyquist folding frequency.)

</emphasis>
</para>





</quote>




<section id="h41000">
<title>
Input parameters

</title>




<para id="p1019">
The program gets its input parameters from a file named 

<emphasis id="strong1006" effect="bold">
Dsp029.txt

</emphasis>
. 
If that file doesn't exist in the current directory, the program uses a set of 
default parameters.

</para>





<para id="p1020">
Each parameter value must be stored as characters on a separate line in the 
file named 

<emphasis id="strong1007" effect="bold">
Dsp029.txt

</emphasis>
. The required parameters are shown in 


<link id="a1081" target-id="Figure_1">

 Figure 1

</link>

. 

</para>





<table id="table1000" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1000">
<row id="tr1000">
<entry id="th1000">



<emphasis id="Figure_1" effect="bold">

Figure 1.

</emphasis>

 Required parameters.

</entry>



</row>
</thead>


<tbody id="tbody1000">
<row id="tr1001">
<entry id="td1000">

		

<code id="pre1000" display="block">Data length as type int
Number of sinusoids as type int.  Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.</code>




</entry>
</row>
</tbody>


</tgroup>
</table>





</section>
<section id="h41001">
<title>
The length of the two lists

</title>




<para id="p1021">
The number of values in each of the lists must match the value for the number 
of sinusoids. Also, you must not allow blank lines at the end of the data in the 
file.

</para>





</section>
<section id="h41002">
<title>
Frequency value specifications

</title>




<para id="p1022">
Each frequency value is specified as a type double value representing a 
fractional part of the sampling frequency.

</para>





<quote id="blockquote1002" display="block">

	

<para id="p1023">
<emphasis id="em1014" effect="italics">
(For example, a double value of 0.5 specifies one-half the sampling 
	frequency, or the Nyquist folding frequency. A double value of 2.0 specifies 
	a frequency that is twice the sampling frequency.)

</emphasis>
</para>





</quote>




<para id="p1024">
<link id="a1082" target-id="Figure_2">

 Figure 2

</link>

 shows the contents of the file named 

<emphasis id="strong1008" effect="bold">
Dsp029.txt

</emphasis>
 
that I used to produce the output shown in 

<link id="a1083" target-id="Figure_3">

 Figure 3

</link>

. I will discuss that output 
later.

</para>






<table id="table1001" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1001">
<row id="tr1002">
<entry id="th1001">



<emphasis id="Figure_2" effect="bold">

Figure 2.

</emphasis>

 Actual parameter values.

</entry>



</row>
</thead>


<tbody id="tbody1001">
<row id="tr1003">
<entry id="td1001">

		

<code id="pre1001" display="block">50.0
5
0.03125
0.0625
0.125
0.25
0.5
90
90
90
90
90</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
</section>
<section id="h31003">
<title>
<emphasis id="The_plotting_program_named_Graph06" effect="bold">

The plotting program named Graph06

</emphasis>


</title>




<para id="p1025">
The plotting program that is used to plot the output data from this program 
requires that the program implement 

<emphasis id="strong1009" effect="bold">
GraphIntfc01

</emphasis>
. I discussed that interface in 
the module titled


<link id="a1084" url="http://cnx.org/contents/b5a14d3a-c54c-4239-b414-bae75d1e8cda/Java1468-Plotting-Engineering-">


Plotting Engineering and Scientific Data using Java

</link>

. For example, the 
plotting program named 

<emphasis id="strong1010" effect="bold">
Graph06

</emphasis>
 can be used to plot the data produced by this 
program. When it is used, the program is executed and its output is plotted by 
entering the following at the command line prompt:

</para>





<code id="pre1002" display="block">java Graph06 Dsp029</code>




<section id="h41003">
<title>
Program output

</title>




<para id="p1026">
<link id="a1085" target-id="Figure_3">

 Figure 3

</link>

 shows the output produced by running the program named 

<emphasis id="strong1011" effect="bold">
Dsp029

</emphasis>
 with 
the parameters shown in 

<link id="a1086" target-id="Figure_2">

 Figure 2

</link>

 and then adjusting the xMax parameter in the 
textbox at the bottom of the display.

</para>






<table id="table1002" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1002">
<row id="tr1004">
<entry id="th1002">



<emphasis id="Figure_3" effect="bold">

Figure 3.

</emphasis>

 Program output for five sinusoids.

</entry>



</row>
</thead>


<tbody id="tbody1002">
<row id="tr1005">
<entry id="td1002">




<media id="media1000" alt="missing image" display="block">
<image id="img1000" mime-type="image/jpeg" src="../../media/java1482a1.jpg" width="409" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





</section>
<section id="h41004">
<title>
Five horizontal plots

</title>




<para id="p1027">
Each of the five horizontal plots in 

<link id="a1087" target-id="Figure_3">

 Figure 3

</link>

 shows a sampled sinusoid. Each 
of the vertical bars represents one sample value for a given sinusoid.

</para>





<para id="p1028">
If you examine the frequency values in 

<link id="a1088" target-id="Figure_2">

 Figure 2

</link>

 carefully, you will see that 
they represent the sampling frequency divided by the factors 32, 16, 8, 4, and 
2. Thus, the last frequency value is the Nyquist folding frequency and the first 
four frequency values are related to that frequency by multiples of two.

</para>





<para id="p1029">
The horizontal plot at the top of 

<link id="a1089" target-id="Figure_3">

 Figure 3

</link>

 is a reasonably well defined 
cosine wave. The horizontal plot at the bottom of 

<link id="a1090" target-id="Figure_3">

 Figure 3

</link>

 shows the result of 
having exactly two samples per cycle of the sinusoid. Using this plotting 
scheme, the sampled sinusoid is represented as a square wave. Using another 
plotting scheme 

<emphasis id="em1015" effect="italics">
(such as that used in the program named 

<emphasis id="strong1012" effect="bold">
Graph03

</emphasis>
)

</emphasis>
 
the sampled sinusoid at the bottom would be represented as a triangular wave.

</para>





</section>
<section id="h41005">
<title>
An upper frequency limit

</title>




<para id="p1030">
Regardless of the plotting scheme used, it should be obvious that a set of 
uniform samples cannot possibly represent frequencies higher than one-half the 
sampling frequency because then there would be less than one sample per cycle of 
the sinusoid.

</para>





</section>
</section>
<section id="h31004">
<title>
<emphasis id="The_Nyquist_folding_frequency" effect="bold">

The Nyquist folding frequency

</emphasis>


</title>




<para id="p1031">
Now I will show you why the frequency at one-half the sampling frequency is 
referred to as the folding frequency using the new set of frequency values shown 
in 

<link id="a1091" target-id="Figure_4">

 Figure 4

</link>

.

</para>





<quote id="blockquote1003" display="block">

	

<para id="p1032">
<emphasis id="em1016" effect="italics">
(

<link id="a1092" target-id="Figure_4">

 Figure 4

</link>

 shows the values read from the file named 

<emphasis id="strong1013" effect="bold">
Dsp029.txt

</emphasis>
 and 
	displayed in an improved format.)

</emphasis>
</para>





</quote>




<para id="p1033">
In this case, the third frequency in the list is one-half the sampling 
frequency, which is the folding frequency. The two frequencies on either side of 
that one have values that are symmetrical about the folding frequency.

</para>





<table id="table1003" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1003">
<row id="tr1006">
<entry id="th1003">



<emphasis id="Figure_4" effect="bold">

Figure 4.

</emphasis>

 A new set of frequency values.

</entry>



</row>
</thead>


<tbody id="tbody1003">
<row id="tr1007">
<entry id="td1003">

		

<code id="pre1003" display="block">Data length: 50
Number sinusoids: 5
Frequencies
0.125
0.25
0.5
0.75
0.875
Amplitudes
90.0
90.0
90.0
90.0
90.0</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41006">
<title>
The program output

</title>




<para id="p1034">
The five horizontal plots in 

<link id="a1093" target-id="Figure_5">

 Figure 5

</link>

 show the result of running the program 
named 

<emphasis id="strong1014" effect="bold">
Dsp029

</emphasis>
 with the frequencies shown in 

<link id="a1094" target-id="Figure_4">

 Figure 4

</link>

.

</para>







<table id="table1004" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1004">
<row id="tr1008">
<entry id="th1004">



<emphasis id="Figure_5" effect="bold">

Figure 5.

</emphasis>

 Program output for five sinusoids.

</entry>



</row>
</thead>


<tbody id="tbody1004">
<row id="tr1009">
<entry id="td1004">




<media id="media1001" alt="missing image" display="block">
<image id="img1001" mime-type="image/jpeg" src="../../media/java1482a2.jpg" width="409" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<para id="p1035">
The center plot in 

<link id="a1095" target-id="Figure_5">

 Figure 5

</link>

 is the sampled representation of the folding 
frequency.

</para>





<para id="p1036">
The top two plots in 

<link id="a1096" target-id="Figure_5">

 Figure 5

</link>

 are obviously the sampled representations of 
the two lower frequencies specified by the first two frequencies in 

<link id="a1097" target-id="Figure_4">

 Figure 4

</link>

.

</para>





</section>
<section id="h41007">
<title>
Not so obvious ...

</title>




<para id="p1037">
However, it is not so obvious that the bottom two plots in 

<link id="a1098" target-id="Figure_5">

 Figure 5

</link>

 are the 
sampled representations of the two higher frequencies specified by the last two 
frequencies in 

<link id="a1099" target-id="Figure_4">

 Figure 4

</link>

. They look exactly like the top two plots but in reverse 
order.

</para>





</section>
<section id="h41008">
<title>
Unable to distinguish ...

</title>




<para id="p1038">
Frequencies above one-half the sampling frequency are not distinguishable by 
viewing the sampled data. In fact, they are converted to lower frequencies by 
sampling process. The new lower frequencies fold around a point in the frequency 
spectrum given by one-half the sampling frequency. That is why it is called the 
folding frequency. (In 1933, this frequency was named after scientist


<link id="a1100" url="http://www.webopedia.com/TERM/N/Nyquists_Law.html">

Harry Nyquist

</link>

.)

</para>





</section>
</section>
<section id="h31005">
<title>
<emphasis id="One_more_example" effect="bold">

One more example

</emphasis>


</title>




<para id="p1039">
Let's look at one more example of plotted sinusoids. Consider the frequency 
values shown in 

<link id="a1101" target-id="Figure_6">

 Figure 6

</link>

. The second and third frequencies are symmetrical about 
the sampling frequency. The fourth and fifth frequencies are symmetrical about 
twice the sampling frequency. The first frequency value is the same distance 
from zero as the other four frequencies are from the sampling frequency and 
twice the sampling frequency.

</para>






<table id="table1005" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1005">
<row id="tr1010">
<entry id="th1005">



<emphasis id="Figure_6" effect="bold">

Figure 6.

</emphasis>

 One more example.

</entry>



</row>
</thead>


<tbody id="tbody1005">
<row id="tr1011">
<entry id="td1005">

		

<code id="pre1004" display="block">Data length: 50
Number sinusoids: 5
Frequencies
0.1
0.9
1.1
1.9
2.1
Amplitudes
90.0
90.0
90.0
90.0
90.0</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41009">
<title>
The program output

</title>




<para id="p1040">
<link id="a1102" target-id="Figure_7">

 Figure 7

</link>

 shows the output produced by running the program named 

<emphasis id="strong1015" effect="bold">

Dsp029

</emphasis>
 with the frequency parameters specified by 

<link id="a1103" target-id="Figure_6">

 Figure 6

</link>

.

</para>






<table id="table1006" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1006">
<row id="tr1012">
<entry id="th1006">



<emphasis id="Figure_7" effect="bold">

Figure 7.

</emphasis>

 Program output for five sinusoids.

</entry>



</row>
</thead>


<tbody id="tbody1006">
<row id="tr1013">
<entry id="td1006">




<media id="media1002" alt="missing image" display="block">
<image id="img1002" mime-type="image/jpeg" src="../../media/java1482a3.jpg" width="409" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





</section>
<section id="h41010">
<title>
The sinusoids are indistinguishable

</title>




<para id="p1041">
Although the actual frequencies of the five cosine functions are 
significantly different, once they are sampled, they are indistinguishable. The 
sampling process converts the actual frequencies to new frequencies that not 
only fold around one-half the sampling frequency, they also fold around all 
multiples of one-half the sampling frequency.

</para>





</section>
</section>
<section id="h31006">
<title>
<emphasis id="Beginning_of_the_class_named_Dsp029" effect="bold">

Beginning of the class named Dsp029

</emphasis>


</title>




<para id="p1042">
The program named 

<emphasis id="strong1016" effect="bold">
Dsp029

</emphasis>
 is provided in 

<link id="a1104" target-id="Listing_16">

 Listing 16

</link>

 near the 
end of the module. I will break the program down and explain it in fragments, 
beginning with the fragment shown in 

<link id="a1105" target-id="Listing_1">

 Listing 1

</link>

.

</para>





<table id="table1007" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1007">
<row id="tr1014">



<entry id="th1007">
<emphasis id="Listing_1" effect="bold">

Listing 1.

</emphasis>

 Beginning of the class named Dsp029.

</entry>



</row>
</thead>


<tbody id="tbody1007">
<row id="tr1015">
<entry id="td1007">

		

<code id="pre1005" display="block">class Dsp029 implements GraphIntfc01{
  final double pi = Math.PI;//for simplification

  //Begin default parameters
  int len = 400;//data length
  int numberSinusoids = 5;
  //Frequencies of the sinusoids
  double[] freq = {0.1,0.25,0.5,0.75,0.9};
  //Amplitudes of the sinusoids
  double[] amp = {75,75,75,75,75};
  //End default parameters</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1043">
The code in 

<link id="a1106" target-id="Listing_1">

 Listing 1

</link>

 defines a convenience constant representing the value 
of 

<emphasis id="strong1017" effect="bold">
pi

</emphasis>
 and then defines the set of default parameters that will 
be used by the program in the event that the file named 

<emphasis id="strong1018" effect="bold">
Dsp029.txt

</emphasis>
 
does not exist in the current directory.

</para>





<section id="h41011">
<title>
Create array objects to hold sinusoidal data

</title>




<para id="p1044">
The code in 

<link id="a1107" target-id="Listing_2">

 Listing 2

</link>

 creates five array objects that will be populated with 
sinusoidal data.

</para>





<table id="table1008" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1008">
<row id="tr1016">



<entry id="th1008">
<emphasis id="Listing_2" effect="bold">

Listing 2.

</emphasis>

 Create array objects to hold sinusoidal data.

</entry>



</row>
</thead>


<tbody id="tbody1008">
<row id="tr1017">
<entry id="td1008">

		

<code id="pre1006" display="block">  double[] data1 = new double[len];
  double[] data2 = new double[len];
  double[] data3 = new double[len];
  double[] data4 = new double[len];
  double[] data5 = new double[len];</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41012">
<title>
Get the parameters

</title>




<para id="p1045">
The constructor begins in 

<link id="a1108" target-id="Listing_3">

 Listing 3

</link>

. The code in this fragment calls the 
method named 

<emphasis id="strong1019" effect="bold">
getParameters

</emphasis>
 to read the parameters from the file named

<emphasis id="strong1020" effect="bold">
 
Dsp029.txt

</emphasis>
.

</para>





<table id="table1009" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1009">
<row id="tr1018">



<entry id="th1009">
<emphasis id="Listing_3" effect="bold">

Listing 3.

</emphasis>

 Get the parameters.

</entry>



</row>
</thead>


<tbody id="tbody1009">
<row id="tr1019">
<entry id="td1009">

		

<code id="pre1007" display="block">  public Dsp029(){//constructor

    if(new File("Dsp029.txt").exists()){
      getParameters();
    }//end if</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1046">
Before calling the 

<emphasis id="strong1021" effect="bold">
getParameters

</emphasis>
 method, however, the 
program calls the 

<emphasis id="strong1022" effect="bold">
exists

</emphasis>
 method of the 

<emphasis id="strong1023" effect="bold">
File

</emphasis>
 
class to confirm that the file actually exists. If the file doesn't exist, the 
call to 

<emphasis id="strong1024" effect="bold">
getParameters

</emphasis>
 is skipped, causing the default 
parameters defined in 

<link id="a1109" target-id="Listing_1">

 Listing 1

</link>

 to be used instead.

</para>





</section>
<section id="h41013">
<title>
The getParameters method

</title>




<para id="p1047">
The 

<emphasis id="strong1025" effect="bold">
getParameters

</emphasis>
 method is straightforward, so I won't 
discuss it in detail. You can view it in 

<link id="a1110" target-id="Listing_16">

 Listing 16

</link>

. Suffice it to say that the 
method reads the input parameters from the disk file and writes their values 
into the variables declared in 

<link id="a1111" target-id="Listing_1">

 Listing 1

</link>

, overwriting the default values stored 
in those variables.

</para>





<para id="p1048">
In addition, the 

<emphasis id="strong1026" effect="bold">
getParameters

</emphasis>
 method displays the values 
read from the disk file in the format shown in 

<link id="a1112" target-id="Figure_4">

 Figure 4

</link>

 and 

<link id="a1113" target-id="Figure_6">

 Figure 6

</link>

.

</para>





</section>
<section id="h41014">
<title>
Create the sinusoidal data

</title>




<para id="p1049">
For simplicity, this program always generates five sinusoids, even if fewer 
than five were requested as the input parameter value for 

<emphasis id="strong1027" effect="bold">

numberSinusoids

</emphasis>
. In that case, the extra sinusoids are generated using 
default values and are simply ignored when the sinusoids are plotted.

</para>





<para id="p1050">
The code fragment in 

<link id="a1114" target-id="Listing_4">

 Listing 4

</link>

 creates the sinusoidal data for each of the 
five specified frequencies and saves that data in the array objects that were 
created in 

<link id="a1115" target-id="Listing_2">

 Listing 2

</link>

.

</para>





<table id="table1010" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1010">
<row id="tr1020">



<entry id="th1010">
<emphasis id="Listing_4" effect="bold">

Listing 4.

</emphasis>

 Create the sinusoidal data.

</entry>



</row>
</thead>


<tbody id="tbody1010">
<row id="tr1021">
<entry id="td1010">

		

<code id="pre1008" display="block">    for(int n = 0;n &lt; len;n++){
      data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
      data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
      data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
      data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
      data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
    }//end for loop

  }//end constructor</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41015">
<title>
The end of the constructor

</title>




<para id="p1051">
<link id="a1116" target-id="Listing_4">

 Listing 4

</link>

 also signals the end of the constructor. When the constructor 
terminates, an object of the 

<emphasis id="strong1028" effect="bold">
Dsp029

</emphasis>
 class has been 
instantiated. The five arrays shown in 

<link id="a1117" target-id="Listing_4">

 Listing 4

</link>

 have been populated with 
sinusoidal data according to the parameters read from the file named 

<emphasis id="strong1029" effect="bold">

Dsp029.txt

</emphasis>
 or according to the default values of the parameters shown 
in 

<link id="a1118" target-id="Listing_1">

 Listing 1

</link>

.

</para>





</section>
<section id="h41016">
<title>
Plotting the sinusoidal data

</title>




<para id="p1052">
In order to better understand what is going on in the plotting process, it 
would be helpful for you to review the module titled


<link id="a1119" url="http://cnx.org/contents/b5a14d3a-c54c-4239-b414-bae75d1e8cda/Java1468-Plotting-Engineering-">


Plotting Engineering and Scientific Data using Java

</link>

. However, assuming that 
you don't have the time to do that, I will provide a very brief explanation as 
to how the plotting programs work.

</para>





</section>
<section id="h41017">
<title>
Using Graph06 to plot the sinusoidal data

</title>




<para id="p1053">
The plotting program named 

<emphasis id="strong1030" effect="bold">
Graph06

</emphasis>
 can be used to 
plot the sinusoidal data as follows:

</para>





<list id="ul1011" list-type="bulleted">

	

<item id="li1083">
Define and compile the program named 

<emphasis id="strong1031" effect="bold">
Dsp029

</emphasis>
, 
	implementing the interface named 

<emphasis id="strong1032" effect="bold">
GraphIntfc01

</emphasis>
. The 
	definition of that interface is shown in 

<link id="a1120" target-id="Listing_5">

 Listing 5

</link>


</item>


	

<item id="li1084">
Compile the program named 

<emphasis id="strong1033" effect="bold">
Graph06

</emphasis>
. Then start the 
	plotting program named 

<emphasis id="strong1034" effect="bold">
Graph06

</emphasis>
 running by 
	entering the command shown below at the command line prompt.

</item>




</list>




<code id="pre1009" display="block">java Graph06 Dsp029</code>




</section>
<section id="h41018">
<title>
The code for GraphIntfc01

</title>




<table id="table1011" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1011">
<row id="tr1022">



<entry id="th1011">
<emphasis id="Listing_5" effect="bold">

Listing 5.

</emphasis>

 The code for GraphIntfc01.

</entry>



</row>
</thead>


<tbody id="tbody1011">
<row id="tr1023">
<entry id="td1011">

		

<code id="pre1010" display="block">public interface GraphIntfc01{
  public int getNmbr();
  public double f1(double x);
  public double f2(double x);
  public double f3(double x);
  public double f4(double x);
  public double f5(double x);
}//end GraphIntfc01</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41019">
<title>
What does this do?

</title>




<para id="p1054">
When executed in this manner, the program named 

<emphasis id="strong1035" effect="bold">
Graph06

</emphasis>
 
instantiates an object of the class named 

<emphasis id="strong1036" effect="bold">
Dsp029

</emphasis>
 and then calls 
the interface methods on that object to obtain the data to be plotted.

</para>





<para id="p1055">
In this case, the constructor for the 

<emphasis id="strong1037" effect="bold">
Dsp029

</emphasis>
 class populates 
the five array objects with sinusoidal data. The subsequent call to the 
interface methods by the program named 

<emphasis id="strong1038" effect="bold">
Graph06

</emphasis>
 causes that 
sinusoidal data to be retrieved and plotted by Graph06.

</para>





</section>
<section id="h41020">
<title>
The GraphIntfc01 interface methods

</title>




<para id="p1056">
A brief description of each of the interface methods is provided in the 
following sections.

</para>





<section id="h51000">
<title>
The getNmbr method

</title>




<para id="p1057">
Plotting programs based on 

<emphasis id="strong1039" effect="bold">
GraphIntfc01

</emphasis>
 can be used to plot 
any number of functions from one to five.

</para>





<para id="p1058">
The method named 

<emphasis id="strong1040" effect="bold">
getNmbr

</emphasis>
 must return an integer value 
between 1 and 5 that specifies the number of functions to be plotted. The 
plotting program uses that value to divide the total plotting surface into the 
specified number of plotting areas, and plots each of the functions named


<emphasis id="strong1041" effect="bold">
f1

</emphasis>
 through 

<emphasis id="strong1042" effect="bold">
fn

</emphasis>
 in one of those plotting areas.

</para>





</section>
<section id="h51001">
<title>
The methods named f1, f2, f3, f4, and f5

</title>




<para id="p1059">
As you can see in 

<link id="a1121" target-id="Listing_5">

 Listing 5

</link>

, each of these methods receives a double value as 
an incoming parameter and returns a double value. In essence, each of these 
methods receives a value for the horizontal coordinate x and returns the 
corresponding value for the vertical coordinate y.

</para>





</section>
</section>
<section id="h41021">
<title>
One plotting area per method

</title>




<para id="p1060">
Each of these methods provides the data to be plotted in one plotting area. 
The method named 

<emphasis id="strong1043" effect="bold">
f1

</emphasis>
 provides the data for the top plotting area; the method 
named 

<emphasis id="strong1044" effect="bold">
f2

</emphasis>
 provides the data for the first plotting area down from the top, and so 
forth.

</para>





<quote id="blockquote1004" display="block">

	

<para id="p1061">
<emphasis id="em1017" effect="italics">
(For example, if the getNmbr method returns a value of 4, the method 
	named f5 will never be called. If getNmbr returns 5, the method named f5 
	will be called to provide the data for the bottom plotting area.)

</emphasis>
</para>





</quote>




</section>
<section id="h41022">
<title>
How does it work?

</title>




<para id="p1062">
Each plotting area contains a horizontal axis. The plotting program moves 
across the horizontal axis in each plotting area one step at a time 

<emphasis id="em1018" effect="italics">
(moving in 
incremental steps equal to the plotting parameter named 

<emphasis id="strong1045" effect="bold">
xCalcInc

</emphasis>
, which you will 
find if you examine the code for 

<emphasis id="strong1046" effect="bold">
Graph06

</emphasis>
)

</emphasis>
.

</para>





<para id="p1063">
At each step along the way, the plotting program calls the method associated 
with that plotting area, 

<emphasis id="em1019" effect="italics">
(

<emphasis id="strong1047" effect="bold">
f1

</emphasis>
, 

<emphasis id="strong1048" effect="bold">
f2

</emphasis>
, etc.)

</emphasis>
, passing the horizontal position as a 
parameter to the method.

</para>





<para id="p1064">
The value returned by the method is assumed to be the vertical value 
associated with that horizontal position, and that is the vertical value that is 
plotted for that horizontal position.

</para>





</section>
<section id="h41023">
<title>
Doesn't know and doesn't care

</title>




<para id="p1065">
The plotting program doesn't know, and doesn't care how the interface method 
decides on the value to return for each value that it receives as an incoming 
parameter. The plotting program simply calls the methods to get the data, and 
then plots the returned values.

</para>





</section>
<section id="h41024">
<title>
Computed "on the fly"

</title>




<para id="p1066">
For example, the returned values could be computed and returned "on the fly," 
as was the case in the example program named 

<emphasis id="strong1049" effect="bold">
Graph01Demo

</emphasis>
, which I explained in 
the module titled


<link id="a1122" url="http://cnx.org/contents/b5a14d3a-c54c-4239-b414-bae75d1e8cda/Java1468-Plotting-Engineering-">


Plotting Engineering and Scientific Data using Java

</link>

.

</para>





</section>
<section id="h41025">
<title>
Returned from an array

</title>




<para id="p1067">
On the other hand, the values could have been computed earlier and saved in 
an array. That is the case with all the programs that I will explain in this 
module.

</para>





</section>
<section id="h41026">
<title>
From a disk file, a database, the Internet, etc.

</title>




<para id="p1068">
The returned values could be read from a disk file, obtained from a database 
on another computer, or obtained from any other source such as another computer 
on the Internet.

</para>





<para id="p1069">
All that matters is that when the plotting program calls one of the five 
methods named 

<emphasis id="strong1050" effect="bold">
f1

</emphasis>
 through 

<emphasis id="strong1051" effect="bold">
f5

</emphasis>
, passing a 

<emphasis id="strong1052" effect="bold">
double

</emphasis>
 value as a parameter, it expects 
to receive a 

<emphasis id="strong1053" effect="bold">
double

</emphasis>
 value in return, and it will plot the value that it 
receives.

</para>





</section>
</section>
<section id="h31007">
<title>
<emphasis id="The_getNmbr_method" effect="bold">

The getNmbr method

</emphasis>


</title>




<para id="p1070">
The 

<emphasis id="strong1054" effect="bold">
getNmbr

</emphasis>
 method for the class named 

<emphasis id="strong1055" effect="bold">
Dsp029

</emphasis>
 is shown in 

<link id="a1123" target-id="Listing_6">

 Listing 6

</link>

.

</para>





<table id="table1012" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1012">
<row id="tr1024">



<entry id="th1012">
<emphasis id="Listing_6" effect="bold">

Listing 6.

</emphasis>

 The getNmbr method.

</entry>



</row>
</thead>


<tbody id="tbody1012">
<row id="tr1025">
<entry id="td1012">

		

<code id="pre1011" display="block">  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return numberSinusoids;
  }//end getNmbr</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1071">
This is a very simple method. It returns the value stored in the variable 
named 

<emphasis id="strong1056" effect="bold">
numberSinusoids

</emphasis>
. This variable may contain the default 
value established by 

<link id="a1124" target-id="Listing_1">

 Listing 1

</link>

, or may contain the value read from the file 
named 

<emphasis id="strong1057" effect="bold">
Dsp029.txt

</emphasis>
 by the method named 

<emphasis id="strong1058" effect="bold">
getParameters

</emphasis>
.

</para>





</section>
<section id="h31008">
<title>
<emphasis id="The_method_named_f1" effect="bold">

The method named f1

</emphasis>


</title>




<para id="p1072">
The code for the method named 

<emphasis id="strong1059" effect="bold">
f1

</emphasis>
 is shown in 

<link id="a1125" target-id="Listing_7">

 Listing 7

</link>

.

</para>





<table id="table1013" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1013">
<row id="tr1026">



<entry id="th1013">
<emphasis id="Listing_7" effect="bold">

Listing 7.

</emphasis>

 The method named f1.

</entry>



</row>
</thead>


<tbody id="tbody1013">
<row id="tr1027">
<entry id="td1013">

		

<code id="pre1012" display="block">  public double f1(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 || index &gt; data1.length-1){
      return 0;
    }else{
      return data1[index];
    }//end else
  }//end function</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1073">
Note that there is not a one-to-one correspondence between horizontal 
coordinate values and pixels on the screen. For example, it may sometimes be 
necessary to plot 90 values across an area of the screen containing 110 pixels. 
The plotting program must interpolate properly to deal with that issue. 
Therefore, the plotting program deals with horizontal coordinates as type double 
and then converts those coordinate values to integer pixel values when the time 
comes to actually draw the material on the screen.

</para>





<section id="h41027">
<title>
Round from double to int

</title>




<para id="p1074">
The method named 

<emphasis id="strong1060" effect="bold">
f1

</emphasis>
 receives an incoming horizontal 
coordinate value as type 

<emphasis id="strong1061" effect="bold">
double

</emphasis>
. It rounds that value to the 
nearest value of type 

<emphasis id="strong1062" effect="bold">
long

</emphasis>
 and casts it to type 

<emphasis id="strong1063" effect="bold">
int

</emphasis>
 
to determine the index value to use when retrieving the corresponding vertical 
value from the array object.

</para>





<para id="p1075">
If the index value is outside the bounds of the array, the method simply 
returns a value of zero. Otherwise, it uses the index value to return the value 
stored in the array object at that index.

</para>





</section>
<section id="h41028">
<title>
The remaining interface methods

</title>




<para id="p1076">
The remaining four interface methods are identical to the method named


<emphasis id="strong1064" effect="bold">
f1

</emphasis>
, except that each method returns data values stored in a 
different array object. Therefore, I won't discuss those methods.

</para>





</section>
<section id="h41029">
<title>
That's it for Dsp029

</title>




<para id="p1077">
That's about it for the program named 

<emphasis id="strong1065" effect="bold">
Dsp029

</emphasis>
. If you 
understand this program, you are well ahead of the game. The overall structure 
for the programs named 

<emphasis id="strong1066" effect="bold">
Dsp028

</emphasis>
 and 

<emphasis id="strong1067" effect="bold">
Dsp030

</emphasis>
 are 
very similar to the structure for 

<emphasis id="strong1068" effect="bold">
Dsp029

</emphasis>
. The big difference is 
the manner in which they populate the array objects with the data that is to be 
plotted. Instead of simply plotting sinusoids, they perform spectral analysis on 
sinusoids and provide the results of the spectral analysis to be plotted.

</para>





</section>
<section id="h41030">
<title>
Using the interface named GraphIntfc01

</title>




<para id="p1078">
As you learned earlier, this is a very simple interface. However, because the 
class named 

<emphasis id="strong1069" effect="bold">
Dsp029

</emphasis>
 implements the interface, the interface 
definition file must be in the same directory as the source file for 

<emphasis id="strong1070" effect="bold">

Dsp029

</emphasis>
 in order to successfully compile 

<emphasis id="strong1071" effect="bold">
Dsp029

</emphasis>
. 
Therefore, I have provided a complete listing of 

<emphasis id="strong1072" effect="bold">
GraphIntfc01

</emphasis>
 
in 

<link id="a1126" target-id="Listing_17">

 Listing 17

</link>

 near the end of the module.

</para>





</section>
</section>
<section id="h31009">
<title>
<emphasis id="The_program_named_Graph06" effect="bold">

The program named Graph06

</emphasis>


</title>




<para id="p1079">
A complete listing of the program named 

<emphasis id="strong1073" effect="bold">
Graph06

</emphasis>
 is provided 
in 

<link id="a1127" target-id="Listing_18">

 Listing 18

</link>

 near the end of the module. This is simply a newer version of 
graphics display programs that I explained in the earlier module titled


<link id="a1128" url="http://cnx.org/contents/b5a14d3a-c54c-4239-b414-bae75d1e8cda/Java1468-Plotting-Engineering-">


Plotting Engineering and Scientific Data using Java

</link>

. Therefore, I won't 
repeat that explanation here. The comments at the beginning and spread 
throughout the program provide considerable information about it.

</para>





<section id="h41031">
<title>
Operational aspects of Graph06

</title>




<para id="p1080">
However, an explanation of the operational aspects of the program will be 
useful here. You can use this program to display the output produced by 

<emphasis id="strong1074" effect="bold">

Dsp029

</emphasis>
 by entering the following at the command line prompt:

</para>





<code id="pre1013" display="block">java Graph06 Dsp029</code>




<para id="p1081">
As you saw in 

<link id="a1129" target-id="Figure_3">

 Figure 3

</link>

 and other previous figures, this program provides the 
following text fields for user input, along with a button labeled 

<emphasis id="strong1075" effect="bold">
Graph

</emphasis>
:

</para>





<list id="ul1012" list-type="bulleted">

	

<item id="li1085">
xMin = minimum x-axis value

</item>


	

<item id="li1086">
xMax = maximum x-axis value

</item>


	

<item id="li1087">
yMin = minimum y-axis value

</item>


	

<item id="li1088">
yMax = maximum y-axis value

</item>


	

<item id="li1089">
xTicInt = tic interval on x-axis

</item>


	

<item id="li1090">
yTicInt = tic interval on y-axis

</item>


	

<item id="li1091">
xCalcInc = calculation interval

</item>




</list>




<para id="p1082">
These text fields make it possible for you to adjust the plotting parameters 
and to re-plot the graphs as many times as needed.

</para>





<para id="p1083">
You can modify any of these parameters and then click the 

<emphasis id="strong1076" effect="bold">
Graph

</emphasis>
 
button to cause the five functions to be re-plotted according to the new 
plotting parameters.

</para>





</section>
</section>
</section>
<section id="h21002">
<title>
<emphasis id="Spectral_Analysis_using_a_DFT_Algorithm0" effect="bold">

Spectral Analysis using a 
DFT Algorithm

</emphasis>


</title>




<para id="p1084">
Now that you have a good idea where we are heading, it's time to start doing 
some spectral analysis.

</para>





<para id="p1085">
Let's begin by looking at some output obtained by performing a spectral 
analysis on the same five sinusoids shown in 

<link id="a1130" target-id="Figure_3">

 Figure 3

</link>

. The parameters used to 
perform this spectral analysis are shown in 

<link id="a1131" target-id="Figure_8">

 Figure 8

</link>

. 

<emphasis id="em1020" effect="italics">
(I will explain each 
of these parameters as we go along.)

</emphasis>
</para>





<table id="table1014" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1014">
<row id="tr1028">
<entry id="th1014">



<emphasis id="Figure_8" effect="bold">

Figure 8.

</emphasis>

 Parameters for spectral analysis.

</entry>



</row>
</thead>


<tbody id="tbody1014">
<row id="tr1029">
<entry id="td1014">

		

<code id="pre1014" display="block">Data length: 400
Sample for zero time: 0
Lower frequency bound: 0.0
Upper frequency bound: 1.0
Number spectra: 5
Frequencies
0.03125
0.0625
0.125
0.25
0.5
Amplitudes
90.0
90.0
90.0
90.0
90.0</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1086">
Although more parameters are required to perform spectral analysis than are 
required to simply generate and plot the sinusoids, the number of sinusoids, the 
frequencies of the sinusoids, and the amplitudes of the sinusoids in 

<link id="a1132" target-id="Figure_8">

 Figure 8

</link>

 
are the same as in 

<link id="a1133" target-id="Figure_2">

 Figure 2

</link>

.

</para>





<section id="h31010">
<title>
<emphasis id="The_spectral_analysis_output" effect="bold">

The spectral analysis output

</emphasis>


</title>




<para id="p1087">
The output produced by performing spectral analysis on these five sinusoids 
is shown in 

<link id="a1134" target-id="Figure_9">

 Figure 9

</link>

. The computation and display of this spectral analysis was 
performed using the programs named 

<emphasis id="strong1077" effect="bold">
Dsp028

</emphasis>
 and 

<emphasis id="strong1078" effect="bold">
Graph03

</emphasis>
.


<emphasis id="em1021" effect="italics">
(Note that the parameters in the text boxes at the bottom were used to alter 
the appearance of the plots.)

</emphasis>
</para>






<table id="table1015" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1015">
<row id="tr1030">
<entry id="th1015">



<emphasis id="Figure_9" effect="bold">

Figure 9.

</emphasis>

 Spectral analysis of five sinusoids.

</entry>



</row>
</thead>


<tbody id="tbody1015">
<row id="tr1031">
<entry id="td1015">




<media id="media1003" alt="missing image" display="block">
<image id="img1003" mime-type="image/jpeg" src="../../media/java1482a4.jpg" width="409" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<section id="h41032">
<title>
The format explained

</title>




<para id="p1088">
Five separate spectral analyses were performed and the results of those five 
spectral analyses are shown in 

<link id="a1135" target-id="Figure_9">

 Figure 9

</link>

. Each of the horizontal lines in 

<link id="a1136" target-id="Figure_9">

 Figure 9

</link>


 is the horizontal axis used to display the result of performing a spectral 
analysis on a different sinusoid. In other words, 

<link id="a1137" target-id="Figure_9">

 Figure 9

</link>

 contains five 
separate graphs moving from the top to the bottom of the display. The individual 
graphs have alternating white and gray backgrounds to make them easier to 
separate visually.

</para>





<para id="p1089">
The top graph in 

<link id="a1138" target-id="Figure_9">

 Figure 9

</link>

 shows the result of performing a spectral analysis 
on the top sinusoid in 

<link id="a1139" target-id="Figure_3">

 Figure 3

</link>

. Moving down the page, each graph in 

<link id="a1140" target-id="Figure_9">

 Figure 9

</link>

 
shows the result of performing a spectral analysis on the corresponding sinusoid 
in 

<link id="a1141" target-id="Figure_3">

 Figure 3

</link>

.

</para>





</section>
<section id="h41033">
<title>
The frequency axes

</title>




<para id="p1090">
The horizontal axes in 

<link id="a1142" target-id="Figure_9">

 Figure 9

</link>

 represent the frequency range from zero to 
the sampling frequency.

</para>





<quote id="blockquote1005" display="block">

	

<para id="p1091">
<emphasis id="em1022" effect="italics">
(The frequency range covered is specified by the Lower frequency 
	bound and the Upper frequency bound parameters in 

<link id="a1143" target-id="Figure_8">

 Figure 8

</link>

.)

</emphasis>
</para>





</quote>




</section>
<section id="h41034">
<title>
The horizontal units

</title>




<para id="p1092">
The horizontal units in 

<link id="a1144" target-id="Figure_9">

 Figure 9

</link>

 don't represent frequency in an absolute 
sense of cycles per second or Hertz. Rather, the horizontal units in 

<link id="a1145" target-id="Figure_9">

 Figure 9

</link>

 
represent the frequency bins for which spectral energy was computed. In this 
case, the spectral energy for each sinusoid was computed in 400 equally spaced 
bins distributed between zero and the sampling frequency.

</para>





<quote id="blockquote1006" display="block">

	

<para id="p1093">
<emphasis id="em1023" effect="italics">
(The number of frequency bins for each individual spectrum computed 
	by this program is equal to the 

<emphasis id="strong1079" effect="bold">
Data

</emphasis>
 length parameter in 
	

<link id="a1146" target-id="Figure_8">

 Figure 8

</link>

. Those frequency bins are distributed uniformly between the 

<emphasis id="strong1080" effect="bold">

	Lower

</emphasis>
 frequency bound and the 

<emphasis id="strong1081" effect="bold">
Upper

</emphasis>
 frequency 
	bound parameters in 

<link id="a1147" target-id="Figure_8">

 Figure 8

</link>

.)

</emphasis>
</para>





</quote>




</section>
<section id="h41035">
<title>
Location of the folding frequency

</title>




<para id="p1094">
Because the right-most end of each horizontal axis in 

<link id="a1148" target-id="Figure_9">

 Figure 9

</link>

 represents the 
sampling frequency, the center of each horizontal axis represents one-half the 
sampling frequency, or the Nyquist folding frequency. Thus, the frequency 
represented by the center of each horizontal axis represents the frequency 
specified by a value of 0.5 in 

<link id="a1149" target-id="Figure_8">

 Figure 8

</link>

.

</para>





</section>
<section id="h41036">
<title>
A peak at the folding frequency

</title>




<para id="p1095">
You can see a large peak in energy at the folding frequency of the bottom 
graph in 

<link id="a1150" target-id="Figure_9">

 Figure 9

</link>

. That peak corresponds to the frequency of the fifth sinusoid 
specified in the parameters shown in 

<link id="a1151" target-id="Figure_8">

 Figure 8

</link>

. 

<emphasis id="em1024" effect="italics">
(This also corresponds to the 
spectrum of the bottom graph in 

<link id="a1152" target-id="Figure_3">

 Figure 3

</link>

.)

</emphasis>
</para>





<para id="p1096">
Knowing that, you should be able to correlate each of the peaks to the left 
of center in 

<link id="a1153" target-id="Figure_9">

 Figure 9

</link>

 with the frequencies of the sinusoids specified in 

<link id="a1154" target-id="Figure_8">

 Figure 8

</link>

 
and with the individual sinusoids plotted in 

<link id="a1155" target-id="Figure_3">

 Figure 3

</link>

.

</para>





</section>
<section id="h41037">
<title>
The frequency folding effect

</title>




<para id="p1097">
<link id="a1156" target-id="Figure_9">

 Figure 9

</link>

 clearly shows the frequency folding effect of the sampling process 
illustrated earlier. As you can see, the peaks in the various graphs to the 
right of the folding frequency are mirror images of the peaks to the left of the 
folding frequency. In other words, given a set of samples of a sinusoid, the 
spectral analysis process is unable to determine whether the peak is above or 
below the folding frequency, so the energy is equally distributed between two 
peaks on opposite sides of the folding frequency.

</para>





</section>
<section id="h41038">
<title>
Size of the peak at the folding frequency

</title>




<para id="p1098">
Note that the peak in the bottom graph is approximately twice the height of 
the peaks in the other graphs. This is because the peak at the folding frequency 
has no mirror-image partner, and all the energy is concentrated in that single 
peak.

</para>





<quote id="blockquote1007" display="block">

	

<para id="p1099">
<emphasis id="em1025" effect="italics">
(Another interpretation is that two mirror-image peaks converge at 
	the folding frequency causing the resulting peak to be twice as large as 
	either mirror-image peak. I will illustrate this effect with another example 
	later.)

</emphasis>
</para>





</quote>




</section>
<section id="h41039">
<title>
A short fat peak at the top

</title>




<para id="p1100">
You may also have noticed that the peaks in the top graph are shorter and 
wider than the peaks in the other graphs. This may be because the actual 
frequency of the sinusoid for the top graph is about half way between the values 
of the twelfth and thirteenth bins for which spectral energy was computed. Thus, 
the energy in the sinusoid was spread between the bins on either side of the 
actual frequency.

</para>





<para id="p1101">
This frequency spreading effect can be minimized by increasing the data 
length to 800 samples. This causes the frequency bins to be only half as wide 
and the peak in the top graph becomes tall and narrow just like the peaks in the 
other graphs. You should try this and observe the result when you run the 
program later.

</para>





<para id="p1102">
It is also instructive to plot these spectra with a data length of 400 using 
the program named 

<emphasis id="strong1082" effect="bold">
Graph06

</emphasis>
. This will show you how the energy is 
distributed between the frequency bins. This is most effective when the graph is 
expanded as described in the next section.

</para>





</section>
<section id="h41040">
<title>
Mapping the peaks to pixels

</title>




<para id="p1103">
The broadening of the peak in the top graph may also have to do with the 
requirement to map the peaks in the spectrum to the locations of the actual 
pixels on the screen. If the location of the peak falls between the positions of 
two pixels, the plotting program must interpolate the energy in the peak so as 
to display that energy in actual pixel locations.

</para>





<para id="p1104">
This effect can be minimized by plotting the same number of spectral values 
across a wider area of the screen. When you run this program later, click the 
maximize button on the 

<emphasis id="strong1083" effect="bold">
Frame

</emphasis>
 to cause the display to occupy the 
entire screen. That will give you a much better look at the actual shape of each 
of the peaks. Do this using both 

<emphasis id="strong1084" effect="bold">
Graph03

</emphasis>
 and 

<emphasis id="strong1085" effect="bold">
Graph06

</emphasis>
 
to plot the results.

</para>





<quote id="blockquote1008" display="block">

	

<para id="p1105">
<emphasis id="em1026" effect="italics">
(Note: When switching between the plotting programs, you may need to 
	delete the class files from the old program and compile the new program to 
	avoid having class files with the same names from the two programs becoming 
	intermingled in the same directory.)

</emphasis>
</para>





</quote>




</section>
</section>
<section id="h31011">
<title>
<emphasis id="Another_DFT_example" effect="bold">

Another DFT example

</emphasis>


</title>




<para id="p1106">
This next example is designed to illustrate the following features of the DFT 
algorithm which don't generally apply to an FFT algorithm:

</para>





<list id="ul1013" list-type="bulleted">

	

<item id="li1092">
Ability to do spectral analysis on data of arbitrary lengths. 

<emphasis id="em1027" effect="italics">
(With 
	many FFT algorithms, the data length must be a power of two.)

</emphasis>
</item>


	

<item id="li1093">
Ability to zero in on an arbitrary range of frequencies and to ignore 
	all other frequencies. 

<emphasis id="em1028" effect="italics">
(Most FFT algorithms always compute the spectrum 
	at uniform frequency increments from zero to one unit less than the sampling 
	frequency.)

</emphasis>
</item>




</list>




<para id="p1107">
As mentioned earlier, the DFT algorithm is much more flexible while the FFT 
algorithm is much faster, particularly for large data lengths.

</para>





<section id="h41041">
<title>
Peaks merge at the folding frequency

</title>




<para id="p1108">
In addition to illustrating these fundamental aspects of the DFT algorithm, 
this example also illustrates how the mirror image peaks on either side of the 
folding frequency merge into a single larger peak as the data frequency 
approaches the folding frequency.

</para>





</section>
<section id="h41042">
<title>
The input parameters

</title>




<para id="p1109">
The input parameters are shown in 

<link id="a1157" target-id="Figure_10">

 Figure 10

</link>

. Note in particular the values 
for the following parameters:

</para>





<list id="ul1014" list-type="bulleted">

	

<item id="li1094">
Data length: 200

</item>


	

<item id="li1095">
Sample for zero time: 0

</item>


	

<item id="li1096">
Lower frequency bound: 0.4

</item>


	

<item id="li1097">
Upper frequency bound: 0.6

</item>




</list>





<table id="table1016" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1016">
<row id="tr1032">
<entry id="th1016">



<emphasis id="Figure_10" effect="bold">

Figure 10.

</emphasis>

 The input parameters.

</entry>



</row>
</thead>


<tbody id="tbody1016">
<row id="tr1033">
<entry id="td1016">

		

<code id="pre1015" display="block">Data length: 200
Sample for zero time: 0
Lower frequency bound: 0.4
Upper frequency bound: 0.6
Number spectra: 5
Frequencies
0.492
0.494
0.496
0.498
0.5
Amplitudes
90.0
90.0
90.0
90.0
90.0</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41043">
<title>
A different data length

</title>




<para id="p1110">
As you can see, the data length for this experiment is different from the 
data length of 400 used earlier. In addition, neither data length is a power of 
two.

</para>





</section>
<section id="h41044">
<title>
Computational frequency bounds

</title>




<para id="p1111">
As you can also see, the lower and upper frequency bounds are not 0.0 and 1.0 
as in the earlier cases. In this case, the frequency bounds describe a much 
narrower range centered on the folding frequency.

</para>





</section>
<section id="h41045">
<title>
Frequencies are close to the folding frequency

</title>




<para id="p1112">
Finally, the frequencies of each of the five sinusoids specified in 

<link id="a1158" target-id="Figure_10">

 Figure 10

</link>

 
is progressively closer to the folding frequency with the frequency of the fifth 
sinusoid being equal to the folding frequency.

</para>





</section>
<section id="h41046">
<title>
The spectral analysis output

</title>




<para id="p1113">
The output from the spectral analysis for each of the five sinusoids is shown 
in 

<link id="a1159" target-id="Figure_11">

 Figure 11

</link>

. 

<emphasis id="em1029" effect="italics">
(Another interesting view of the same results is shown later in 


<link id="a1160" target-id="Figure_14">

 Figure 14

</link>

.)

</emphasis>
</para>






<table id="table1017" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1017">
<row id="tr1034">
<entry id="th1017">



<emphasis id="Figure_11" effect="bold">

Figure 11.

</emphasis>

 Spectral analysis of five sinusoids.

</entry>



</row>
</thead>


<tbody id="tbody1017">
<row id="tr1035">
<entry id="td1017">




<media id="media1004" alt="missing image" display="block">
<image id="img1004" mime-type="image/jpeg" src="../../media/java1482a5.jpg" width="409" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





</section>
<section id="h41047">
<title>
Peaks are symmetrical about the folding frequency

</title>




<para id="p1114">
The spectral peaks shown in 

<link id="a1161" target-id="Figure_11">

 Figure 11

</link>

 are symmetrical about the folding 
frequency, which in turn is centered horizontally in each of the graphs. As you 
already know, the peaks are always symmetrical about the folding frequency due to 
the frequency folding at that frequency.

</para>





<para id="p1115">
The folding frequency is centered horizontally due to the way that I defined 
the lower and upper frequency bounds, and the way that I adjusted the plotting 
parameters.

</para>





</section>
<section id="h41048">
<title>
Peaks are well defined and wider than before

</title>




<para id="p1116">
The peaks are well defined because I computed the spectral energy at 200 
points across the specified frequency range from 0.4 to 0.6. Thus, the frequency 
bins at which I computed spectral energy were much narrower than before.

</para>





<para id="p1117">
The peaks are wider because I displayed a much smaller slice of the entire 
frequency spectrum in the same physical screen space.

</para>





</section>
<section id="h41049">
<title>
Peaks merge at the folding frequency

</title>




<para id="p1118">
As the frequency of each sinusoid approaches the folding frequency, the two 
mirror-image peaks corresponding to that sinusoid merge into a single peak with 
twice the height at the folding frequency. This agrees with what you saw in 


<link id="a1162" target-id="Figure_9">

 Figure 9

</link>

, but on a much more detailed basis.

</para>





<para id="p1119">
It would be difficult to perform this experiment using an FFT algorithm 
because of the inherent limitations built into the algorithm. The FFT algorithm 
sacrifices flexibility for speed.

</para>





</section>
<section id="h41050">
<title>
Implementing the DFT algorithm

</title>




<para id="p1120">
At this point, I will present and explain two different programs:

</para>





<list id="ul1015" list-type="bulleted">

	

<item id="li1098">
Dsp028 - Driver program for doing spectral analysis using a DFT 
	algorithm.

</item>


	

<item id="li1099">
ForwardRealToComplex01 - Class that implements the DFT algorithm.

</item>




</list>




<para id="p1121">
In addition, I will present, but will not explain the plotting program named 


<emphasis id="strong1086" effect="bold">
Graph03

</emphasis>
.

</para>





</section>
</section>
<section id="h31012">
<title>
<emphasis id="The_program_named_Dsp028" effect="bold">

The program named Dsp028

</emphasis>


</title>




<para id="p1122">
This driver program is similar in many respects to the program named 

<emphasis id="strong1087" effect="bold">
Dsp029

</emphasis>
 
that I explained earlier. It differs mainly in how it populates the array 
objects containing the data that is plotted by the plotting program.

</para>





<para id="p1123">
The program named 

<emphasis id="strong1088" effect="bold">
Dsp029

</emphasis>
 simply populates those array objects with five 
sinusoidal functions. The program named 

<emphasis id="strong1089" effect="bold">
Dsp028

</emphasis>
 also creates five sinusoidal 
functions. However, it passes those functions to a static method named 

<emphasis id="strong1090" effect="bold">
transform

</emphasis>
 
belonging to the 

<emphasis id="strong1091" effect="bold">
ForwardRealToComplex01

</emphasis>
 class to perform spectral analysis on 
those functions. The results of the spectral analysis are used to populate the 
five array objects whose contents are plotted by the plotting program.

</para>





<para id="p1124">
Because of the similarity of the two programs, my discussion of 

<emphasis id="strong1092" effect="bold">
Dsp028

</emphasis>
 will 
be much more brief than was my discussion of 

<emphasis id="strong1093" effect="bold">
Dsp029

</emphasis>
.

</para>





<section id="h41051">
<title>
Computes and displays the magnitude spectrum

</title>




<para id="p1125">
The program named 

<emphasis id="strong1094" effect="bold">
Dsp028

</emphasis>
 computes and displays the magnitude of the spectral 
content for up to five sinusoids having different frequencies and amplitudes.

</para>





<quote id="blockquote1009" display="block">

	

<para id="p1126">
<emphasis id="em1030" effect="italics">
(Future modules will discuss other aspects of spectral analysis such as 
	the complex spectrum, zero time, and the phase angle.)

</emphasis>
</para>





</quote>




</section>
<section id="h41052">
<title>
Input parameters

</title>




<para id="p1127">
The program gets input parameters from a file named 

<emphasis id="strong1095" effect="bold">
Dsp028.txt

</emphasis>
. If that file 
doesn't exist in the current directory, the program uses a set of default 
parameters. As with the program named 

<emphasis id="strong1096" effect="bold">
Dsp029

</emphasis>
, each parameter value must be 
stored as characters on a separate line in the file named 

<emphasis id="strong1097" effect="bold">
Dsp028.txt

</emphasis>
. The 
required parameters are shown in 

<link id="a1163" target-id="Figure_12">

 Figure 12

</link>

.

</para>






<table id="table1018" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1018">
<row id="tr1036">
<entry id="th1018">



<emphasis id="Figure_12" effect="bold">

Figure 12.

</emphasis>

 Required input parameters for Dsp028.

</entry>



</row>
</thead>


<tbody id="tbody1018">
<row id="tr1037">
<entry id="td1018">

		

<code id="pre1016" display="block">Data length as type int
Sample number representing zero time as type int
Lower frequency bound as type double
Upper frequency bound as type double
Number of spectra as type int.  Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1128">
Don't allow blank lines at the end of the data in the file.

</para>





<para id="p1129">
The number of values in each of the lists must match the value for the number 
of spectra.

</para>





</section>
<section id="h41053">
<title>
Specification of sinusoidal frequencies

</title>




<para id="p1130">
As before, each frequency value is specified as a 

<emphasis id="strong1098" effect="bold">
double

</emphasis>
 
value representing a fractional part of the sampling frequency. For example, a 
value of 0.5 specifies a frequency that is one-half the sampling frequency.

</para>





</section>
<section id="h41054">
<title>
Example contents for Dsp028.txt

</title>




<para id="p1131">
<link id="a1164" target-id="Figure_13">

 Figure 13

</link>

 shows the contents of the file named 

<emphasis id="strong1099" effect="bold">
Dsp028.txt

</emphasis>
 that represent the 
parameters shown in 

<link id="a1165" target-id="Figure_10">

 Figure 10

</link>

.

</para>





<table id="table1019" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1019">
<row id="tr1038">
<entry id="th1019">



<emphasis id="Figure_13" effect="bold">

Figure 13.

</emphasis>

 Contents of Dsp028.txt file.

</entry>



</row>
</thead>


<tbody id="tbody1019">
<row id="tr1039">
<entry id="td1019">

		

<code id="pre1017" display="block">200
0
0.4
0.6
5
0.492
0.494
0.496
0.498
0.5
90
90
90
90
90</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41055">
<title>
Performing the spectral analysis

</title>




<para id="p1132">
A static method named 

<emphasis id="strong1100" effect="bold">
transform

</emphasis>
 belonging to the class named


<emphasis id="strong1101" effect="bold">
ForwardRealToComplex01

</emphasis>
 is used to perform the actual spectral 
analysis. The method named 

<emphasis id="strong1102" effect="bold">
transform

</emphasis>
 does not implement an FFT 
algorithm. Rather, it is more general than, but much slower than an FFT 
algorithm.

</para>





</section>
<section id="h41056">
<title>
Will discuss the code in fragments

</title>




<para id="p1133">
As usual, I will discuss the code in fragments. A complete listing of the 
program is presented in 

<link id="a1166" target-id="Listing_19">

 Listing 19

</link>

 near the end of the module. Because of the 
similarity of 

<emphasis id="strong1103" effect="bold">
Dsp028

</emphasis>
 with 

<emphasis id="strong1104" effect="bold">
Dsp029

</emphasis>
 discussed 
earlier, the fragments for 

<emphasis id="strong1105" effect="bold">
Dsp028

</emphasis>
 will be much larger and will 
be explained in much less detail.

</para>





</section>
</section>
<section id="h31013">
<title>
<emphasis id="Beginning_of_the_class_named_Dsp028" effect="bold">

Beginning of the class named 
Dsp028

</emphasis>


</title>





<para id="p1134">
The class definition begins in 

<link id="a1167" target-id="Listing_8">

 Listing 8

</link>

. For reasons that you already 
understand, this class implements the interface named GraphIntfc01. 

</para>





<table id="table1020" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1020">
<row id="tr1040">



<entry id="th1020">
<emphasis id="Listing_8" effect="bold">

Listing 8.

</emphasis>

 Beginning of the class named Dsp028.

</entry>



</row>
</thead>


<tbody id="tbody1020">
<row id="tr1041">
<entry id="td1020">

		

<code id="pre1018" display="block">class Dsp028 implements GraphIntfc01{
  final double pi = Math.PI;//for simplification

  //Begin default parameters
  int len = 400;//data length
  //Sample that represents zero time.
  int zeroTime = 0;
  //Low and high frequency limits for the
  // spectral analysis.
  double lowF = 0.0;
  double highF = 1.0;
  int numberSpectra = 5;
  //Frequencies of the sinusoids
  double[] freq = {0.1,0.2,0.3,0.4,0.5};
  //Amplitudes of the sinusoids
  double[] amp = {60,70,80,90,100};
  //End default parameters</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1135">
The code in 

<link id="a1168" target-id="Listing_8">

 Listing 8

</link>

 defines a set of default parameter values that are used 
in the event that a file named 

<emphasis id="strong1106" effect="bold">
Dsp028.txt

</emphasis>
 does not exist in the 
current directory.

</para>





<section id="h41057">
<title>
Declare array variables

</title>




<para id="p1136">
The code in 

<link id="a1169" target-id="Listing_9">

 Listing 9

</link>

 declares several array variables that will be used to 
point to array objects whose purposes are explained in the comments.

</para>





<table id="table1021" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1021">
<row id="tr1042">



<entry id="th1021">
<emphasis id="Listing_9" effect="bold">

Listing 9.

</emphasis>

 Declare array variables.

</entry>



</row>
</thead>


<tbody id="tbody1021">
<row id="tr1043">
<entry id="td1021">

		

<code id="pre1019" display="block">  //Following arrays will contain data that is
  // input to the spectral analysis process.
  double[] data1;
  double[] data2;
  double[] data3;
  double[] data4;
  double[] data5;

  //Following arrays receive information back
  // from the spectral analysis that is not used
  // in this program.
  double[] real;
  double[] imag;
  double[] angle;

  //Following arrays receive the magnitude
  // spectral information back from the spectral
  // analysis process.
  double[] magnitude1;
  double[] magnitude2;
  double[] magnitude3;
  double[] magnitude4;
  double[] magnitude5;</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1137">
The constructor

</para>





<para id="p1138">
The constructor for the class begins in 

<link id="a1170" target-id="Listing_10">

 Listing 10

</link>

. The constructor begins by 
getting the parameters from a file named 

<emphasis id="strong1107" effect="bold">
Dsp028.txt

</emphasis>
. If that 
file doesn't exist in the current directory, default parameters are used.

</para>





<table id="table1022" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1022">
<row id="tr1044">



<entry id="th1022">
<emphasis id="Listing_10" effect="bold">

Listing 10.

</emphasis>

 Beginning of the constructor.

</entry>



</row>
</thead>


<tbody id="tbody1022">
<row id="tr1045">
<entry id="td1022">

		

<code id="pre1020" display="block">  public Dsp028(){//constructor

    if(new File("Dsp028.txt").exists()){
      getParameters();
    }//end if</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41058">
<title>
Always processes five sinusoids

</title>




<para id="p1139">
For simplicity, this program always processes five sinusoids, even if fewer 
than five were requested as the input parameter for 

<emphasis id="strong1108" effect="bold">
numberSpectra

</emphasis>
. 
In that case, the extra sinusoids are processed using default values and simply 
ignored when the results are plotted.

</para>





</section>
<section id="h41059">
<title>
Create the raw sinusoidal data

</title>




<para id="p1140">
The code in 

<link id="a1171" target-id="Listing_11">

 Listing 11

</link>

 instantiates array objects and creates the sinusoidal 
data upon which spectral analysis will be performed.

</para>





<table id="table1023" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1023">
<row id="tr1046">



<entry id="th1023">
<emphasis id="Listing_11" effect="bold">

Listing 11.

</emphasis>

 Create the raw sinusoidal data.

</entry>



</row>
</thead>


<tbody id="tbody1023">
<row id="tr1047">
<entry id="td1023">

		

<code id="pre1021" display="block">    //First create empty array objects.
    double[] data1 = new double[len];
    double[] data2 = new double[len];
    double[] data3 = new double[len];
    double[] data4 = new double[len];
    double[] data5 = new double[len];
    //Now populate the array objects
    for(int n = 0;n &lt; len;n++){
      data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
      data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
      data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
      data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
      data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
    }//end for loop</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41060">
<title>
Perform the spectral analysis

</title>




<para id="p1141">
The code in 

<link id="a1172" target-id="Listing_12">

 Listing 12

</link>

 creates array objects to receive the results and calls 
the static 

<emphasis id="strong1109" effect="bold">
transform

</emphasis>
 method of the 

<emphasis id="strong1110" effect="bold">

forwardRealToComplex01

</emphasis>
 class five times in succession to perform the 
spectral analysis on each of the five sinusoids.

</para>





<quote id="blockquote1010" display="block">

	

<para id="p1142">
<emphasis id="em1031" effect="italics">
(I will explain the transform method that performs the spectral 
	analysis shortly.)

</emphasis>
</para>





</quote>




<para id="p1143">
Only the magnitude data is displayed by this program. Therefore, the arrays 
that receive the other spectral analysis results from the transform method are 
discarded each time a new spectral analysis is performed.

</para>





<table id="table1024" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1024">
<row id="tr1048">



<entry id="th1024">
<emphasis id="Listing_12" effect="bold">

Listing 12.

</emphasis>

 Perform the spectral analysis.

</entry>



</row>
</thead>


<tbody id="tbody1024">
<row id="tr1049">
<entry id="td1024">

		

<code id="pre1022" display="block">    magnitude1 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data1,real,
      imag,angle,magnitude1,zeroTime,lowF,highF);

    magnitude2 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data2,real,
      imag,angle,magnitude2,zeroTime,lowF,highF);

    magnitude3 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data3,real,
      imag,angle,magnitude3,zeroTime,lowF,highF);

    magnitude4 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data4,real,
      imag,angle,magnitude4,zeroTime,lowF,highF);

    magnitude5 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data5,real,
      imag,angle,magnitude5,zeroTime,lowF,highF);
  }//end constructor</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41061">
<title>
The spectral magnitude results

</title>




<para id="p1144">
Note that the magnitude results are saved in the array objects referred to by


<emphasis id="strong1111" effect="bold">
magnitude1

</emphasis>
, 

<emphasis id="strong1112" effect="bold">
magnitude2

</emphasis>
, etc. This will be 
important later when I discuss the interface methods defined by 

<emphasis id="strong1113" effect="bold">
Dsp028

</emphasis>
.

</para>





</section>
<section id="h41062">
<title>
The end of the constructor

</title>




<para id="p1145">
<link id="a1173" target-id="Listing_12">

 Listing 12

</link>

 also signals the end of the constructor. When the constructor 
terminates, the object has been instantiated and populated with spectral 
analysis results for five sinusoids using the parameters specified by the file 
named 

<emphasis id="strong1114" effect="bold">
Dsp028.tx

</emphasis>
t.

</para>





</section>
<section id="h41063">
<title>
The getParameters method

</title>




<para id="p1146">
The getParameters method used in this program is the same as that used in


<emphasis id="strong1115" effect="bold">
Dsp029

</emphasis>
, so I won't discuss it further.

</para>





</section>
<section id="h41064">
<title>
The interface methods

</title>




<para id="p1147">
The 

<emphasis id="strong1116" effect="bold">
Dsp028

</emphasis>
 class must define the same six interface methods 
as the 

<emphasis id="strong1117" effect="bold">
Dsp029

</emphasis>
 class, which I discussed earlier. The only 
difference in the interface methods is the identification of the array objects 
from which the methods return data when the methods are called.

</para>





<para id="p1148">
The code in 

<link id="a1174" target-id="Listing_13">

 Listing 13

</link>

 is typical of the code for methods 

<emphasis id="strong1118" effect="bold">
f1

</emphasis>
 
through 

<emphasis id="strong1119" effect="bold">
f5

</emphasis>
. As you can see, these methods return the data 
stored in the magnitude arrays. These are the spectral analysis results that are 
plotted in 

<link id="a1175" target-id="Figure_9">

 Figure 9

</link>

, 


<link id="a1176" target-id="Figure_11">

 Figure 11

</link>

, and later in 


<link id="a1177" target-id="Figure_14">

 Figure 14

</link>

.

</para>





<table id="table1025" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1025">
<row id="tr1050">



<entry id="th1025">
<emphasis id="Listing_13" effect="bold">

Listing 13.

</emphasis>

 The method named f1.

</entry>



</row>
</thead>


<tbody id="tbody1025">
<row id="tr1051">
<entry id="td1025">

		

<code id="pre1023" display="block">  public double f1(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude1.length-1){
      return 0;
    }else{
      return magnitude1[index];
    }//end else
  }//end function</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
</section>
<section id="h31014">
<title>
<emphasis id="The_program_named_Graph03" effect="bold">

The program named Graph03

</emphasis>


</title>




<para id="p1149">
The plots in 

<link id="a1178" target-id="Figure_9">

 Figure 9

</link>

 and 

<link id="a1179" target-id="Figure_11">

 Figure 11

</link>

 were produced by entering the following 
at the command line prompt:

</para>





<code id="pre1024" display="block">java Graph03 Dsp028</code>




<para id="p1150">
The program named 

<emphasis id="strong1120" effect="bold">
Graph03

</emphasis>
 is very similar to the program 
named 

<emphasis id="strong1121" effect="bold">
Graph06

</emphasis>
 discussed earlier. In fact, the program named


<emphasis id="strong1122" effect="bold">
Graph06

</emphasis>
 can be used to produce very similar plots where the 
sample values are represented by vertical bars instead of being represented by 
connected dots. This results in the very interesting display shown in 

<link id="a1180" target-id="Figure_14">

 Figure 14

</link>

. 
Each of the vertical bars in 

<link id="a1181" target-id="Figure_14">

 Figure 14

</link>

 represents a computational frequency bin.


<emphasis id="em1032" effect="italics">
(Compare 

<link id="a1182" target-id="Figure_14">

 Figure 14

</link>

 with 

<link id="a1183" target-id="Figure_11">

 Figure 11

</link>

.)

</emphasis>
</para>







<table id="table1026" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1026">
<row id="tr1052">
<entry id="th1026">



<emphasis id="Figure_14" effect="bold">

Figure 14.

</emphasis>

 Output from Graph03.

</entry>



</row>
</thead>


<tbody id="tbody1026">
<row id="tr1053">
<entry id="td1026">




<media id="media1005" alt="missing image" display="block">
<image id="img1005" mime-type="image/jpeg" src="../../media/java1482a6.jpg" width="409" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<para id="p1151">
In any event, 

<emphasis id="strong1123" effect="bold">
Graph03

</emphasis>
 is so similar to 

<emphasis id="strong1124" effect="bold">
Graph06

</emphasis>
 
that I'm not going to discuss it further. A complete listing of the program 
named 

<emphasis id="strong1125" effect="bold">
Graph03

</emphasis>
 is provided in 

<link id="a1184" target-id="Listing_20">

 Listing 20

</link>

 near the end of the 
module.

</para>





</section>
<section id="h31015">
<title>
<emphasis id="The_transform_method_of_the_ForwardRealToComplex01_class" effect="bold">

The 
transform method of the ForwardRealToComplex01 class

</emphasis>


</title>




<para id="p1152">
That brings us to the heart of this module, which is the method that actually 
implements the DFT algorithm and performs the spectral analysis. This is a 
method named 

<emphasis id="strong1126" effect="bold">
transform

</emphasis>
, which is a static method of the class 
named 

<emphasis id="strong1127" effect="bold">
ForwardRealToComplex01

</emphasis>
. You saw this method being called 
five times in the code in 

<link id="a1185" target-id="Listing_12">

 Listing 12

</link>

.

</para>





<section id="h41065">
<title>
Will discuss in fragments

</title>




<para id="p1153">
As usual, I will discuss this method in fragments. A complete listing of the 
class is presented in 

<link id="a1186" target-id="Listing_21">

 Listing 21

</link>

 near the end of the module.

</para>





<para id="p1154">
The 

<emphasis id="strong1128" effect="bold">
transform

</emphasis>
 method is a rather straightforward implementation of the 
concepts that I explained in the earlier module titled


<link id="a1187" url="http://cnx.org/contents/9fdb2951-7fca-47a1-83fc-d3d3d15d6ff1/Java1478-Fun-with-Java-How-and">


Fun with Java, How and Why Spectral Analysis Works

</link>

. If you have not done so 
already, I strongly urge you go to back and study that module at this time. You 
need to understand those concepts in order for the code in the 

<emphasis id="strong1129" effect="bold">
transform

</emphasis>
 method 
to make sense.

</para>





</section>
<section id="h41066">
<title>
A brief description

</title>




<para id="p1155">
For those of you who don't have the time to go back and study that module in 
detail, a brief description of the DFT algorithm follows.

</para>





<para id="p1156">
Using a notation that I described in the earlier module, the expressions that 
you must evaluate to determine the frequency spectral content of a target time 
series at a frequency F are shown in 

<link id="a1188" target-id="Figure_15">

 Figure 15

</link>

.

</para>





<table id="table1027" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1027">
<row id="tr1054">
<entry id="th1027">



<emphasis id="Figure_15" effect="bold">

Figure 15.

</emphasis>

  Spectral transform expressions.

</entry>



</row>
</thead>


<tbody id="tbody1027">
<row id="tr1055">
<entry id="td1027">

		

<code id="pre1025" display="block">Real(F) = S(n=0,N-1)[x(n)*cos(2Pi*F*n)]
Imag(F) = S(n=0,N-1)[x(n)*sin(2Pi*F*n)]

ComplexAmplitude(F) = Real(F) - j*Imag(F)
Power(F) = Real(F)*Real(F) + Imag(F)*Imag(F)
Amplitude(F) = SqRt(Power(F))</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41067">
<title>
What does this really mean?

</title>




<para id="p1157">
Before you panic, let me explain what this means in layman's terms. Given a 
time series, x(n), you can determine if that time series contains a cosine 
component or a sine component at a given frequency, F, by doing the following: 

</para>





<list id="ul1016" list-type="bulleted">

	

<item id="li1100">
Create one new time series, cos(n), which is a cosine function with the 
	frequency F.

</item>


	

<item id="li1101">
Create another new time series, sin(n), which is a sine function with 
	the frequency F.

</item>


	

<item id="li1102">
Multiply x(n) by cos(n) on a point by point basis and compute the sum of 
	the products. Save this value, calling it Real(F). This is an estimate of 
	the amplitude, if any, of the cosine component with the matching frequency 
	contained in the time series x(n).

</item>


	

<item id="li1103">
Multiply x(n) by sin(n) on a point by point basis and compute the sum of 
	the products. Save this value, calling it Imag(f). This is an estimate of 
	the amplitude, if any, of the sine component with the matching frequency 
	contained in the time series x(n).

</item>


	

<item id="li1104">
Consider the values for Real(F) and Imag(F) to be the real and imaginary 
	parts of a complex number.

</item>


	

<item id="li1105">
Consider the sum of the squares of the real and imaginary parts to 
	represent the power at that frequency in the time series.

</item>


	

<item id="li1106">
Consider the square root of the power to be the amplitude at that 
	frequency in the time series. 

<emphasis id="em1033" effect="italics">
(This is the value that is plotted in 

<link id="a1189" target-id="Figure_9">

 Figure 9

</link>

, 
	

<link id="a1190" target-id="Figure_11">

 Figure 11

</link>

, and 
	

<link id="a1191" target-id="Figure_14">

 Figure 14

</link>

.)

</emphasis>
</item>




</list>




</section>
<section id="h41068">
<title>
Compute the complex energy at each frequency

</title>




<para id="p1158">
That is all there is to it. For 
each frequency of interest, you can use this process to compute a complex 
number, Real(F)-jImag(F), which represents the complex energy corresponding to 
that frequency in the target time series.

</para>





<para id="p1159">
Similarly, you can compute the sum of the squares of the real and imaginary 
parts and consider that to be a measure of the power at that frequency in the 
time series. The square root of the power is the amplitude of the energy at that 
frequency.

</para>





</section>
<section id="h41069">
<title>
Nested for loops

</title>




<para id="p1160">
Normally we are interested in more than one frequency, so we would repeat the 
above procedure once for each frequency of interest. This suggests the use of 
nested 

<emphasis id="strong1130" effect="bold">
for

</emphasis>
 loops in the algorithm. The outer loop specifies the frequency of 
interest. The inner loop computes the sum of the products at a particular 
frequency.

</para>





</section>
<section id="h41070">
<title>
Description of the transform method

</title>




<para id="p1161">
The static method named 

<emphasis id="strong1131" effect="bold">
transform

</emphasis>
 performs a real to complex Fourier 
transform. The method does not implement the FFT algorithm. Rather, it 
implements a straightforward sampled data version of the continuous Fourier 
transform defined using integral calculus.

<emphasis id="em1034" effect="italics">
 (See 

<emphasis id="strong1132" effect="bold">
ForwardRealToComplexFFT01

</emphasis>
 for an 
FFT algorithm.)

</emphasis>
</para>





</section>
<section id="h41071">
<title>
The return values

</title>




<para id="p1162">
The method returns the following:

</para>





<list id="ul1017" list-type="bulleted">

	

<item id="li1107">
Real part of the spectral analysis result

</item>


	

<item id="li1108">
Imaginary part of the spectral analysis result

</item>


	

<item id="li1109">
Magnitude of the spectral analysis result

</item>


	

<item id="li1110">
Phase angle of the spectral analysis result in degrees

</item>




</list>




</section>
<section id="h41072">
<title>
The transform method parameters

</title>




<para id="p1163">
The method parameters are: 

</para>





<list id="ul1018" list-type="bulleted">

	

<item id="li1111">
double[] data - incoming real data 

</item>


	

<item id="li1112">
double[] realOut - outgoing real data 

</item>


	

<item id="li1113">
double[] imagOut - outgoing imaginary data 

</item>


	

<item id="li1114">
double[] angleOut - outgoing phase angle in degrees 

</item>


	

<item id="li1115">
double[] magnitude - outgoing amplitude spectrum 

</item>


	

<item id="li1116">
int zero - the index of the incoming data sample that represents zero 
	time 

</item>


	

<item id="li1117">
double lowF - low frequency limit for computation as a fraction of 
	sampling frequency 

</item>


	

<item id="li1118">
double highF - high frequency limit for computation as a fraction of 
	sampling frequency 

</item>




</list>




</section>
<section id="h41073">
<title>
Frequency increment, magnitude spectrum, and number of returned values

</title>




<para id="p1164">
The computational frequency increment is the difference between the high and 
low limits divided by the length of the magnitude array.

</para>





<para id="p1165">
The magnitude or amplitude is computed as the square root of the sum of the 
squares of the real and imaginary parts. This value is divided by the incoming 
data length, which is given by 

<emphasis id="strong1133" effect="bold">
data.length

</emphasis>
.

</para>





<para id="p1166">
The method returns a number of points in the frequency domain equal to the 
incoming data length regardless of the high and low frequency limits.

</para>





</section>
</section>
<section id="h31016">
<title>
<emphasis id="The_beginning_of_the_transform_method" effect="bold">

The beginning of the transform method

</emphasis>


</title>




<para id="p1167">
The class and the 

<emphasis id="strong1134" effect="bold">
transform

</emphasis>
 method begin in 

<link id="a1192" target-id="Listing_14">

 Listing 14

</link>

. The code in 

<link id="a1193" target-id="Listing_14">

 Listing 14

</link>


 is described above.

</para>






<table id="table1028" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1028">
<row id="tr1056">



<entry id="th1028">
<emphasis id="Listing_14" effect="bold">

Listing 14.

</emphasis>

 The beginning of the transform method.

</entry>



</row>
</thead>


<tbody id="tbody1028">
<row id="tr1057">
<entry id="td1028">

		

<code id="pre1026" display="block">public class ForwardRealToComplex01{

  public static void transform(
                              double[] data,
                              double[] realOut,
                              double[] imagOut,
                              double[] angleOut,
                              double[] magnitude,
                              int zero,
                              double lowF,
                              double highF){
    double pi = Math.PI;//for convenience
    int dataLen = data.length;
    double delF = (highF-lowF)/data.length;</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41074">
<title>
The remainder of the method and the class

</title>




<para id="p1168">
The nested 

<emphasis id="strong1135" effect="bold">
for

</emphasis>
 loops discussed above are included in the code shown in 


<link id="a1194" target-id="Listing_15">

 Listing 15

</link>

. As suggested above, the outer loop iterates on frequency while the 
inner loop iterates on the values that make up the incoming samples. The code in 
the inner loop computes the sum of the product of the time series and the 
reference cosine and sine functions.

</para>





<table id="table1029" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1029">
<row id="tr1058">



<entry id="th1029">
<emphasis id="Listing_15" effect="bold">

Listing 15.

</emphasis>

 The remainder of the method and the class.

</entry>



</row>
</thead>


<tbody id="tbody1029">
<row id="tr1059">
<entry id="td1029">

		

<code id="pre1027" display="block">    //Outer loop iterates on frequency
    // values.
    for(int i=0; i &lt; dataLen;i++){
      double freq = lowF + i*delF;
      double real = 0.0;
      double imag = 0.0;
      double ang = 0.0;
      //Inner loop iterates on time-
      // series points.
      for(int j=0; j &lt; dataLen; j++){
        real += data[j]*Math.cos(
                             2*pi*freq*(j-zero));
        imag += data[j]*Math.sin(
                             2*pi*freq*(j-zero));
      }//end inner loop
      
      realOut[i] = real/dataLen;
      imagOut[i] = imag/dataLen;
      magnitude[i] = (Math.sqrt(
                 real*real + imag*imag))/dataLen;

      //Calculate and return the phase
      // angle in degrees.
      if(imag == 0.0 &amp;&amp; real == 0.0){ang = 0.0;}
      else{ang = Math.atan(imag/real)*180.0/pi;}

      if(real &lt; 0.0 &amp;&amp; imag == 0.0){ang = 180.0;}
      else if(real &lt; 0.0 &amp;&amp; imag == -0.0){
                                   ang = -180.0;}
      else if(real &lt; 0.0 &amp;&amp; imag &gt; 0.0){
                                   ang += 180.0;}
      else if(real &lt; 0.0 &amp;&amp; imag &lt; 0.0){
                                  ang += -180.0;}
      angleOut[i] = ang;
    }//end outer loop
  }//end transform method

}//end class ForwardRealToComplex01</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41075">
<title>
Store results in output array objects

</title>




<para id="p1169">
At the end of each iteration of the inner loop, code in the outer loop 
deposits the real, imaginary, magnitude, and phase angle results in the output 
array objects. To accomplish this, the code:

</para>





<list id="ul1019" list-type="bulleted">

	

<item id="li1119">
Computes the magnitude or amplitude as the square root of the sum of the 
	squares of the real and imaginary parts.

</item>


	

<item id="li1120">
Performs some trigonometry operations to determine the phase angle in 
	degrees based on the values of the real and imaginary parts.

</item>




</list>




</section>
<section id="h41076">
<title>
Now you know about the DFT algorithm

</title>




<para id="p1170">
Now you know about the DFT algorithm. You also know about some of the 
fundamental aspects of spectral analysis involving the sampling frequency and 
the folding frequency.

</para>





<para id="p1171">
Future modules will discuss other aspects of spectral analysis including:

</para>





<list id="ul1020" list-type="bulleted">

	

<item id="li1121">
Frequency resolution versus data length.

</item>


	

<item id="li1122">
The relationship between the phase angle and delays in the time domain.

</item>


	

<item id="li1123">
The reversible nature of the Fourier transform involving both forward 
	and inverse Fourier transforms.

</item>




</list>




</section>
</section>
</section>
<section id="h21003">
<title>
<emphasis id="Spectral_analysis_using_an_FFT_algorithm" effect="bold">

Spectral analysis using 
an FFT algorithm

</emphasis>


</title>




<para id="p1172">
At this point, I will present a similar spectral analysis program that uses 
an FFT algorithm. I will present this program with very little discussion. I am 
providing it in this module for two primary purposes:

</para>





<list id="ul1021" list-type="bulleted">

	

<item id="li1124">
To allow you to experiment and appreciate the flexibility of the DFT as 
	compared to the FFT.

</item>


	

<item id="li1125">
To allow you to experiment and appreciate the speed of the FFT as 
	compared to the DFT.

</item>




</list>




<section id="h31017">
<title>
<emphasis id="The_program_named_Dsp030" effect="bold">

The program named Dsp030

</emphasis>


</title>




<para id="p1173">
The program named 

<emphasis id="strong1136" effect="bold">
Dsp030

</emphasis>
 is very similar to 

<emphasis id="strong1137" effect="bold">
Dsp028

</emphasis>
. 
The major differences are:

</para>





<list id="ul1022" list-type="bulleted">

	

<item id="li1126">
Because it uses an FFT algorithm, 

<emphasis id="strong1138" effect="bold">
Dsp030

</emphasis>
 is much less 
	flexible than 

<emphasis id="strong1139" effect="bold">
Dsp028

</emphasis>
, particularly with respect to data 
	length and selection of the frequencies of interest.

</item>


	

<item id="li1127">
Because it uses an FFT algorithm, 

<emphasis id="strong1140" effect="bold">
Dsp030

</emphasis>
 is much faster 
	than 

<emphasis id="strong1141" effect="bold">
Dsp028

</emphasis>
, particularly when used to perform spectral 
	analysis on long data lengths.

</item>




</list>




<para id="p1174">
A complete listing of 

<emphasis id="strong1142" effect="bold">
Dsp030

</emphasis>
 is provided in 

<link id="a1195" target-id="Listing_22">

 Listing 22

</link>

.

</para>





<section id="h41077">
<title>
Description of the program named Dsp030

</title>




<para id="p1175">
This program uses an FFT algorithm to compute and display the magnitude of 
the spectral content for up to five sinusoids having different frequencies and 
amplitudes. 

<emphasis id="em1035" effect="italics">
(See the program named 

<emphasis id="strong1143" effect="bold">
Dsp028

</emphasis>
 for a program 
that does not use an FFT algorithm.)

</emphasis>
</para>





</section>
<section id="h41078">
<title>
The input parameters

</title>




<para id="p1176">
The program gets input parameters from a file named 

<emphasis id="strong1144" effect="bold">
Dsp030.txt

</emphasis>
. 
If that file doesn't exist in the current directory, the program uses a set of 
default parameters.

</para>





<para id="p1177">
Each parameter value must be stored as characters on a separate line in the 
file named 

<emphasis id="strong1145" effect="bold">
Dsp030.txt

</emphasis>
. The required input parameters are shown 
in 

<link id="a1196" target-id="Figure_16">

 Figure 16

</link>

. 

<emphasis id="em1036" effect="italics">
(Contrast this with the required input parameters for 

<emphasis id="strong1146" effect="bold">

Dsp028

</emphasis>
 shown in 

<link id="a1197" target-id="Figure_12">

 Figure 12

</link>

.)

</emphasis>
</para>






<table id="table1030" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1030">
<row id="tr1060">
<entry id="th1030">



<emphasis id="Figure_16" effect="bold">

Figure 16.

</emphasis>

 Required input parameters for Dsp030.

</entry>



</row>
</thead>


<tbody id="tbody1030">
<row id="tr1061">
<entry id="td1030">

		

<code id="pre1028" display="block">Data length as type int (must be a power of 2)
Number of spectra as type int. Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1178">
Note that in contrast with 

<link id="a1198" target-id="Figure_12">

 Figure 12

</link>

, the required input parameters for


<emphasis id="strong1147" effect="bold">
Dsp030

</emphasis>
 do not include the sample number representing zero time, 
the lower frequency bound for computation of the spectra, and the upper 
frequency bound for computation of the spectra.

</para>





<quote id="blockquote1011" display="block">

	

<para id="p1179">
<emphasis id="em1037" effect="italics">
(The computational frequency range cannot be specified for the FFT 
	algorithm. It always computes the spectra from zero to one unit less than 
	the sampling frequency.)

</emphasis>
</para>





</quote>




</section>
<section id="h41079">
<title>
Restrictions on the data length

</title>




<para id="p1180">
Note also that the data length must always be a power of two. Otherwise, the 
FFT algorithm will fail to run properly.

</para>





<quote id="blockquote1012" display="block">

	

<para id="p1181">
<emphasis id="em1038" effect="italics">
(This restriction is an important contributor to the speed achieved 
	by the FFT algorithm.)

</emphasis>
</para>





</quote>




</section>
<section id="h41080">
<title>
The sinusoidal frequency values

</title>




<para id="p1182">
As with 

<emphasis id="strong1148" effect="bold">
Dsp028

</emphasis>
, the number of values in each of the lists 
must match the value for the number of spectra.

</para>





<para id="p1183">
All frequency values are specified as a 

<emphasis id="strong1149" effect="bold">
double

</emphasis>
 representing 
a fractional part of the sampling frequency.

</para>





<para id="p1184">
<link id="a1199" target-id="Figure_17">

 Figure 17

</link>

 shows the parameters used to produce the spectral analysis plots 
shown later in 

<link id="a1200" target-id="Figure_18">

 Figure 18

</link>

.

</para>





<quote id="blockquote1013" display="block">

	

<para id="p1185">
<emphasis id="em1039" effect="italics">
(Note that the data length is a power of two as required by the FFT.)

</emphasis>
</para>





</quote>




<table id="table1031" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1031">
<row id="tr1062">
<entry id="th1031">



<emphasis id="Figure_17" effect="bold">

Figure 17.

</emphasis>

 Example input parameters.

</entry>



</row>
</thead>


<tbody id="tbody1031">
<row id="tr1063">
<entry id="td1031">

		

<code id="pre1029" display="block">256
5
0.1
0.2
0.3
0.5
0.005
90
90
90
90
90</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41081">
<title>
The plotting program

</title>




<para id="p1186">
The plotting program that is used to plot the output data from this program 
requires that the program implement 

<emphasis id="strong1150" effect="bold">
GraphIntfc01

</emphasis>
. For example, 
the plotting program named 

<emphasis id="strong1151" effect="bold">
Graph03

</emphasis>
 can be used to plot the data 
produced by this program. This requires that you enter the following at the 
command line prompt after everything is compiled:

</para>





<code id="pre1030" display="block">java Graph03 Dsp030</code>




<para id="p1187">
The plotting program named 

<emphasis id="strong1152" effect="bold">
Graph06

</emphasis>
 can also be used to plot 
the data produced by this program, requiring that you enter the following at the 
command line prompt:

</para>





<code id="pre1031" display="block">java Graph06 Dsp030</code>




</section>
<section id="h41082">
<title>
The transform method

</title>




<para id="p1188">
A static method named 

<emphasis id="strong1153" effect="bold">
transform

</emphasis>
 belonging to the class named


<emphasis id="strong1154" effect="bold">
ForwardRealToComplexFFT01

</emphasis>
 is used to perform the actual 
spectral analysis. The method named 

<emphasis id="strong1155" effect="bold">
transform

</emphasis>
 implements an FFT 
algorithm. As mentioned above, the FFT algorithm requires that the data length 
be a power of two. This method will be discussed very briefly later.

</para>





</section>
<section id="h41083">
<title>
A sample FFT spectral analysis

</title>




<para id="p1189">
The output produced by running 

<emphasis id="strong1156" effect="bold">
Dsp030

</emphasis>
 using the input 
parameters shown in 

<link id="a1201" target-id="Figure_17">

 Figure 17

</link>

 is shown in 

<link id="a1202" target-id="Figure_18">

 Figure 18

</link>

.

</para>






<table id="table1032" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1032">
<row id="tr1064">
<entry id="th1032">



<emphasis id="Figure_18" effect="bold">

Figure 18.

</emphasis>

 FFT of five sinusoids.

</entry>



</row>
</thead>


<tbody id="tbody1032">
<row id="tr1065">
<entry id="td1032">




<media id="media1006" alt="missing image" display="block">
<image id="img1006" mime-type="image/jpeg" src="../../media/java1482a7.jpg" width="409" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





</section>
<section id="h41084">
<title>
Nothing special here

</title>




<para id="p1190">
There is nothing special about this particular spectral analysis. I presented 
it here to illustrate the use of the FFT algorithm for spectral analysis. You 
should be able to produce the same results using the same program and the same 
parameters.

</para>





</section>
<section id="h41085">
<title>
A matching DFT spectral analysis

</title>




<para id="p1191">
<link id="a1203" target-id="Figure_19">

 Figure 19

</link>

 shows the parameters required for the program named 

<emphasis id="strong1157" effect="bold">
Dsp028

</emphasis>
 
to perform a DFT spectral analysis producing the same results as those produced 
by the FFT analysis shown in 

<link id="a1204" target-id="Figure_18">

 Figure 18

</link>

. Note that the data length has been set 
to 256 and the computational frequency range extends from zero to the sampling 
frequency in 

<link id="a1205" target-id="Figure_19">

 Figure 19

</link>

.

</para>






<table id="table1033" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1033">
<row id="tr1066">
<entry id="th1033">



<emphasis id="Figure_19" effect="bold">

Figure 19.

</emphasis>

 Parameters for A matching DFT spectral analysis.

</entry>



</row>
</thead>


<tbody id="tbody1033">
<row id="tr1067">
<entry id="td1033">

		

<code id="pre1032" display="block">Data length: 256
Sample for zero time: 0
Lower frequency bound: 0.0
Upper frequency bound: 1.0
Number spectra: 5
Frequencies
0.1
0.2
0.3
0.5
0.0050
Amplitudes
90.0
90.0
90.0
90.0
90.0</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1192">
The matching DFT output

</para>






<para id="p1193">
The DFT output produced by running Dsp028 with the parameters shown in 

<link id="a1206" target-id="Figure_19">

 Figure 19

</link>

 
is shown in 

<link id="a1207" target-id="Figure_20">

 Figure 20

</link>

.

</para>








<table id="table1034" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1034">
<row id="tr1068">
<entry id="th1034">



<emphasis id="Figure_20" effect="bold">

Figure 20.

</emphasis>

 DFT of five sinusoids.

</entry>



</row>
</thead>


<tbody id="tbody1034">
<row id="tr1069">
<entry id="td1034">




<media id="media1007" alt="missing image" display="block">
<image id="img1007" mime-type="image/jpeg" src="../../media/java1482a8.jpg" width="409" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<para id="p1194">
Hopefully you noticed that 

<link id="a1208" target-id="Figure_20">

 Figure 20

</link>

 looks almost exactly like 

<link id="a1209" target-id="Figure_18">

 Figure 18

</link>

. 
This is how it should be. The DFT algorithm and the FFT algorithm are simply two 
different algorithms for computing the same results. However, the DFT algorithm 
is much more flexible than the FFT algorithm while the FFT algorithm is much 
faster than the DFT algorithm.

</para>





</section>
<section id="h41086">
<title>
Repeat these two experiments

</title>




<para id="p1195">
I recommend that you repeat these two experiments several times increasing 
the data length to a higher power of two each time you run the experiments.

</para>





<para id="p1196">
On my machine, the DFT algorithm used by 

<emphasis id="strong1158" effect="bold">
Dsp028

</emphasis>
 becomes 
noticeably slow by the time the data length reaches 2048 samples. However, the 
FFT algorithm used by 

<emphasis id="strong1159" effect="bold">
Dsp030

</emphasis>
 is still reasonably responsive at 
a data length of 131,072 samples.

</para>





<quote id="blockquote1014" display="block">

	

<para id="p1197">
<emphasis id="em1040" effect="italics">
(Performing the DFT on five input samples each having a data length 
	of 131,072 samples would require an intolerably long time on my machine.)

</emphasis>
</para>





</quote>




<para id="p1198">
If what you need is speed for long data lengths, the FFT is your best 
approach. On the other hand, if you need more flexibility than the FFT provides 
and the data length is not too long, then the DFT may be your best approach.

</para>





</section>
</section>
<section id="h31018">
<title>
<emphasis id="The_ForwardRealToComplexFFT01_class" effect="bold">

The ForwardRealToComplexFFT01 
class

</emphasis>


</title>




<para id="p1199">
The 

<emphasis id="strong1160" effect="bold">
ForwardRealToComplexFFT01

</emphasis>
 class containing the method 
that implements the FFT algorithm is provided in 

<link id="a1210" target-id="Listing_23">

 Listing 23

</link>

 near the end of this 
module. 

</para>





<para id="p1200">
The FFT algorithm is based on some very complicated signal processing 
concepts. I'm not going to explain how this algorithm works in this module 
because I haven't given you the proper background for understanding it. I plan 
to explain additional signal processing concepts in future modules that will 
prepare you to understand how the FFT algorithm works.

</para>





<para id="p1201">
Fortunately, you don't have to understand the mechanics of the FFT algorithm 
works to be able to use it.

</para>







</section>
</section>
</section>
<section id="h11004">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the programs

</emphasis>


</title>





<para id="p1202">
I encourage you to copy, compile, and run the programs provided in this 
module. Experiment with them, making changes and observing the results of your 
changes.

</para>





<para id="p1203">
I suggest that you begin by compiling and running the following files to 
confirm that everything is working correctly on your machine before attempting 
to compile and run the spectral analysis programs:

</para>





<list id="ul1023" list-type="bulleted">

	

<item id="li1128">
Dsp029.java

</item>


	

<item id="li1129">
GraphIntfc01.java

</item>


	

<item id="li1130">
Graph06.java

</item>




</list>




<para id="p1204">
Make sure that you create an appropriate file named 

<emphasis id="strong1161" effect="bold">
Dsp029.txt

</emphasis>
, 
as described in 

<link id="a1211" target-id="Figure_2">

 Figure 2

</link>

. You should be able to reproduce my results if 
everything is working correctly.

</para>





<para id="p1205">
Once you confirm that things are working correctly, copy, compile, and run 
the spectral analysis programs. Experiment with the parameters and try to 
understand the result of making changes to the parameters. Confirm the 
flexibility of the DFT algorithm and the speed of the FFT algorithm.

</para>





</section>
<section id="h11005">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1206">
In this module I have provided and explained programs that illustrate the 
impact of sampling and the Nyquist folding frequency.

</para>





<para id="p1207">
I have also provided and explained several different programs used for 
performing spectral analysis. The first program was a very general program that 
implements a 

<emphasis id="em1041" effect="italics">
Discrete Fourier Transform (DFT)

</emphasis>
 algorithm. I explained 
this program in detail.

</para>





<para id="p1208">
The second program was a less general, but much faster program that 
implements a 

<emphasis id="em1042" effect="italics">
Fast Fourier Transform (FFT)

</emphasis>
 algorithm. I will defer an 
explanation of this program until a future module. I provided it in this module 
so that you can use it and compare it with the DFT program in terms of speed and 
flexibility.

</para>





</section>
<section id="h11006">
<title>
<emphasis id="Whats_next" effect="bold">

What's next?

</emphasis>


</title>




<para id="p1209">
Future modules will discuss other aspects of spectral analysis including:

</para>





<list id="ul1024" list-type="bulleted">

	

<item id="li1131">
Frequency resolution versus data length.

</item>


	

<item id="li1132">
The relationship between the phase angle and delays in the time domain.

</item>


	

<item id="li1133">
The reversible nature of the Fourier transform involving both forward 
	and inverse Fourier transforms.

</item>


	

<item id="li1134">
Additional material aimed towards an understanding of the signal 
	processing concepts behind the FFT algorithm.

</item>




</list>




</section>
<section id="h11007">
<title>
<emphasis id="Complete_program_listings" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1210">
Complete listings of all the programs discussed in this module follow.

</para>





<table id="table1035" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1035">
<row id="tr1070">



<entry id="th1035">
<emphasis id="Listing_16" effect="bold">

Listing 16.

</emphasis>

 Dsp029.java.

</entry>



</row>
</thead>


<tbody id="tbody1035">
<row id="tr1071">
<entry id="td1035">

		

<code id="pre1033" display="block">/* File Dsp029.java
Copyright 2004, R.G.Baldwin
Rev 5/6/04

Generates and displays up to five sinusoids
having different frequencies and amplitudes. Very
useful for providing a visual illustration of the
way in which frequencies above half the sampling
frequency fold back down into the area bounded
by zero and half the sampling frequency (the
Nyquist folding frequency).

Gets input parameters from a file named
Dsp029.txt.  If that file doesn't exist in the
current directory, the program uses a set of
default parameters.

Each parameter value must be stored as characters
on a separate line in the file named Dsp029.txt.
The required parameters are as follows:

Data length as type int
Number of sinusoids as type int.  Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.

The number of values in each of the lists must
match the value for the number of spectra.

Note:  All frequency values are specified as a
double representing a fractional part of the
sampling frequency.

Here is a set of sample parameter values.  Don't
allow blank lines at the end of the data in the
file.

400.0
5
0.1
0.9
1.1
1.9
2.1
90
90
90
90
90

The plotting program that is used to plot the
output data from this program requires that the
program implement GraphIntfc01.  For example,
the plotting program named Graph06 can be used
to plot the data produced by this program.  When
it is used, the usage information is:

java Graph06 Dsp029

Tested using SDK 1.4.2 under WinXP.
************************************************/
import java.util.*;
import java.io.*;

class Dsp029 implements GraphIntfc01{
  final double pi = Math.PI;//for simplification

  //Begin default parameters
  int len = 400;//data length
  int numberSinusoids = 5;
  //Frequencies of the sinusoids
  double[] freq = {0.1,0.25,0.5,0.75,0.9};
  //Amplitudes of the sinusoids
  double[] amp = {75,75,75,75,75};
  //End default parameters

  //Following arrays will be populated with
  // sinusoidal data to be plotted
  double[] data1 = new double[len];
  double[] data2 = new double[len];
  double[] data3 = new double[len];
  double[] data4 = new double[len];
  double[] data5 = new double[len];

  public Dsp029(){//constructor

    //Get the parameters from a file named
    // Dsp029.txt.  Use the default parameters
    // if the file doesn't exist in the current
    // directory.
    if(new File("Dsp029.txt").exists()){
      getParameters();
    }//end if

    //Note that this program always generates
    // five sinusoids, even if fewer than five
    // were requested as the input parameter
    // for numberSinusoids.  In that case, the
    // extras are generated using default values
    // and simply ignored when the results are
    // plotted.

    //Create the raw data.  Note that the
    // argument for a sinusoid at half the
    // sampling frequency would be (2*pi*x*0.5).
    // This would represent one half cycle or pi
    // radians per sample.
    for(int n = 0;n &lt; len;n++){
      data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
      data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
      data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
      data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
      data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
    }//end for loop

  }//end constructor
  //-------------------------------------------//

  //This method gets processing parameters from
  // a file named Dsp029.txt and stores those
  // parameters in instance variables belonging
  // to the object of type Dsp029.
  void getParameters(){
    int cnt = 0;
    //Temporary holding area for strings.  Allow
    // space for a few blank lines at the end
    // of the data in the file.
    String[] data = new String[20];
    try{
      //Open an input stream.
      BufferedReader inData =
               new BufferedReader(new FileReader(
                                  "Dsp029.txt"));
      //Read and save the strings from each of
      // the lines in the file.  Be careful to
      // avoid having blank lines at the end,
      // which may cause an ArrayIndexOutOfBounds
      // exception to be thrown.
      while((data[cnt] =
                     inData.readLine()) != null){
        cnt++;
      }//end while
      inData.close();
    }catch(IOException e){}

    //Move the parameter values from the
    // temporary holding array into the instance
    // variables, converting from characters to
    // numeric values in the process.
    cnt = 0;
    len = (int)Double.parseDouble(data[cnt++]);
    numberSinusoids = (int)Double.parseDouble(
                                    data[cnt++]);
    for(int fCnt = 0;fCnt &lt; numberSinusoids;
                                         fCnt++){
      freq[fCnt] = Double.parseDouble(
                                    data[cnt++]);
    }//end for loop

    for(int aCnt = 0;aCnt &lt; numberSinusoids;
                                         aCnt++){
      amp[aCnt] = Double.parseDouble(
                                    data[cnt++]);
    }//end for loop

    //Print parameter values.
    System.out.println();
    System.out.println("Data length: " + len);
    System.out.println(
         "Number sinusoids: " + numberSinusoids);
    System.out.println("Frequencies");
    for(cnt = 0;cnt &lt; numberSinusoids;cnt++){
      System.out.println(freq[cnt]);
    }//end for loop
    System.out.println("Amplitudes");
    for(cnt = 0;cnt &lt; numberSinusoids;cnt++){
      System.out.println(amp[cnt]);
    }//end for loop

  }//end getParameters
  //-------------------------------------------//
  //The following six methods are required by the
  // interface named GraphIntfc01.  The plotting
  // program pulls the data values to be plotted
  // by calling these methods.
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return numberSinusoids;
  }//end getNmbr
  //-------------------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; data1.length-1){
      return 0;
    }else{
      return data1[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f2(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; data2.length-1){
      return 0;
    }else{
      return data2[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f3(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; data3.length-1){
      return 0;
    }else{
      return data3[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f4(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; data4.length-1){
      return 0;
    }else{
      return data4[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f5(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; data5.length-1){
      return 0;
    }else{
      return data5[index];
    }//end else
  }//end function
  //-------------------------------------------//

}//end class Dsp029</code>




</entry>
</row>
</tbody>


</tgroup>
</table>





<table id="table1036" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1036">
<row id="tr1072">



<entry id="th1036">
<emphasis id="Listing_17" effect="bold">

Listing 17.

</emphasis>

 GraphIntfc01.java.

</entry>



</row>
</thead>


<tbody id="tbody1036">
<row id="tr1073">
<entry id="td1036">

		

<code id="pre1034" display="block">/* File GraphIntfc01.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

This interface must be implemented by classes
whose objects produce data to be plotted by
programs such as Graph03 and Graph06.

Tested using SDK 1.4.2 under WinXP.
************************************************/

public interface GraphIntfc01{
  public int getNmbr();
  public double f1(double x);
  public double f2(double x);
  public double f3(double x);
  public double f4(double x);
  public double f5(double x);
}//end GraphIntfc01</code>




</entry>
</row>
</tbody>


</tgroup>
</table>





<table id="table1037" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1037">
<row id="tr1074">



<entry id="th1037">
<emphasis id="Listing_18" effect="bold">

Listing 18.

</emphasis>

 Graph06.java.

</entry>



</row>
</thead>


<tbody id="tbody1037">
<row id="tr1075">
<entry id="td1037">

		

<code id="pre1035" display="block">/* File Graph06.java
Copyright 2002, R.G.Baldwin
Revised 5/15/04

Very similar to Graph03, except that
each point is displayed as a
rectangle, centered on the sample.
Can be used to explain integration
through summation of the sample values.

Note:  This program requires access to
the interface named GraphIntfc01.

This is a plotting program.  It is
designed to access a class file, which
implements GraphIntfc01, and to plot up
to five functions defined in that class
file.  The plotting surface is divided
into the required number of equally
sized plotting areas, and one function
is plotted on cartesian coordinates in
each area.

The methods corresponding to the
functions are named f1, f2, f3, f4,
and f5.

The class containing the functions must
also define a method named
getNmbr(), which takes no parameters
and returns the number of functions to
be plotted.  If this method returns a
value greater than 5, a
NoSuchMethodException will be thrown.

Note that the constructor for the class
that implements GraphIntfc01 must not
require any parameters due to the
use of the newInstance method of the
Class class to instantiate an object
of that class.

If the number of functions is less
than 5, then the absent method names
must begin with f5 and work down toward
f1.  For example, if the number of
functions is 3, then the program will
expect to call methods named f1, f2,
and f3.  It is OK for the absent
methods to be defined in the class.
They simply won't be called.

The plotting areas have alternating
white and gray backgrounds to make them
easy to separate visually.

All curves are plotted in black.  A
cartesian coordinate system with axes,
tic marks, and labels is drawn in red
in each plotting area.

The cartesian coordinate system in each
plotting area has the same horizontal
and vertical scale, as well as the
same tic marks and labels on the axes.

The labels displayed on the axes,
correspond to the values of the extreme
edges of the plotting area.

The program also compiles a sample
class named junk, which contains five
methods and the method named getNmbr.
This makes it easy to compile and test
this program in a stand-alone mode.

At runtime, the name of the class that
implements the GraphIntfc01 interface
must be provided as a command-line
parameter.  If this parameter is
missing, the program instantiates an
object from the internal class named
junk and plots the data provided by
that class.  Thus, you can test the
program by running it with no
command-line parameter.

This program provides the following
text fields for user input, along with
a button labeled Graph.  This allows
the user to adjust the parameters and
replot the graph as many times with as
many plotting scales as needed:

xMin = minimum x-axis value
xMax = maximum x-axis value
yMin = minimum y-axis value
yMax = maximum y-axis value
xTicInt = tic interval on x-axis
yTicInt = tic interval on y-axis
xCalcInc = calculation interval

The user can modify any of these
parameters and then click the Graph
button to cause the five functions
to be re-plotted according to the
new parameters.

Whenever the Graph button is clicked,
the event handler instantiates a new
object of the class that implements
the GraphIntfc01 interface.  Depending
on the nature of that class, this may
be redundant in some cases.  However,
it is useful in those cases where it
is necessary to refresh the values of
instance variables defined in the
class (such as a counter, for example).

Tested using JDK 1.4.0 under Win 2000.

This program uses constants that were
first defined in the Color class of
v1.4.0.  Therefore, the program
requires v1.4.0 or later to compile and
run correctly.
**************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph06{
  public static void main(
          String[] args)
          throws NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{
    if(args.length == 1){
      //pass command-line paramater
      new GUI(args[0]);
    }else{
      //no command-line parameter given
      new GUI(null);
    }//end else
  }// end main
}//end class Graph06 definition
//===================================//

class GUI extends JFrame
             implements ActionListener{

  //Define plotting parameters and
  // their default values.
  double xMin = 0.0;
  double xMax = 400.0;
  double yMin = -100.0;
  double yMax = 100.0;

  //Tic mark intervals
  double xTicInt = 20.0;
  double yTicInt = 20.0;

  //Tic mark lengths.  If too small
  // on x-axis, a default value is
  // used later.
  double xTicLen = (yMax-yMin)/50;
  double yTicLen = (xMax-xMin)/50;

  //Calculation interval along x-axis
  double xCalcInc = 1.0;

  //Text fields for plotting parameters
  JTextField xMinTxt =
             new JTextField("" + xMin);
  JTextField xMaxTxt =
             new JTextField("" + xMax);
  JTextField yMinTxt =
             new JTextField("" + yMin);
  JTextField yMaxTxt =
             new JTextField("" + yMax);
  JTextField xTicIntTxt =
          new JTextField("" + xTicInt);
  JTextField yTicIntTxt =
          new JTextField("" + yTicInt);
  JTextField xCalcIncTxt =
         new JTextField("" + xCalcInc);

  //Panels to contain a label and a
  // text field
  JPanel pan0 = new JPanel();
  JPanel pan1 = new JPanel();
  JPanel pan2 = new JPanel();
  JPanel pan3 = new JPanel();
  JPanel pan4 = new JPanel();
  JPanel pan5 = new JPanel();
  JPanel pan6 = new JPanel();

  //Misc instance variables
  int frmWidth = 408;
  int frmHeight = 430;
  int width;
  int height;
  int number;
  GraphIntfc01 data;
  String args = null;

  //Plots are drawn on the canvases
  // in this array.
  Canvas[] canvases;

  //Constructor
  GUI(String args)throws
                NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{

    if(args != null){
      //Save for use later in the
      // ActionEvent handler
      this.args = args;
      //Instantiate an object of the
      // target class using the String
      // name of the class.
      data = (GraphIntfc01)
                   Class.forName(args).
                         newInstance();
    }else{
      //Instantiate an object of the
      // test class named junk.
      data = new junk();
    }//end else

    //Create array to hold correct
    // number of Canvas objects.
    canvases =
            new Canvas[data.getNmbr()];

    //Throw exception if number of
    // functions is greater than 5.
    number = data.getNmbr();
    if(number &gt; 5){
      throw new NoSuchMethodException(
                "Too many functions.  "
                  + "Only 5 allowed.");
    }//end if

    //Create the control panel and
    // give it a border for cosmetics.
    JPanel ctlPnl = new JPanel();
    ctlPnl.setLayout(//?rows x 4 cols
                  new GridLayout(0,4));
    ctlPnl.setBorder(
                   new EtchedBorder());

    //Button for replotting the graph
    JButton graphBtn =
                  new JButton("Graph");
    graphBtn.addActionListener(this);

    //Populate each panel with a label
    // and a text field.  Will place
    // these panels in a grid on the
    // control panel later.
    pan0.add(new JLabel("xMin"));
    pan0.add(xMinTxt);

    pan1.add(new JLabel("xMax"));
    pan1.add(xMaxTxt);

    pan2.add(new JLabel("yMin"));
    pan2.add(yMinTxt);

    pan3.add(new JLabel("yMax"));
    pan3.add(yMaxTxt);

    pan4.add(new JLabel("xTicInt"));
    pan4.add(xTicIntTxt);

    pan5.add(new JLabel("yTicInt"));
    pan5.add(yTicIntTxt);

    pan6.add(new JLabel("xCalcInc"));
    pan6.add(xCalcIncTxt);

    //Add the populated panels and the
    // button to the control panel with
    // a grid layout.
    ctlPnl.add(pan0);
    ctlPnl.add(pan1);
    ctlPnl.add(pan2);
    ctlPnl.add(pan3);
    ctlPnl.add(pan4);
    ctlPnl.add(pan5);
    ctlPnl.add(pan6);
    ctlPnl.add(graphBtn);

    //Create a panel to contain the
    // Canvas objects.  They will be
    // displayed in a one-column grid.
    JPanel canvasPanel = new JPanel();
    canvasPanel.setLayout(//?rows,1 col
                  new GridLayout(0,1));

    //Create a custom Canvas object for
    // each function to be plotted and
    // add them to the one-column grid.
    // Make background colors alternate
    // between white and gray.
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      switch(cnt){
        case 0 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 1 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 2 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 3 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 4 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].
            setBackground(Color.WHITE);
      }//end switch
      //Add the object to the grid.
      canvasPanel.add(canvases[cnt]);
    }//end for loop

    //Add the sub-assemblies to the
    // frame.  Set its location, size,
    // and title, and make it visible.
    getContentPane().
                   add(ctlPnl,"South");
    getContentPane().
             add(canvasPanel,"Center");

    setBounds(0,0,frmWidth,frmHeight);

    if(args == null){
      setTitle("Graph06, " +
                 "Copyright 2002, " +
                 "Richard G. Baldwin");
    }else{
      setTitle("Graph06/" + args +
                 " Copyright 2002, " +
                 "R. G. Baldwin");
    }//end else

    setVisible(true);

    //Set to exit on X-button click
    setDefaultCloseOperation(
                        EXIT_ON_CLOSE);

    //Guarantee a repaint on startup.
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end constructor
  //---------------------------------//

  //This event handler is registered
  // on the JButton to cause the
  // functions to be replotted.
  public void actionPerformed(
                      ActionEvent evt){
    //Re-instantiate the object that
    // provides the data
    try{
      if(args != null){
        data = (GraphIntfc01)Class.
           forName(args).newInstance();
      }else{
        data = new junk();
      }//end else
    }catch(Exception e){
      //Known to be safe at this point.
      // Otherwise would have aborted
      // earlier.
    }//end catch

    //Set plotting parameters using
    // data from the text fields.
    xMin = Double.parseDouble(
                    xMinTxt.getText());
    xMax = Double.parseDouble(
                    xMaxTxt.getText());
    yMin = Double.parseDouble(
                    yMinTxt.getText());
    yMax = Double.parseDouble(
                    yMaxTxt.getText());
    xTicInt = Double.parseDouble(
                 xTicIntTxt.getText());
    yTicInt = Double.parseDouble(
                 yTicIntTxt.getText());
    xCalcInc = Double.parseDouble(
                xCalcIncTxt.getText());

    //Calculate new values for the
    // length of the tic marks on the
    // axes.  If too small on x-axis,
    // a default value is used later.
    xTicLen = (yMax-yMin)/50;
    yTicLen = (xMax-xMin)/50;

    //Repaint the plotting areas
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end actionPerformed
  //---------------------------------//


//This is an inner class, which is used
// to override the paint method on the
// plotting surface.
class MyCanvas extends Canvas{
  int cnt;//object number
  //Factors to convert from double
  // values to integer pixel locations.
  double xScale;
  double yScale;

  MyCanvas(int cnt){//save obj number
    this.cnt = cnt;
  }//end constructor

  //Override the paint method
  public void paint(Graphics g){
    //Get and save the size of the
    // plotting surface
    width = canvases[0].getWidth();
    height = canvases[0].getHeight();

    //Calculate the scale factors
    xScale = width/(xMax-xMin);
    yScale = height/(yMax-yMin);

    //Set the origin based on the
    // minimum values in x and y
    g.translate((int)((0-xMin)*xScale),
               (int)((0-yMin)*yScale));
    drawAxes(g);//Draw the axes
    g.setColor(Color.BLACK);

    //Get initial data values
    double xVal = xMin;
    int oldX = getTheX(xVal);
    int oldY = 0;
    //Use the Canvas obj number to
    // determine which method to
    // call to get the value for y.
    switch(cnt){
      case 0 :
        oldY = getTheY(data.f1(xVal));
        break;
      case 1 :
        oldY = getTheY(data.f2(xVal));
        break;
      case 2 :
        oldY = getTheY(data.f3(xVal));
        break;
      case 3 :
        oldY = getTheY(data.f4(xVal));
        break;
      case 4 :
        oldY = getTheY(data.f5(xVal));
    }//end switch

    //Now loop and plot the points
    while(xVal &lt; xMax){
      int yVal = 0;
      //Get next data value.  Use the
      // Canvas obj number to
      // determine which method to
      // call to get the value for y.
      switch(cnt){
        case 0 :
          yVal =
                getTheY(data.f1(xVal));
          break;
        case 1 :
          yVal =
                getTheY(data.f2(xVal));
          break;
        case 2 :
          yVal =
                getTheY(data.f3(xVal));
          break;
        case 3 :
          yVal =
                getTheY(data.f4(xVal));
          break;
        case 4 :
          yVal =
                getTheY(data.f5(xVal));
      }//end switch1


      //Convert the x-value to an int
      // and draw the next horizontal
      // line segment

      int x = getTheX(xVal+xCalcInc/2);
      g.drawLine(oldX,yVal,x,yVal);

      //Draw a vertical line at the
      // old x-value
      int yZero = getTheY(0);
      g.drawLine(oldX,yZero,oldX,yVal);

      //Draw a vertical line at the
      // new y-value
      g.drawLine(x,yZero,x,yVal);

      //Increment along the x-axis
      xVal += xCalcInc;

      //Save end point to use as start
      // point for next line segment.
      oldX = x;
      oldY = yVal;
    }//end while loop

  }//end overridden paint method
  //---------------------------------//

  //Method to draw axes with tic marks
  // and labels in the color RED
  void drawAxes(Graphics g){
    g.setColor(Color.RED);

    //Lable left x-axis and bottom
    // y-axis.  These are the easy
    // ones.  Separate the labels from
    // the ends of the tic marks by
    // two pixels.
    g.drawString("" + (int)xMin,
                 getTheX(xMin),
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMin,
                  getTheX(yTicLen/2)+2,
                        getTheY(yMin));

    //Label the right x-axis and the
    // top y-axis.  These are the hard
    // ones because the position must
    // be adjusted by the font size and
    // the number of characters.
    //Get the width of the string for
    // right end of x-axis and the
    // height of the string for top of
    // y-axis
    //Create a string that is an
    // integer representation of the
    // label for the right end of the
    // x-axis.  Then get a character
    // array that represents the
    // string.
    int xMaxInt = (int)xMax;
    String xMaxStr = "" + xMaxInt;
    char[] array = xMaxStr.
                         toCharArray();

    //Get a FontMetrics object that can
    // be used to get the size of the
    // string in pixels.
    FontMetrics fontMetrics =
                    g.getFontMetrics();
    //Get a bounding rectangle for the
    // string
    Rectangle2D r2d =
           fontMetrics.getStringBounds(
               array,0,array.length,g);
    //Get the width and the height of
    // the bounding rectangle.  The
    // width is the width of the label
    // at the right end of the
    // x-axis.  The height applies to
    // all the labels, but is needed
    // specifically for the label at
    // the top end of the y-axis.
    int labWidth =
                 (int)(r2d.getWidth());
    int labHeight =
                (int)(r2d.getHeight());

    //Label the positive x-axis and the
    // positive y-axis using the width
    // and height from above to
    // position the labels.  These
    // labels apply to the very ends of
    // the axes at the edge of the
    // plotting surface.
    g.drawString("" + (int)xMax,
                getTheX(xMax)-labWidth,
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMax,
              getTheX(yTicLen/2)+2,
              getTheY(yMax)+labHeight);

    //Draw the axes
    g.drawLine(getTheX(xMin),
                         getTheY(0.0),
                         getTheX(xMax),
                         getTheY(0.0));

    g.drawLine(getTheX(0.0),
                        getTheY(yMin),
                        getTheX(0.0),
                        getTheY(yMax));

    //Draw the tic marks on axes
    xTics(g);
    yTics(g);
  }//end drawAxes

  //---------------------------------//

  //Method to draw tic marks on x-axis
  void xTics(Graphics g){
    double xDoub = 0;
    int x = 0;

    //Get the ends of the tic marks.
    int topEnd = getTheY(xTicLen/2);
    int bottomEnd =
                   getTheY(-xTicLen/2);

    //If the vertical size of the
    // plotting area is small, the
    // calculated tic size may be too
    // small.  In that case, set it to
    // 10 pixels.
    if(topEnd &lt; 5){
      topEnd = 5;
      bottomEnd = -5;
    }//end if

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive x-axis
    // moving to the right from zero.
    while(xDoub &lt; xMax){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub += xTicInt;
    }//end while

    //Now do the negative x-axis moving
    // to the left from zero
    xDoub = 0;
    while(xDoub &gt; xMin){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub -= xTicInt;
    }//end while

  }//end xTics
  //---------------------------------//

  //Method to draw tic marks on y-axis
  void yTics(Graphics g){
    double yDoub = 0;
    int y = 0;
    int rightEnd = getTheX(yTicLen/2);
    int leftEnd = getTheX(-yTicLen/2);

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive y-axis
    // moving up from zero.
    while(yDoub &lt; yMax){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub += yTicInt;
    }//end while

    //Now do the negative y-axis moving
    // down from zero.
    yDoub = 0;
    while(yDoub &gt; yMin){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub -= yTicInt;
    }//end while

  }//end yTics

  //---------------------------------//

  //This method translates and scales
  // a double y value to plot properly
  // in the integer coordinate system.
  // In addition to scaling, it causes
  // the positive direction of the
  // y-axis to be from bottom to top.
  int getTheY(double y){
    double yDoub = (yMax+yMin)-y;
    int yInt = (int)(yDoub*yScale);
    return yInt;
  }//end getTheY
  //---------------------------------//

  //This method scales a double x value
  // to plot properly in the integer
  // coordinate system.
  int getTheX(double x){
    return (int)(x*xScale);
  }//end getTheX
  //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI
//===================================//

//Sample test class.  Required for
// compilation and stand-alone
// testing.
class junk implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 4;
  }//end getNmbr

  public double f1(double x){
    return (x*x*x)/200.0;
  }//end f1

  public double f2(double x){
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    return (x*x)/200.0;
  }//end f3

  public double f4(double x){
    return 50*Math.cos(x/10.0);
  }//end f4

  public double f5(double x){
    return 100*Math.sin(x/20.0);
  }//end f5

}//end sample class junk</code>




</entry>
</row>
</tbody>


</tgroup>
</table>





<table id="table1038" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1038">
<row id="tr1076">



<entry id="th1038">
<emphasis id="Listing_19" effect="bold">

Listing 19.

</emphasis>

 Dsp028.java.

</entry>



</row>
</thead>


<tbody id="tbody1038">
<row id="tr1077">
<entry id="td1038">

		

<code id="pre1036" display="block">/* File Dsp028.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

Computes and displays the magnitude of the
spectral content for up to five sinusoids having
different frequencies and amplitudes.

Gets input parameters from a file named
Dsp028.txt.  If that file doesn't exist in the
current directory, the program uses a set of
default parameters.

Each parameter value must be stored as characters
on a separate line in the file named Dsp028.txt.
The required parameters are as follows:

Data length as type int
Sample number representing zero time as type int
Lower frequency bound as type double (See note)
Upper frequency bound as type double
Number of spectra as type int.  Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.

The number of values in each of the lists must
match the value for the number of spectra.

Note:  All frequency values are specified as a
double representing a fractional part of the
sampling frequency.  For example, a value of 0.5
specifies a frequency that is half the sampling
frequency.

Here is a set of sample parameter values.  Don't
allow blank lines at the end of the data in the
file.

400
0
0.0
1.0
5
0.1
0.2
0.3
0.4
0.45
60
70
80
90
100

The plotting program that is used to plot the
output data from this program requires that the
program implement GraphIntfc01.  For example,
the plotting program named Graph03 can be used
to plot the data produced by this program.  When
it is used, the usage information is:

java Graph03 Dsp028

A static method named transform belonging to the
class named ForwardRealToComplex01 is used to
perform the actual spectral analysis.  The
method named transform does not implement an FFT
algorithm.  Rather, it is more general than, but
much slower than an FFT algorithm.  (See the
program named Dsp030 for the use of an FFT
algorithm.)

Tested using SDK 1.4.2 under WinXP.
************************************************/
import java.util.*;
import java.io.*;

class Dsp028 implements GraphIntfc01{
  final double pi = Math.PI;//for simplification

  //Begin default parameters
  int len = 400;//data length
  //Sample that represents zero time.
  int zeroTime = 0;
  //Low and high frequency limits for the
  // spectral analysis.
  double lowF = 0.0;
  double highF = 1.0;
  int numberSpectra = 5;
  //Frequencies of the sinusoids
  double[] freq = {0.1,0.2,0.3,0.4,0.5};
  //Amplitudes of the sinusoids
  double[] amp = {60,70,80,90,100};
  //End default parameters

  //Following arrays will contain data that is
  // input to the spectral analysis process.
  double[] data1;
  double[] data2;
  double[] data3;
  double[] data4;
  double[] data5;

  //Following arrays receive information back
  // from the spectral analysis that is not used
  // in this program.
  double[] real;
  double[] imag;
  double[] angle;

  //Following arrays receive the magnitude
  // spectral information back from the spectral
  // analysis process.
  double[] magnitude1;
  double[] magnitude2;
  double[] magnitude3;
  double[] magnitude4;
  double[] magnitude5;

  public Dsp028(){//constructor

    //Get the parameters from a file named
    // Dsp028.txt.  Use the default parameters
    // if the file doesn't exist in the current
    // directory.
    if(new File("Dsp028.txt").exists()){
      getParameters();
    }//end if

    //Note that this program always processes
    // five sinusoids, even if fewer than five
    // were requested as the input parameter
    // for numberSpectra.  In that case, the
    // extras are processed using default values
    // and simply ignored when the results are
    // plotted.

    //Create the raw data.  Note that the
    // argument for a sinusoid at half the
    // sampling frequency would be (2*pi*x*0.5).
    // This would represent one half cycle or pi
    // radians per sample.
    //First create empty array objects.
    double[] data1 = new double[len];
    double[] data2 = new double[len];
    double[] data3 = new double[len];
    double[] data4 = new double[len];
    double[] data5 = new double[len];
    //Now populate the array objects
    for(int n = 0;n &lt; len;n++){
      data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
      data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
      data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
      data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
      data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
    }//end for loop

    //Compute magnitude spectra of the raw data
    // and save it in output arrays.  Note that
    // the real, imag, and angle arrays are not
    // used later, so they are discarded each
    // time a new spectral analysis is performed.
    magnitude1 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data1,real,
      imag,angle,magnitude1,zeroTime,lowF,highF);

    magnitude2 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data2,real,
      imag,angle,magnitude2,zeroTime,lowF,highF);

    magnitude3 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data3,real,
      imag,angle,magnitude3,zeroTime,lowF,highF);

    magnitude4 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data4,real,
      imag,angle,magnitude4,zeroTime,lowF,highF);

    magnitude5 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplex01.transform(data5,real,
      imag,angle,magnitude5,zeroTime,lowF,highF);
  }//end constructor
  //-------------------------------------------//

  //This method gets processing parameters from
  // a file named Dsp028.txt and stores those
  // parameters in instance variables belonging
  // to the object of type Dsp028.
  void getParameters(){
    int cnt = 0;
    //Temporary holding area for strings.  Allow
    // space for a few blank lines at the end
    // of the data in the file.
    String[] data = new String[20];
    try{
      //Open an input stream.
      BufferedReader inData =
               new BufferedReader(new FileReader(
                                  "Dsp028.txt"));
      //Read and save the strings from each of
      // the lines in the file.  Be careful to
      // avoid having blank lines at the end,
      // which may cause an ArrayIndexOutOfBounds
      // exception to be thrown.
      while((data[cnt] =
                     inData.readLine()) != null){
        cnt++;
      }//end while
      inData.close();
    }catch(IOException e){}

    //Move the parameter values from the
    // temporary holding array into the instance
    // variables, converting from characters to
    // numeric values in the process.
    cnt = 0;
    len = (int)Double.parseDouble(data[cnt++]);
    zeroTime = (int)Double.parseDouble(
                                    data[cnt++]);
    lowF = Double.parseDouble(data[cnt++]);
    highF = Double.parseDouble(data[cnt++]);
    numberSpectra = (int)Double.parseDouble(
                                    data[cnt++]);
    for(int fCnt = 0;fCnt &lt; numberSpectra;
                                         fCnt++){
      freq[fCnt] = Double.parseDouble(
                                    data[cnt++]);
    }//end for loop
    for(int aCnt = 0;aCnt &lt; numberSpectra;
                                         aCnt++){
      amp[aCnt] = Double.parseDouble(
                                    data[cnt++]);
    }//end for loop

    //Print parameter values.
    System.out.println();
    System.out.println("Data length: " + len);
    System.out.println(
            "Sample for zero time: " + zeroTime);
    System.out.println(
               "Lower frequency bound: " + lowF);
    System.out.println(
              "Upper frequency bound: " + highF);
    System.out.println(
             "Number spectra: " + numberSpectra);
    System.out.println("Frequencies");
    for(cnt = 0;cnt &lt; numberSpectra;cnt++){
      System.out.println(freq[cnt]);
    }//end for loop
    System.out.println("Amplitudes");
    for(cnt = 0;cnt &lt; numberSpectra;cnt++){
      System.out.println(amp[cnt]);
    }//end for loop

  }//end getParameters
  //-------------------------------------------//
  //The following six methods are required by the
  // interface named GraphIntfc01.  The plotting
  // program pulls the data values to be plotted
  // by calling these methods.
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return numberSpectra;
  }//end getNmbr
  //-------------------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude1.length-1){
      return 0;
    }else{
      return magnitude1[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f2(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude2.length-1){
      return 0;
    }else{
      return magnitude2[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f3(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude3.length-1){
      return 0;
    }else{
      return magnitude3[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f4(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude4.length-1){
      return 0;
    }else{
      return magnitude4[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f5(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude5.length-1){
      return 0;
    }else{
      return magnitude5[index];
    }//end else
  }//end function
  //-------------------------------------------//

}//end class Dsp028
</code>




</entry>
</row>
</tbody>


</tgroup>
</table>





<table id="table1039" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1039">
<row id="tr1078">



<entry id="th1039">
<emphasis id="Listing_20" effect="bold">

Listing 20.

</emphasis>

 Graph03.java.

</entry>



</row>
</thead>


<tbody id="tbody1039">
<row id="tr1079">
<entry id="td1039">

		

<code id="pre1037" display="block">/* File Graph03.java
Copyright 2002, R.G.Baldwin

This program is very similar to Graph01
except that it has been modified to
allow the user to manually resize and
replot the frame.

Note:  This program requires access to
the interface named GraphIntfc01.

This is a plotting program.  It is
designed to access a class file, which
implements GraphIntfc01, and to plot up
to five functions defined in that class
file.  The plotting surface is divided
into the required number of equally
sized plotting areas, and one function
is plotted on cartesian coordinates in
each area.

The methods corresponding to the
functions are named f1, f2, f3, f4,
and f5.

The class containing the functions must
also define a method named
getNmbr(), which takes no parameters
and returns the number of functions to
be plotted.  If this method returns a
value greater than 5, a
NoSuchMethodException will be thrown.

Note that the constructor for the class
that implements GraphIntfc01 must not
require any parameters due to the
use of the newInstance method of the
Class class to instantiate an object
of that class.

If the number of functions is less
than 5, then the absent method names
must begin with f5 and work down toward
f1.  For example, if the number of
functions is 3, then the program will
expect to call methods named f1, f2,
and f3.  It is OK for the absent
methods to be defined in the class.
They simply won't be called.

The plotting areas have alternating
white and gray backgrounds to make them
easy to separate visually.

All curves are plotted in black.  A
cartesian coordinate system with axes,
tic marks, and labels is drawn in red
in each plotting area.

The cartesian coordinate system in each
plotting area has the same horizontal
and vertical scale, as well as the
same tic marks and labels on the axes.

The labels displayed on the axes,
correspond to the values of the extreme
edges of the plotting area.

The program also compiles a sample
class named junk, which contains five
methods and the method named getNmbr.
This makes it easy to compile and test
this program in a stand-alone mode.

At runtime, the name of the class that
implements the GraphIntfc01 interface
must be provided as a command-line
parameter.  If this parameter is
missing, the program instantiates an
object from the internal class named
junk and plots the data provided by
that class.  Thus, you can test the
program by running it with no
command-line parameter.

This program provides the following
text fields for user input, along with
a button labeled Graph.  This allows
the user to adjust the parameters and
replot the graph as many times with as
many plotting scales as needed:

xMin = minimum x-axis value
xMax = maximum x-axis value
yMin = minimum y-axis value
yMax = maximum y-axis value
xTicInt = tic interval on x-axis
yTicInt = tic interval on y-axis
xCalcInc = calculation interval

The user can modify any of these
parameters and then click the Graph
button to cause the five functions
to be re-plotted according to the
new parameters.

Whenever the Graph button is clicked,
the event handler instantiates a new
object of the class that implements
the GraphIntfc01 interface.  Depending
on the nature of that class, this may
be redundant in some cases.  However,
it is useful in those cases where it
is necessary to refresh the values of
instance variables defined in the
class (such as a counter, for example).

Tested using JDK 1.4.0 under Win 2000.

This program uses constants that were
first defined in the Color class of
v1.4.0.  Therefore, the program
requires v1.4.0 or later to compile and
run correctly.
**************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph03{
  public static void main(
          String[] args)
          throws NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{
    if(args.length == 1){
      //pass command-line paramater
      new GUI(args[0]);
    }else{
      //no command-line parameter given
      new GUI(null);
    }//end else
  }// end main
}//end class Graph03 definition
//===================================//

class GUI extends JFrame
             implements ActionListener{

  //Define plotting parameters and
  // their default values.
  double xMin = 0.0;
  double xMax = 400.0;
  double yMin = -100.0;
  double yMax = 100.0;

  //Tic mark intervals
  double xTicInt = 20.0;
  double yTicInt = 20.0;

  //Tic mark lengths.  If too small
  // on x-axis, a default value is
  // used later.
  double xTicLen = (yMax-yMin)/50;
  double yTicLen = (xMax-xMin)/50;

  //Calculation interval along x-axis
  double xCalcInc = 1.0;

  //Text fields for plotting parameters
  JTextField xMinTxt =
             new JTextField("" + xMin);
  JTextField xMaxTxt =
             new JTextField("" + xMax);
  JTextField yMinTxt =
             new JTextField("" + yMin);
  JTextField yMaxTxt =
             new JTextField("" + yMax);
  JTextField xTicIntTxt =
          new JTextField("" + xTicInt);
  JTextField yTicIntTxt =
          new JTextField("" + yTicInt);
  JTextField xCalcIncTxt =
         new JTextField("" + xCalcInc);

  //Panels to contain a label and a
  // text field
  JPanel pan0 = new JPanel();
  JPanel pan1 = new JPanel();
  JPanel pan2 = new JPanel();
  JPanel pan3 = new JPanel();
  JPanel pan4 = new JPanel();
  JPanel pan5 = new JPanel();
  JPanel pan6 = new JPanel();

  //Misc instance variables
  int frmWidth = 408;
  int frmHeight = 430;
  int width;
  int height;
  int number;
  GraphIntfc01 data;
  String args = null;

  //Plots are drawn on the canvases
  // in this array.
  Canvas[] canvases;

  //Constructor
  GUI(String args)throws
                NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{

    if(args != null){
      //Save for use later in the
      // ActionEvent handler
      this.args = args;
      //Instantiate an object of the
      // target class using the String
      // name of the class.
      data = (GraphIntfc01)
                   Class.forName(args).
                         newInstance();
    }else{
      //Instantiate an object of the
      // test class named junk.
      data = new junk();
    }//end else

    //Create array to hold correct
    // number of Canvas objects.
    canvases =
            new Canvas[data.getNmbr()];

    //Throw exception if number of
    // functions is greater than 5.
    number = data.getNmbr();
    if(number &gt; 5){
      throw new NoSuchMethodException(
                "Too many functions.  "
                  + "Only 5 allowed.");
    }//end if

    //Create the control panel and
    // give it a border for cosmetics.
    JPanel ctlPnl = new JPanel();
    ctlPnl.setLayout(//?rows x 4 cols
                  new GridLayout(0,4));
    ctlPnl.setBorder(
                   new EtchedBorder());

    //Button for replotting the graph
    JButton graphBtn =
                  new JButton("Graph");
    graphBtn.addActionListener(this);

    //Populate each panel with a label
    // and a text field.  Will place
    // these panels in a grid on the
    // control panel later.
    pan0.add(new JLabel("xMin"));
    pan0.add(xMinTxt);

    pan1.add(new JLabel("xMax"));
    pan1.add(xMaxTxt);

    pan2.add(new JLabel("yMin"));
    pan2.add(yMinTxt);

    pan3.add(new JLabel("yMax"));
    pan3.add(yMaxTxt);

    pan4.add(new JLabel("xTicInt"));
    pan4.add(xTicIntTxt);

    pan5.add(new JLabel("yTicInt"));
    pan5.add(yTicIntTxt);

    pan6.add(new JLabel("xCalcInc"));
    pan6.add(xCalcIncTxt);

    //Add the populated panels and the
    // button to the control panel with
    // a grid layout.
    ctlPnl.add(pan0);
    ctlPnl.add(pan1);
    ctlPnl.add(pan2);
    ctlPnl.add(pan3);
    ctlPnl.add(pan4);
    ctlPnl.add(pan5);
    ctlPnl.add(pan6);
    ctlPnl.add(graphBtn);

    //Create a panel to contain the
    // Canvas objects.  They will be
    // displayed in a one-column grid.
    JPanel canvasPanel = new JPanel();
    canvasPanel.setLayout(//?rows,1 col
                  new GridLayout(0,1));

    //Create a custom Canvas object for
    // each function to be plotted and
    // add them to the one-column grid.
    // Make background colors alternate
    // between white and gray.
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      switch(cnt){
        case 0 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 1 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 2 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 3 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 4 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].
            setBackground(Color.WHITE);
      }//end switch
      //Add the object to the grid.
      canvasPanel.add(canvases[cnt]);
    }//end for loop

    //Add the sub-assemblies to the
    // frame.  Set its location, size,
    // and title, and make it visible.
    getContentPane().
                   add(ctlPnl,"South");
    getContentPane().
             add(canvasPanel,"Center");

    setBounds(0,0,frmWidth,frmHeight);

    if(args == null){
      setTitle("Graph03, " +
                 "Copyright 2002, " +
                 "Richard G. Baldwin");
    }else{
      setTitle("Graph03/" + args +
                 " Copyright 2002, " +
                 "R. G. Baldwin");
    }//end else

    setVisible(true);

    //Set to exit on X-button click
    setDefaultCloseOperation(
                        EXIT_ON_CLOSE);

    //Guarantee a repaint on startup.
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end constructor
  //---------------------------------//

  //This event handler is registered
  // on the JButton to cause the
  // functions to be replotted.
  public void actionPerformed(
                      ActionEvent evt){
    //Re-instantiate the object that
    // provides the data
    try{
      if(args != null){
        data = (GraphIntfc01)Class.
           forName(args).newInstance();
      }else{
        data = new junk();
      }//end else
    }catch(Exception e){
      //Known to be safe at this point.
      // Otherwise would have aborted
      // earlier.
    }//end catch

    //Set plotting parameters using
    // data from the text fields.
    xMin = Double.parseDouble(
                    xMinTxt.getText());
    xMax = Double.parseDouble(
                    xMaxTxt.getText());
    yMin = Double.parseDouble(
                    yMinTxt.getText());
    yMax = Double.parseDouble(
                    yMaxTxt.getText());
    xTicInt = Double.parseDouble(
                 xTicIntTxt.getText());
    yTicInt = Double.parseDouble(
                 yTicIntTxt.getText());
    xCalcInc = Double.parseDouble(
                xCalcIncTxt.getText());

    //Calculate new values for the
    // length of the tic marks on the
    // axes.  If too small on x-axis,
    // a default value is used later.
    xTicLen = (yMax-yMin)/50;
    yTicLen = (xMax-xMin)/50;

    //Repaint the plotting areas
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end actionPerformed
  //---------------------------------//


//This is an inner class, which is used
// to override the paint method on the
// plotting surface.
class MyCanvas extends Canvas{
  int cnt;//object number
  //Factors to convert from double
  // values to integer pixel locations.
  double xScale;
  double yScale;

  MyCanvas(int cnt){//save obj number
    this.cnt = cnt;
  }//end constructor

  //Override the paint method
  public void paint(Graphics g){

    //Get and save the size of the
    // plotting surface
    width = canvases[0].getWidth();
    height = canvases[0].getHeight();

    //Calculate the scale factors
    xScale = width/(xMax-xMin);
    yScale = height/(yMax-yMin);

    //Set the origin based on the
    // minimum values in x and y
    g.translate((int)((0-xMin)*xScale),
               (int)((0-yMin)*yScale));
    drawAxes(g);//Draw the axes
    g.setColor(Color.BLACK);

    //Get initial data values
    double xVal = xMin;
    int oldX = getTheX(xVal);
    int oldY = 0;
    //Use the Canvas obj number to
    // determine which method to
    // call to get the value for y.
    switch(cnt){
      case 0 :
        oldY = getTheY(data.f1(xVal));
        break;
      case 1 :
        oldY = getTheY(data.f2(xVal));
        break;
      case 2 :
        oldY = getTheY(data.f3(xVal));
        break;
      case 3 :
        oldY = getTheY(data.f4(xVal));
        break;
      case 4 :
        oldY = getTheY(data.f5(xVal));
    }//end switch

    //Now loop and plot the points
    while(xVal &lt; xMax){
      int yVal = 0;
      //Get next data value.  Use the
      // Canvas obj number to
      // determine which method to
      // call to get the value for y.
      switch(cnt){
        case 0 :
          yVal =
                getTheY(data.f1(xVal));
          break;
        case 1 :
          yVal =
                getTheY(data.f2(xVal));
          break;
        case 2 :
          yVal =
                getTheY(data.f3(xVal));
          break;
        case 3 :
          yVal =
                getTheY(data.f4(xVal));
          break;
        case 4 :
          yVal =
                getTheY(data.f5(xVal));
      }//end switch1

      //Convert the x-value to an int
      // and draw the next line segment
      int x = getTheX(xVal);
      g.drawLine(oldX,oldY,x,yVal);

      //Increment along the x-axis
      xVal += xCalcInc;

      //Save end point to use as start
      // point for next line segment.
      oldX = x;
      oldY = yVal;
    }//end while loop

  }//end overridden paint method
  //---------------------------------//

  //Method to draw axes with tic marks
  // and labels in the color RED
  void drawAxes(Graphics g){
    g.setColor(Color.RED);

    //Lable left x-axis and bottom
    // y-axis.  These are the easy
    // ones.  Separate the labels from
    // the ends of the tic marks by
    // two pixels.
    g.drawString("" + (int)xMin,
                 getTheX(xMin),
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMin,
                  getTheX(yTicLen/2)+2,
                        getTheY(yMin));

    //Label the right x-axis and the
    // top y-axis.  These are the hard
    // ones because the position must
    // be adjusted by the font size and
    // the number of characters.
    //Get the width of the string for
    // right end of x-axis and the
    // height of the string for top of
    // y-axis
    //Create a string that is an
    // integer representation of the
    // label for the right end of the
    // x-axis.  Then get a character
    // array that represents the
    // string.
    int xMaxInt = (int)xMax;
    String xMaxStr = "" + xMaxInt;
    char[] array = xMaxStr.
                         toCharArray();

    //Get a FontMetrics object that can
    // be used to get the size of the
    // string in pixels.
    FontMetrics fontMetrics =
                    g.getFontMetrics();
    //Get a bounding rectangle for the
    // string
    Rectangle2D r2d =
           fontMetrics.getStringBounds(
               array,0,array.length,g);
    //Get the width and the height of
    // the bounding rectangle.  The
    // width is the width of the label
    // at the right end of the
    // x-axis.  The height applies to
    // all the labels, but is needed
    // specifically for the label at
    // the top end of the y-axis.
    int labWidth =
                 (int)(r2d.getWidth());
    int labHeight =
                (int)(r2d.getHeight());

    //Label the positive x-axis and the
    // positive y-axis using the width
    // and height from above to
    // position the labels.  These
    // labels apply to the very ends of
    // the axes at the edge of the
    // plotting surface.
    g.drawString("" + (int)xMax,
                getTheX(xMax)-labWidth,
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMax,
              getTheX(yTicLen/2)+2,
              getTheY(yMax)+labHeight);

    //Draw the axes
    g.drawLine(getTheX(xMin),
                         getTheY(0.0),
                         getTheX(xMax),
                         getTheY(0.0));

    g.drawLine(getTheX(0.0),
                        getTheY(yMin),
                        getTheX(0.0),
                        getTheY(yMax));

    //Draw the tic marks on axes
    xTics(g);
    yTics(g);
  }//end drawAxes

  //---------------------------------//

  //Method to draw tic marks on x-axis
  void xTics(Graphics g){
    double xDoub = 0;
    int x = 0;

    //Get the ends of the tic marks.
    int topEnd = getTheY(xTicLen/2);
    int bottomEnd =
                   getTheY(-xTicLen/2);

    //If the vertical size of the
    // plotting area is small, the
    // calculated tic size may be too
    // small.  In that case, set it to
    // 10 pixels.
    if(topEnd &lt; 5){
      topEnd = 5;
      bottomEnd = -5;
    }//end if

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive x-axis
    // moving to the right from zero.
    while(xDoub &lt; xMax){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub += xTicInt;
    }//end while

    //Now do the negative x-axis moving
    // to the left from zero
    xDoub = 0;
    while(xDoub &gt; xMin){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub -= xTicInt;
    }//end while

  }//end xTics
  //---------------------------------//

  //Method to draw tic marks on y-axis
  void yTics(Graphics g){
    double yDoub = 0;
    int y = 0;
    int rightEnd = getTheX(yTicLen/2);
    int leftEnd = getTheX(-yTicLen/2);

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive y-axis
    // moving up from zero.
    while(yDoub &lt; yMax){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub += yTicInt;
    }//end while

    //Now do the negative y-axis moving
    // down from zero.
    yDoub = 0;
    while(yDoub &gt; yMin){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub -= yTicInt;
    }//end while

  }//end yTics

  //---------------------------------//

  //This method translates and scales
  // a double y value to plot properly
  // in the integer coordinate system.
  // In addition to scaling, it causes
  // the positive direction of the
  // y-axis to be from bottom to top.
  int getTheY(double y){
    double yDoub = (yMax+yMin)-y;
    int yInt = (int)(yDoub*yScale);
    return yInt;
  }//end getTheY
  //---------------------------------//

  //This method scales a double x value
  // to plot properly in the integer
  // coordinate system.
  int getTheX(double x){
    return (int)(x*xScale);
  }//end getTheX
  //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI
//===================================//

//Sample test class.  Required for
// compilation and stand-alone
// testing.
class junk implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 4;
  }//end getNmbr

  public double f1(double x){
    return (x*x*x)/200.0;
  }//end f1

  public double f2(double x){
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    return (x*x)/200.0;
  }//end f3

  public double f4(double x){
    return 50*Math.cos(x/10.0);
  }//end f4

  public double f5(double x){
    return 100*Math.sin(x/20.0);
  }//end f5

}//end sample class junk
</code>




</entry>
</row>
</tbody>


</tgroup>
</table>





<table id="table1040" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1040">
<row id="tr1080">



<entry id="th1040">
<emphasis id="Listing_21" effect="bold">

Listing 21.

</emphasis>

 ForwardRealToComplex01.java.

</entry>



</row>
</thead>


<tbody id="tbody1040">
<row id="tr1081">
<entry id="td1040">

		

<code id="pre1038" display="block">/*File ForwardRealToComplex01.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

The static method named transform performs a real
to complex Fourier transform.

Does not implement the FFT algorithm. Implements
a straight-forward sampled-data version of the
continuous Fourier transform defined using
integral calculus.  See ForwardRealToComplexFFT01
for an FFT algorithm.

Returns real, imag, magnitude, and phase angle in
degrees.

Incoming parameters are:
  double[] data - incoming real data
  double[] realOut - outgoing real data
  double[] imagOut - outgoing imaginary data
  double[] angleOut - outgoing phase angle in
    degrees
  double[] magnitude - outgoing amplitude
    spectrum
  int zero - the index of the incoming data
    sample that represents zero time
  double lowF - Low freq limit as fraction of
    sampling frequency
  double highF - High freq limit as fraction of
    sampling frequency

The frequency increment is the difference between
high and low limits divided by the length of
the magnitude array

The magnitude is computed as the square root of
the sum of the squares of the real and imaginary
parts.  This value is divided by the incoming
data length, which is given by data.length.

Returns a number of points in the frequency
domain equal to the incoming data length
regardless of the high and low frequency
limits.
************************************************/

public class ForwardRealToComplex01{

  public static void transform(
                              double[] data,
                              double[] realOut,
                              double[] imagOut,
                              double[] angleOut,
                              double[] magnitude,
                              int zero,
                              double lowF,
                              double highF){
    double pi = Math.PI;//for convenience
    int dataLen = data.length;
    double delF = (highF-lowF)/data.length;
    //Outer loop iterates on frequency
    // values.
    for(int i=0; i &lt; dataLen;i++){
      double freq = lowF + i*delF;
      double real = 0.0;
      double imag = 0.0;
      double ang = 0.0;
      //Inner loop iterates on time-
      // series points.
      for(int j=0; j &lt; dataLen; j++){
        real += data[j]*Math.cos(
                             2*pi*freq*(j-zero));
        imag += data[j]*Math.sin(
                             2*pi*freq*(j-zero));
      }//end inner loop
      realOut[i] = real/dataLen;
      imagOut[i] = imag/dataLen;
      magnitude[i] = (Math.sqrt(
                 real*real + imag*imag))/dataLen;

      //Calculate and return the phase
      // angle in degrees.
      if(imag == 0.0 &amp;&amp; real == 0.0){ang = 0.0;}
      else{ang = Math.atan(imag/real)*180.0/pi;}

      if(real &lt; 0.0 &amp;&amp; imag == 0.0){ang = 180.0;}
      else if(real &lt; 0.0 &amp;&amp; imag == -0.0){
                                   ang = -180.0;}
      else if(real &lt; 0.0 &amp;&amp; imag &gt; 0.0){
                                   ang += 180.0;}
      else if(real &lt; 0.0 &amp;&amp; imag &lt; 0.0){
                                  ang += -180.0;}
      angleOut[i] = ang;
    }//end outer loop
  }//end transform method

}//end class ForwardRealToComplex01</code>




</entry>
</row>
</tbody>


</tgroup>
</table>





<table id="table1041" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1041">
<row id="tr1082">



<entry id="th1041">
<emphasis id="Listing_22" effect="bold">

Listing 22.

</emphasis>

 Dsp030.java.

</entry>



</row>
</thead>


<tbody id="tbody1041">
<row id="tr1083">
<entry id="td1041">

		

<code id="pre1039" display="block">/* File Dsp030.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

Uses an FFT algorithm to compute and display the
magnitude of the spectral content for up to five
sinusoids having different frequencies and
amplitudes.

See the program named Dsp028 for a program that
does not use an FFT algorithm.

Gets input parameters from a file named
Dsp030.txt.  If that file doesn't exist in the
current directory, the program uses a set of
default parameters.

Each parameter value must be stored as characters
on a separate line in the file named Dsp030.txt.
The required parameters are as follows:

Data length as type int
Number of spectra as type int.  Max value is 5.
List of sinusoid frequency values as type double.
List of sinusoid amplitude values as type double.

CAUTION: THE DATA LENGTH MUST BE A POWER OF TWO.
OTHERWISE, THIS PROGRAM WILL FAIL TO RUN
PROPERLY.

The number of values in each of the lists must
match the value for the number of spectra.

Note:  All frequency values are specified as a
double representing a fractional part of the
sampling frequency.  For example, a value of 0.5
specifies a frequency that is half the sampling
frequency.

Here is a set of sample parameter values.  Don't
allow blank lines at the end of the data in the
file.

128.0
5
0.1
0.2
0.3
0.4
0.45
60
70
80
90
100

The plotting program that is used to plot the
output data from this program requires that the
program implement GraphIntfc01.  For example,
the plotting program named Graph03 can be used
to plot the data produced by this program.  When
it is used, the usage information is:

java Graph03 Dsp030

A static method named transform belonging to the
class named ForwardRealToComplexFFT01 is used to
perform the actual spectral analysis.  The method
named transform implements an FFT algorithm.  The
FFT algorithm requires that the data length be
a power of two.

Tested using SDK 1.4.2 under WinXP.
************************************************/
import java.util.*;
import java.io.*;

class Dsp030 implements GraphIntfc01{
  final double pi = Math.PI;//for simplification

  //Begin default parameters
  int len = 128;//data length
  int numberSpectra = 5;
  //Frequencies of the sinusoids
  double[] freq = {0.1,0.2,0.3,0.4,0.5};
  //Amplitudes of the sinusoids
  double[] amp = {60,70,80,90,100};
  //End default parameters

  //Following arrays will contain data that is
  // input to the spectral analysis process.
  double[] data1;
  double[] data2;
  double[] data3;
  double[] data4;
  double[] data5;

  //Following arrays receive information back
  // from the spectral analysis that is not used
  // in this program.
  double[] real;
  double[] imag;
  double[] angle;

  //Following arrays receive the magnitude
  // spectral information back from the spectral
  // analysis process.
  double[] magnitude1;
  double[] magnitude2;
  double[] magnitude3;
  double[] magnitude4;
  double[] magnitude5;

  public Dsp030(){//constructor

    //Get the parameters from a file named
    // Dsp030.txt.  Use the default parameters
    // if the file doesn't exist in the current
    // directory.
    if(new File("Dsp030.txt").exists()){
      getParameters();
    }//end if

    //Note that this program always processes
    // five sinusoids, even if fewer than five
    // were requested as the input parameter
    // for numberSpectra.  In that case, the
    // extras are processed using default values
    // and simply ignored when the results are
    // plotted.

    //Create the raw data.  Note that the
    // argument for a sinusoid at half the
    // sampling frequency would be (2*pi*x*0.5).
    // This would represent one half cycle or pi
    // radians per sample.
    //First create empty array objects.
    double[] data1 = new double[len];
    double[] data2 = new double[len];
    double[] data3 = new double[len];
    double[] data4 = new double[len];
    double[] data5 = new double[len];
    //Now populate the array objects
    for(int n = 0;n &lt; len;n++){
      data1[n] = amp[0]*Math.cos(2*pi*n*freq[0]);
      data2[n] = amp[1]*Math.cos(2*pi*n*freq[1]);
      data3[n] = amp[2]*Math.cos(2*pi*n*freq[2]);
      data4[n] = amp[3]*Math.cos(2*pi*n*freq[3]);
      data5[n] = amp[4]*Math.cos(2*pi*n*freq[4]);
    }//end for loop
    //Compute magnitude spectra of the raw data
    // and save it in output arrays.  Note that
    // the real, imag, and angle arrays are not
    // used later, so they are discarded each
    // time a new spectral analysis is performed.
    magnitude1 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplexFFT01.transform(data1,
                     real,imag,angle,magnitude1);

    magnitude2 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplexFFT01.transform(data2,
                     real,imag,angle,magnitude2);

    magnitude3 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplexFFT01.transform(data3,
                     real,imag,angle,magnitude3);

    magnitude4 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplexFFT01.transform(data4,
                     real,imag,angle,magnitude4);

    magnitude5 = new double[len];
    real = new double[len];
    imag = new double[len];
    angle = new double[len];
    ForwardRealToComplexFFT01.transform(data5,
                     real,imag,angle,magnitude5);
  }//end constructor
  //-------------------------------------------//

  //This method gets processing parameters from
  // a file named Dsp030.txt and stores those
  // parameters in instance variables belonging
  // to the object of type Dsp030.
  void getParameters(){
    int cnt = 0;
    //Temporary holding area for strings.  Allow
    // space for a few blank lines at the end
    // of the data in the file.
    String[] data = new String[20];
    try{
      //Open an input stream.
      BufferedReader inData =
               new BufferedReader(new FileReader(
                                  "Dsp030.txt"));
      //Read and save the strings from each of
      // the lines in the file.  Be careful to
      // avoid having blank lines at the end,
      // which may cause an ArrayIndexOutOfBounds
      // exception to be thrown.
      while((data[cnt] =
                     inData.readLine()) != null){
        cnt++;
      }//end while
      inData.close();
    }catch(IOException e){}

    //Move the parameter values from the
    // temporary holding array into the instance
    // variables, converting from characters to
    // numeric values in the process.
    cnt = 0;
    len = (int)Double.parseDouble(data[cnt++]);
    numberSpectra = (int)Double.parseDouble(
                                    data[cnt++]);
    for(int fCnt = 0;fCnt &lt; numberSpectra;
                                         fCnt++){
      freq[fCnt] = Double.parseDouble(
                                    data[cnt++]);
    }//end for loop
    for(int aCnt = 0;aCnt &lt; numberSpectra;
                                         aCnt++){
      amp[aCnt] = Double.parseDouble(
                                    data[cnt++]);
    }//end for loop

    //Print parameter values.
    System.out.println();
    System.out.println("Data length: " + len);
    System.out.println(
             "Number spectra: " + numberSpectra);
    System.out.println("Frequencies");
    for(cnt = 0;cnt &lt; numberSpectra;cnt++){
      System.out.println(freq[cnt]);
    }//end for loop
    System.out.println("Amplitudes");
    for(cnt = 0;cnt &lt; numberSpectra;cnt++){
      System.out.println(amp[cnt]);
    }//end for loop

  }//end getParameters
  //-------------------------------------------//
  //The following six methods are required by the
  // interface named GraphIntfc01.  The plotting
  // program pulls the data values to be plotted
  // by calling these methods.
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return numberSpectra;
  }//end getNmbr
  //-------------------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude1.length-1){
      return 0;
    }else{
      return magnitude1[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f2(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude2.length-1){
      return 0;
    }else{
      return magnitude2[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f3(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude3.length-1){
      return 0;
    }else{
      return magnitude3[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f4(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude4.length-1){
      return 0;
    }else{
      return magnitude4[index];
    }//end else
  }//end function
  //-------------------------------------------//
  public double f5(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; magnitude5.length-1){
      return 0;
    }else{
      return magnitude5[index];
    }//end else
  }//end function
  //-------------------------------------------//

}//end class Dsp030</code>




</entry>
</row>
</tbody>


</tgroup>
</table>





<table id="table1042" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1042">
<row id="tr1084">



<entry id="th1042">
<emphasis id="Listing_23" effect="bold">

Listing 23.

</emphasis>

 ForwardRealToComplexFFT01.java.

</entry>



</row>
</thead>


<tbody id="tbody1042">
<row id="tr1085">
<entry id="td1042">

		

<code id="pre1040" display="block">/*File ForwardRealToComplexFFT01.java
Copyright 2004, R.G.Baldwin
Rev 5/14/04

The static method named transform performs a real
to complex Fourier transform using a crippled
complex-to-complex FFT algorithm.  It is crippled
in the sense that it is not being used to its
full potential as a complex-to-complex forward
or inverse FFT algorithm.

See ForwardRealToComplex01 for a slower but more
general approach that does not use an FFT
algorithm.

Returns real, imag, magnitude, and phase angle in
degrees.

Incoming parameters are:
  double[] data - incoming real data
  double[] realOut - outgoing real data
  double[] imagOut - outgoing imaginary data
  double[] angleOut - outgoing phase angle in
    degrees
  double[] magnitude - outgoing amplitude
    spectrum

The magnitude is computed as the square root of
 the sum of the squares of the real and imaginary
 parts.  This value is divided by the incoming
 data length, which is given by data.length.

CAUTION: THE INCOMING DATA LENGTH MUST BE A
POWER OF TWO. OTHERWISE, THIS PROGRAM WILL FAIL
TO RUN PROPERLY.

Returns a number of points in the frequency
domain equal to the incoming data length.  Those
points are uniformly distributed between zero and
one less than the sampling frequency.
************************************************/

public class ForwardRealToComplexFFT01{

  public static void transform(
                             double[] data,
                             double[] realOut,
                             double[] imagOut,
                             double[] angleOut,
                             double[] magnitude){
    double pi = Math.PI;//for convenience
    int dataLen = data.length;
    //The complexToComplex FFT method does an
    // in-place transform causing the output
    // complex data to be stored in the arrays
    // containing the input complex data.
    // Therefore, it is necessary to copy the
    // input data to this method into the real
    // part of the complex data passed to the
    // complexToComplex method.
    System.arraycopy(data,0,realOut,0,dataLen);

    //Perform the spectral analysis.  The results
    // are stored in realOut and imagOut. The +1
    // causes it to be a forward transform. A -1
    // would cause it to be an inverse transform.
    complexToComplex(1,dataLen,realOut,imagOut);

    //Compute the magnitude and the phase angle
    // in degrees.
    for(int cnt = 0;cnt &lt; dataLen;cnt++){
      magnitude[cnt] =
           (Math.sqrt(realOut[cnt]*realOut[cnt]
           + imagOut[cnt]*imagOut[cnt]))/dataLen;

      if(imagOut[cnt] == 0.0
                         &amp;&amp; realOut[cnt] == 0.0){
          angleOut[cnt] = 0.0;
      }//end if
      else{
        angleOut[cnt] = Math.atan(
             imagOut[cnt]/realOut[cnt])*180.0/pi;
      }//end else

      if(realOut[cnt] &lt; 0.0
                         &amp;&amp; imagOut[cnt] == 0.0){
        angleOut[cnt] = 180.0;
      }else if(realOut[cnt] &lt; 0.0
                        &amp;&amp; imagOut[cnt] == -0.0){
        angleOut[cnt] = -180.0;
      }else if(realOut[cnt] &lt; 0.0
                          &amp;&amp; imagOut[cnt] &gt; 0.0){
        angleOut[cnt] += 180.0;
      }else if(realOut[cnt] &lt; 0.0
                          &amp;&amp; imagOut[cnt] &lt; 0.0){
        angleOut[cnt] += -180.0;
      }//end else

    }//end for loop

  }//end transform method
  //-------------------------------------------//

  //This method computes a complex-to-complex
  // FFT.  The value of sign must be 1 for a
  // forward FFT.
  public static void complexToComplex(
                                  int sign,
                                  int len,
                                  double real[],
                                  double imag[]){
    double scale = 1.0;
    //Reorder the input data into reverse binary
    // order.
    int i,j;
    for (i=j=0; i &lt; len; ++i) {
      if (j&gt;=i) {
        double tempr = real[j]*scale;
        double tempi = imag[j]*scale;
        real[j] = real[i]*scale;
        imag[j] = imag[i]*scale;
        real[i] = tempr;
        imag[i] = tempi;
      }//end if
      int m = len/2;
      while (m&gt;=1 &amp;&amp; j&gt;=m) {
        j -= m;
        m /= 2;
      }//end while loop
      j += m;
    }//end for loop

    //Input data has been reordered.
    int stage = 0;
    int maxSpectraForStage,stepSize;
    //Loop once for each stage in the spectral
    // recombination process.
    for(maxSpectraForStage = 1,
                stepSize = 2*maxSpectraForStage;
                maxSpectraForStage &lt; len;
                maxSpectraForStage = stepSize,
                stepSize = 2*maxSpectraForStage){
      double deltaAngle =
                 sign*Math.PI/maxSpectraForStage;
      //Loop once for each individual spectra
      for (int spectraCnt = 0;
                 spectraCnt &lt; maxSpectraForStage;
                 ++spectraCnt){
        double angle = spectraCnt*deltaAngle;
        double realCorrection = Math.cos(angle);
        double imagCorrection = Math.sin(angle);

        int right = 0;
        for (int left = spectraCnt;
                   left &lt; len;left += stepSize){
          right = left + maxSpectraForStage;
          double tempReal =
                    realCorrection*real[right]
                    - imagCorrection*imag[right];
          double tempImag =
                    realCorrection*imag[right]
                    + imagCorrection*real[right];
          real[right] = real[left]-tempReal;
          imag[right] = imag[left]-tempImag;
          real[left] += tempReal;
          imag[left] += tempImag;
        }//end for loop
      }//end for loop for individual spectra
      maxSpectraForStage = stepSize;
    }//end for loop for stages
  }//end complexToComplex method

}//end class ForwardRealToComplexFFT01</code>




</entry>
</row>
</tbody>


</tgroup>
</table>






	

</section>
<section id="h11008">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1211">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1000" type="">


		


			


				

<emphasis id="strong1162" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1025" list-type="bulleted">

					

<item id="li1135">
Module name: Java1482-Spectrum Analysis using Java, 
					Sampling Frequency, Folding Frequency, and the FFT Algorithm

</item>


					

<item id="li1136">
File: Java1482.htm

</item>


					

<item id="li1137">
Published: 07/06/04

</item>



				

</list>




<para id="p1212">
Baldwin explains several different programs used for spectral analysis. He also explains the impact of the sampling frequency and the Nyquist folding frequency on spectral analysis. 

</para>



				

</note>





	

<note id="note1001" type="">


		


			


				

<emphasis id="strong1163" effect="bold">
Disclaimers:

</emphasis>
<para id="p1213">
<emphasis id="strong1164" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>



				

<para id="p1214">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>



				

<para id="p1215">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>



				

<para id="p1216">
<emphasis id="strong1165" effect="bold">
Affiliation

</emphasis>
::: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>




</note>



	

	



<para id="p1217">
-end- 

</para>







</section>
</content>




</document>