<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Java1468-Plotting Engineering and Scientific Data using Java</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m49795</md:content-id>
  <md:title>Java1468-Plotting Engineering and Scientific Data using Java</md:title>
  <md:abstract>Baldwin shows you how write a generalized plotting program that can be used to plot engineering and scientific data produced by any object that implements a very simple interface.</md:abstract>
  <md:uuid>b5a14d3a-c54c-4239-b414-bae75d1e8cda</md:uuid>
</metadata>

<content>






<quote id="blockquote1000" display="block">



<para id="p1000">
Revised: Fri Oct 16 23:13:29 CDT 2015

</para>





<para id="p1001">
This page is included in the following books:

</para>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">
<link id="a1000" url="http://cnx.org/contents/98d253c0-8044-4e22-a707-7b8d819bc8a7">


        Digital Signal Processing - DSP

</link>

 

</item>




</list>




</quote>











<section id="h11000">
<title>
<emphasis id="Table_of_contents" effect="bold">

Table of contents

</emphasis>


</title>




<list id="ul1001" list-type="bulleted">

	

<item id="li1001">
<link id="a1001" target-id="Preface">

Preface

</link>


	

<list id="ul1002" list-type="bulleted">

		

<item id="li1002">
<link id="a1002" target-id="Viewing_tip">

Viewing tip

</link>


<list id="ul1003" list-type="bulleted">

			

<item id="li1003">
<link id="a1003" target-id="Figures">

Figures

</link>


</item>


			

<item id="li1004">
<link id="a1004" target-id="Listings">

Listings

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>



	

<item id="li1005">
<link id="a1005" target-id="Preview">

Preview

</link>


<list id="ul1004" list-type="bulleted">

		

<item id="li1006">
<link id="a1006" target-id="The_Graph01Demo_program_">

The Graph01Demo program

</link>

 

</item>


		

<item id="li1007">
<link id="a1007" target-id="Using_the_plotting_program_with_your_data">

Using the plotting program with your data

</link>


</item>


		

<item id="li1008">
<link id="a1008" target-id="The_Graph01_program_">

The Graph01 program 

</link>

 

</item>


	

</list>


	

</item>



	

<item id="li1009">
<link id="a1009" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>


<list id="ul1005" list-type="bulleted">

		

<item id="li1010">
<link id="a1010" target-id="Testing_the_plotting_program">

Testing the plotting program

</link>


</item>


		

<item id="li1011">
<link id="a1011" target-id="Using_the_plotting_program">

Using the plotting program

</link>

 
		

<list id="ul1006" list-type="bulleted">

			

<item id="li1012">
<link id="a1012" target-id="Plotting_your_data_using_Graph01">

Plotting your data using Graph01

</link>


</item>


			

<item id="li1013">
<link id="a1013" target-id="The_interface_named_GraphIntfc01">

The interface named GraphIntfc01

</link>


</item>


		

</list>


		

</item>


		

<item id="li1014">
<link id="a1014" target-id="The_class_named_Graph01Demo">

The class named Graph01Demo

</link>


<list id="ul1007" list-type="bulleted">

			

<item id="li1015">
<link id="a1015" target-id="Defining_data-generator_classes">

Defining data-generator classes

</link>

 

</item>


			

<item id="li1016">
<link id="a1016" target-id="The_number_of_functions_to_plot_">

The number of functions to plot

</link>

 

</item>


			

<item id="li1017">
<link id="a1017" target-id="Themethodnamedf1">

The method named f1

</link>


</item>


			

<item id="li1018">
<link id="a1018" target-id="The_method_named_f2">

The method named f2

</link>


</item>


			

<item id="li1019">
<link id="a1019" target-id="The_method_named_f3">

The method named f3

</link>


</item>


			

<item id="li1020">
<link id="a1020" target-id="The_method_named_f4">

The method named f4

</link>


</item>


			

<item id="li1021">
<link id="a1021" target-id="The_method_named_f5">

The method named f5

</link>


</item>


			

<item id="li1022">
<link id="a1022" target-id="The_end_of_the_class_definition">

The end of the class definition

</link>


</item>


		

</list>


		

</item>


		

<item id="li1023">
<link id="a1023" target-id="The_class_named_Dsp002">

The class named Dsp002

</link>


<list id="ul1008" list-type="bulleted">

			

<item id="li1024">
<link id="a1024" target-id="A_DSP_example_">

A DSP example 

</link>

 

</item>


			

<item id="li1025">
<link id="a1025" target-id="Beginning_of_the_class_named_Dsp002">

Beginning of the class named Dsp002

</link>


</item>


			

<item id="li1026">
<link id="a1026" target-id="Create_data_arrays_">

Create data arrays

</link>

 

</item>


			

<item id="li1027">
<link id="a1027" target-id="Beginning_of_the_constructor">

Beginning of the constructor

</link>


</item>


			

<item id="li1028">
<link id="a1028" target-id="Create_the_convolution_operator_">

Create the convolution operator

</link>

 

</item>


			

<item id="li1029">
<link id="a1029" target-id="Apply_the_convolution_operator_">

Apply the convolution operator 
			

</link>

 

</item>


			

<item id="li1030">
<link id="a1030" target-id="Compute_spectrum_of_each_of_two_traces">

Compute spectrum of each of two traces

</link>


</item>


			

<item id="li1031">
<link id="a1031" target-id="The_getNmbr_method">

The getNmbr method

</link>


</item>


			

<item id="li1032">
<link id="a1032" target-id="The_method_named_f1">

The method named f1

</link>


</item>


			

<item id="li1033">
<link id="a1033" target-id="Methods_f2_through_f5_">

Methods f2 through f5

</link>

 

</item>


		

</list>


		

</item>


		

<item id="li1034">
<link id="a1034" target-id="The_class_named_Convolve01">

The class named Convolve01

</link>


</item>


		

<item id="li1035">
<link id="a1035" target-id="The_discrete_Fourier_transform">

The discrete Fourier transform

</link>


</item>


		

<item id="li1036">
<link id="a1036" target-id="The_plotting_programs">

Two plotting programs

</link>


</item>


		

<item id="li1037">
<link id="a1037" target-id="The_program_named_Graph01">

The program named Graph01

</link>


<list id="ul1009" list-type="bulleted">

			

<item id="li1038">
<link id="a1038" target-id="Some_general_comments">

Some general comments

</link>


</item>


			

<item id="li1039">
<link id="a1039" target-id="The_class_named_Graph01">

The class named Graph01

</link>


</item>


			

<item id="li1040">
<link id="a1040" target-id="Beginning_of_the_class_named_GUI">

Beginning of the class named GUI

</link>

 

</item>


			

<item id="li1041">
<link id="a1041" target-id="Beginning_of_the_constructor_for_the_GUI_class">

Beginning of the constructor for the GUI class

</link>


</item>


			

<item id="li1042">
<link id="a1042" target-id="Array_to_hold_Canvas_objects_">

Array to hold Canvas objects

</link>

 

</item>


			

<item id="li1043">
<link id="a1043" target-id="Routine_GUI_construction_code">

Routine GUI construction code

</link>


</item>


			

<item id="li1044">
<link id="a1044" target-id="The_Canvas_objects">

The Canvas objects

</link>


</item>


			

<item id="li1045">
<link id="a1045" target-id="More_routine_construction_code_">

More routine construction code

</link>

 

</item>


			

<item id="li1046">
<link id="a1046" target-id="Force_a_repaint_">

Force a repaint

</link>

 

</item>


			

<item id="li1047">
<link id="a1047" target-id="End_of_the_constructor_">

End of the constructor

</link>

 

</item>


			

<item id="li1048">
<link id="a1048" target-id="Re-plotting_the_data_">

Re-plotting the data

</link>

 

</item>


			

<item id="li1049">
<link id="a1049" target-id="A_new_object_of_the_target_class">

A new object of the target class

</link>


</item>


			

<item id="li1050">
<link id="a1050" target-id="The_remainder_of_the_event_handler_">

The remainder of the event handler

</link>

 

</item>


			

<item id="li1051">
<link id="a1051" target-id="Beginning_of_the_class_named_MyCanvas">

Beginning of the class named MyCanvas

</link>


</item>


			

<item id="li1052">
<link id="a1052" target-id="Beginning_of_the_overridden_paint_method_">

Beginning of the overridden paint method

</link>

 

</item>


			

<item id="li1053">
<link id="a1053" target-id="Get_old_coordinate_values_">

Get old coordinate values

</link>

 

</item>


			

<item id="li1054">
<link id="a1054" target-id="Plot_the_points">

Plot the points

</link>


</item>


			

<item id="li1055">
<link id="a1055" target-id="The_drawAxes_method">

The drawAxes method

</link>


</item>


			

<item id="li1056">
<link id="a1056" target-id="Drawing_tic_marks">

Drawing tic marks

</link>


</item>


			

<item id="li1057">
<link id="a1057" target-id="The_getTheX_and_getTheY_methods_">

The getTheX and getTheY methods

</link>

 

</item>


			

<item id="li1058">
<link id="a1058" target-id="The_test_class_named_junk">

The test class named junk

</link>


</item>


		

</list>


		

</item>


		

<item id="li1059">
<link id="a1059" target-id="The_program_named_Graph02">

The program named Graph02

</link>


</item>


	

</list>


	

</item>



	

<item id="li1060">
<link id="a1060" target-id="Run_the_program">

Run the program

</link>


</item>


	

<item id="li1061">
<link id="a1061" target-id="Summary">

Summary

</link>


</item>


	

<item id="li1062">
<link id="a1062" target-id="Complete_program_listings">

Complete program listings

</link>


</item>



	

<item id="li1063">
<link id="a1063" target-id="Miscellaneous">

Miscellaneous

</link>


</item>





</list>


	
	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	
	

<para id="p1002">
<emphasis id="strong1000" effect="bold">
<emphasis id="em1000" effect="italics">
Excellent language for engineering computations

</emphasis>
</emphasis>
</para>





<para id="p1003">
Because of its platform independence, Java provides an excellent programming 
language for engineering and scientific computational experiments, particularly 
where extreme execution speed is not a requirement. Programs developed for such 
experiments on one platform can be successfully executed on a variety of 
platforms without the need to rewrite or recompile the program code. 

</para>





<para id="p1004">
<emphasis id="strong1001" effect="bold">
<emphasis id="em1001" effect="italics">
A large Math library 

</emphasis>
</emphasis>
</para>





<para id="p1005">
Furthermore, because if its inherent simplicity, and the availability of a 
large Math library, Java provides an excellent programming language for 
engineers and scientists who want to do their own programming, but who have no 
desire to become programming experts. The code required to conduct an 
engineering or scientific computational experiment often consists of little more 
than the most rudimentary application of arithmetic in loops using data stored 
in arrays or read from disk files.

</para>





<para id="p1006">
<emphasis id="strong1002" effect="bold">
<emphasis id="em1002" effect="italics">
Now for the bad news 

</emphasis>
</emphasis>
</para>





<para id="p1007">
However, there is a downside to this happy story. When doing this sort of 
work, it is often very important to see the results of the experiments in the 
form of graphs or plots. Unfortunately, the programming required to produce 
graphical output from simple engineering and scientific computational 
experiments cannot be accomplished using rudimentary programming techniques. 
Rather, to do that job right requires considerable expertise in Java 
programming.

</para>





<para id="p1008">
<emphasis id="strong1003" effect="bold">
<emphasis id="em1003" effect="italics">
A generalized plotting program

</emphasis>
</emphasis>
 

</para>





<para id="p1009">
This module develops a generalized plotting program, which is easy to connect 
to other programs, 

<emphasis id="em1004" effect="italics">
(whether they are simple or complex)

</emphasis>
, in order to 
display the output from those programs in two-dimensional


<link id="a1064" url="http://mathworld.wolfram.com/CartesianCoordinates.html">

Cartesian 
coordinates

</link>

.. The plotting program is specifically designed to be useful to 
persons having 

<emphasis id="em1005" effect="italics">
very little knowledge

</emphasis>
 of Java programming.

</para>





<quote id="blockquote1001" display="block">

	

<para id="p1010">
<emphasis id="em1006" effect="italics">
(Actually, the module develops two very similar plotting programs 
	each designed to display the data in a different format.) 

</emphasis>
</para>





</quote>


	
	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1011">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Figures 
and Listings while you are reading about them.

</para>



	

<section id="h31000">
<title>
<emphasis id="Figures" effect="bold">

Figures

</emphasis>


</title>


	

<list id="ul1010" list-type="bulleted">

		

<item id="li1064">
<link id="a1065" target-id="Figure_1">

Figure 1

</link>

. Sample Display. 

</item>


		

<item id="li1065">
<link id="a1066" target-id="Figure_2">

Figure 2

</link>

. Sample Display for Same Data with Different Plotting Parameters. 

</item>


		

<item id="li1066">
<link id="a1067" target-id="Figure_3">

Figure 3

</link>

. A Digital Signal Processing (DSP) Example. 

</item>


		

<item id="li1067">
<link id="a1068" target-id="Figure_4">

Figure 4

</link>

. Graphic Display for Self-Test Class. 

</item>


		

<item id="li1068">
<link id="a1069" target-id="Figure_5">

Figure 5

</link>

. Sample output format from Graph02. 

</item>



	

</list>


	

</section>
<section id="h31001">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1011" list-type="bulleted">

		

<item id="li1069">
<link id="a1070" target-id="Listing_1">

Listing 1

</link>

. Source code for GraphIntfc01.java. 

</item>


		

<item id="li1070">
<link id="a1071" target-id="Listing_2">

Listing 2

</link>

. Beginning of the class named Graph01Demo. 

</item>


		

<item id="li1071">
<link id="a1072" target-id="Listing_3">

Listing 3

</link>

. The method named getNmbr.

</item>


		

<item id="li1072">
<link id="a1073" target-id="Listing_4">

Listing 4

</link>

. The method named f1. 

</item>


		

<item id="li1073">
<link id="a1074" target-id="Listing_5">

Listing 5

</link>

. The method named f2. 

</item>


		

<item id="li1074">
<link id="a1075" target-id="Listing_6">

Listing 6

</link>

. The method named f3. 

</item>


		

<item id="li1075">
<link id="a1076" target-id="Listing_7">

Listing 7

</link>

. The method named f4. 

</item>


		

<item id="li1076">
<link id="a1077" target-id="Listing_8">

Listing 8

</link>

. The method named f5. 

</item>


		

<item id="li1077">
<link id="a1078" target-id="Listing_9">

Listing 9

</link>

. Beginning of the class named Dsp002. 

</item>


		

<item id="li1078">
<link id="a1079" target-id="Listing_10">

Listing 10

</link>

. Create data arrays.

</item>


		

<item id="li1079">
<link id="a1080" target-id="Listing_11">

Listing 11

</link>

. Beginning of the constructor.

</item>


		

<item id="li1080">
<link id="a1081" target-id="Listing_12">

Listing 12

</link>

. Create the convolution operator.

</item>


		

<item id="li1081">
<link id="a1082" target-id="Listing_13">

Listing 13

</link>

. Apply the convolution operator.

</item>


		

<item id="li1082">
<link id="a1083" target-id="Listing_14">

Listing 14

</link>

. Compute spectrum of each of two traces.

</item>


		

<item id="li1083">
<link id="a1084" target-id="Listing_15">

Listing 15

</link>

. The getNmbr method.

</item>


		

<item id="li1084">
<link id="a1085" target-id="Listing_16">

Listing 16

</link>

. The method named f1.

</item>


		

<item id="li1085">
<link id="a1086" target-id="Listing_17">

Listing 17

</link>

. The class named Convolve01.

</item>


		

<item id="li1086">
<link id="a1087" target-id="Listing_18">

Listing 18

</link>

. The discrete Fourier transform (DFT).

</item>


		

<item id="li1087">
<link id="a1088" target-id="Listing_19">

Listing 19

</link>

. The class named Graph01.

</item>


		

<item id="li1088">
<link id="a1089" target-id="Listing_20">

Listing 20

</link>

. Beginning of the class named GUI.

</item>


		

<item id="li1089">
<link id="a1090" target-id="Listing_21">

Listing 21

</link>

. Beginning of the constructor for the GUI class. 

</item>


		

<item id="li1090">
<link id="a1091" target-id="Listing_22">

Listing 22

</link>

. Array to hold Canvas objects.

</item>


		

<item id="li1091">
<link id="a1092" target-id="Listing_23">

Listing 23

</link>

. Routine GUI construction code.

</item>


		

<item id="li1092">
<link id="a1093" target-id="Listing_24">

Listing 24

</link>

. The Canvas objects.

</item>


		

<item id="li1093">
<link id="a1094" target-id="Listing_25">

Listing 25

</link>

. More routine construction code.

</item>


		

<item id="li1094">
<link id="a1095" target-id="Listing_26">

Listing 26

</link>

. Force a repaint.

</item>


		

<item id="li1095">
<link id="a1096" target-id="Listing_27">

Listing 27

</link>

. Beginning of the re-plot code. 

</item>


		

<item id="li1096">
<link id="a1097" target-id="Listing_28">

Listing 28

</link>

. The remainder of the event handler.

</item>


		

<item id="li1097">
<link id="a1098" target-id="Listing_29">

Listing 29

</link>

. Beginning of the class named MyCanvas. 

</item>


		

<item id="li1098">
<link id="a1099" target-id="Listing_30">

Listing 30

</link>

. Beginning of the overridden paint method.

</item>


		

<item id="li1099">
<link id="a1100" target-id="Listing_31">

Listing 31

</link>

. Get old coordinate values.

</item>


		

<item id="li1100">
<link id="a1101" target-id="Listing_32">

Listing 32

</link>

. Plot the points.

</item>


		

<item id="li1101">
<link id="a1102" target-id="Listing_33">

Listing 33

</link>

. The drawAxes method.

</item>


		

<item id="li1102">
<link id="a1103" target-id="Listing_34">

Listing 34

</link>

. Drawing tic marks.

</item>


		

<item id="li1103">
<link id="a1104" target-id="Listing_35">

Listing 35

</link>

. The getTheX and getTheY methods.

</item>


		

<item id="li1104">
<link id="a1105" target-id="Listing_36">

Listing 36

</link>

. The test class named junk.

</item>


		

<item id="li1105">
<link id="a1106" target-id="Listing_37">

Listing 37

</link>

. Graph01Demo.java.

</item>


		

<item id="li1106">
<link id="a1107" target-id="Listing_38">

Listing 38

</link>

. Dsp002.java,

</item>


		

<item id="li1107">
<link id="a1108" target-id="Listing_39">

Listing 39

</link>

. Graph01.java.

</item>


		

<item id="li1108">
<link id="a1109" target-id="Listing_40">

Listing 40

</link>

. Graph02.java. 

</item>


	
	

</list>






</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="Preview" effect="bold">

Preview

</emphasis>


</title>




<para id="p1012">
<link id="a1110" target-id="Figure_1">

Figure 1

</link>

 shows a typical display produced by one of the plotting programs 
that I will develop in this module. 

<emphasis id="em1007" effect="italics">
(The other program superimposes all of 
the curves on the same set of axes instead of spacing them vertically as shown 
in 

<link id="a1111" target-id="Figure_1">

Figure 1

</link>

.) 

</emphasis>
</para>







<table id="table1000" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1000">
<row id="tr1000">
<entry id="th1000">



<emphasis id="Figure_1" effect="bold">

Figure 1.

</emphasis>

 Sample Display.


</entry>
</row>
</thead>


<tbody id="tbody1000">
<row id="tr1001">
<entry id="td1000">



<media id="media1000" alt="missing image" display="block">
<image id="img1000" mime-type="image/gif" src="../../media/java1468a.gif" width="401" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<para id="p1013">
While the plotting program itself is quite complex, the code required to 
produce the data to be plotted can be very simple. For example, because of the 
use of the Java Math library, only fourteen lines of simple Java code were 
required to produce the data plotted in 

<link id="a1112" target-id="Figure_1">

Figure 1

</link>

.

</para>





<section id="h21001">
<title>
<emphasis id="The_Graph01Demo_program_" effect="bold">

The Graph01Demo program 

</emphasis>


</title>




<para id="p1014">
The data displayed in 

<link id="a1113" target-id="Figure_1">

Figure 1

</link>

 was produced by a program named 

<emphasis id="strong1004" effect="bold">

Graph01Demo.

</emphasis>
 A listing of that program is shown in 

<link id="a1114" target-id="Listing_37">

Listing 37

</link>

 near the 
end of the module. I will explain that program in detail shortly. 

</para>





<para id="p1015">
In addition, I will provide and discuss another sample program, which 
produces and plots data having considerably more engineering and scientific 
significance than the data shown in 

<link id="a1115" target-id="Figure_1">

Figure 1

</link>

. 

<emphasis id="em1008" effect="italics">
(This will be a digital signal 
processing (DSP) example).

</emphasis>
 Even in that case, however, you will see that 
the program that produces the data is much less complex than the program used to 
plot the data.

</para>





</section>
<section id="h21002">
<title>
<emphasis id="Using_the_plotting_program_with_your_data" effect="bold">

Using the plotting 
program with your data

</emphasis>

 

</title>




<para id="p1016">
I will explain everything that you will need to know to cause the output from 
your own engineering and scientific programs to be displayed by the plotting 
program.

</para>





</section>
<section id="h21003">
<title>
<emphasis id="The_Graph01_program_" effect="bold">

The Graph01 program 

</emphasis>


</title>




<para id="p1017">
The graphical display of the data shown in 

<link id="a1116" target-id="Figure_1">

Figure 1

</link>

 was produced by my 
generalized plotting program named 

<emphasis id="strong1005" effect="bold">
Graph01

</emphasis>
. As you will see 
later, this is a long and fairly complex program.

</para>





<quote id="blockquote1002" display="block">
<emphasis id="em1009" effect="italics">
You will find two more variations on this program in the 
programs named 

<emphasis id="strong1006" effect="bold">
Graph03

</emphasis>
 and 

<emphasis id="strong1007" effect="bold">
Graph06

</emphasis>
 
in the module titled 


<link id="a1117" url="http://cnx.org/contents/201ece7a-a2bf-4576-9528-4c3c4e5322c9/Java1482-Spectrum-Analysis-usi">

Java1482-Spectrum Analysis using Java, Sampling Frequency, Folding Frequency, and the FFT Algorithm

</link>

.

</emphasis>
</quote>




<para id="p1018">
A listing of the plotting program named 

<emphasis id="strong1008" effect="bold">
Graph01

</emphasis>
 is shown in 


<link id="a1118" target-id="Listing_39">

Listing 39

</link>

 near the end of the module.

</para>





<para id="p1019">
<emphasis id="strong1009" effect="bold">
<emphasis id="em1010" effect="italics">
User need not 
understand the plotting program

</emphasis>
</emphasis>
 

</para>





<para id="p1020">
Fortunately, the user of the plotting program doesn't need to understand 
anything about the code that makes up the plotting program. All the user needs 
to understand is the interface to the program, which I will explain later.

</para>





<para id="p1021">
However, for those of you who may be interested, I will also discuss and 
explain the plotting program later in this module. 

</para>





<para id="p1022">
<emphasis id="strong1010" effect="bold">
<emphasis id="em1011" effect="italics">
Plotting format 

</emphasis>
</emphasis>
 

</para>





<para id="p1023">
As you can see in 

<link id="a1119" target-id="Figure_1">

Figure 1

</link>

, the plotting program allows for plotting up to 
five independent functions stacked vertically, each with the same vertical and 
horizontal axes. This vertical stacking format makes it easy to compare up to 
five plots at the same points on the horizontal axes.

</para>





<para id="p1024">
If you need more than five functions, the number of functions can easily be 
increased with a few minor changes to the program.

</para>




	

<quote id="blockquote1003" display="block">

		

<emphasis id="em1012" effect="italics">
(I will also provide, but will not discuss, another version of the 
		program, named 

</emphasis>
<emphasis id="strong1011" effect="bold">
<emphasis id="em1013" effect="italics">
Graph02

</emphasis>
</emphasis>
<emphasis id="em1014" effect="italics">
, which 
		superimposes up to five plots on the same coordinate system. In some 
		cases, that is a more useful form of display. You will find a complete 
		listing of this program in 

<link id="a1120" target-id="Listing_40">

Listing 40

</link>

 near the end of the module.) 

</emphasis>

	

</quote>





<para id="p1025">
<emphasis id="strong1012" effect="bold">
<emphasis id="em1015" effect="italics">
Plotting parameters 

</emphasis>
</emphasis>
</para>





<para id="p1026">
As you can also see in 

<link id="a1121" target-id="Figure_1">

Figure 1

</link>

, a set of text fields and a button on the 
bottom of the frame make it possible for the user to modify the plotting 
parameters and to re-plot the same data with an entirely new set of plotting 
parameters.

</para>





<quote id="blockquote1004" display="block">

	

<emphasis id="em1016" effect="italics">
(It is often true that important but subtle pieces of information can 
	only be exposed by viewing the same data with different sets of plotting 
	parameters.) 

</emphasis>



</quote>




<para id="p1027">
<emphasis id="strong1013" effect="bold">
<emphasis id="em1017" effect="italics">
Same data, different parameters 

</emphasis>
</emphasis>
 


</para>





<para id="p1028">
<link id="a1122" target-id="Figure_2">

Figure 2

</link>

 shows the same data as in 

<link id="a1123" target-id="Figure_1">

Figure 1

</link>

, but plotted with a different set 
of plotting parameters.

</para>







<table id="table1001" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1001">
<row id="tr1002">
<entry id="th1001">



<emphasis id="Figure_2" effect="bold">

Figure 2.

</emphasis>

 Sample Display for Same Data with Different Plotting Parameters.


</entry>
</row>
</thead>


<tbody id="tbody1001">
<row id="tr1003">
<entry id="td1001">



<media id="media1001" alt="missing image" display="block">
<image id="img1001" mime-type="image/gif" src="../../media/java1468b.gif" width="401" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<para id="p1029">
In the case of 

<link id="a1124" target-id="Figure_2">

Figure 2

</link>

, the origin was moved to the left, the total expanse 
of the horizontal axis was increased, and the space between the tic marks on the 
vertical axis was increased from 20 units to 50 units.

</para>





<quote id="blockquote1005" display="block">

	

<para id="p1030">
<emphasis id="em1018" effect="italics">
(It will help you to see the differences if you will position two 
	browser windows side-by-side while viewing one display in one browser window 
	and viewing the other display in the other browser window.)

</emphasis>
 

</para>





</quote>


	
	

</section>
</section>
<section id="h11003">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	
	

<section id="h21004">
<title>
<emphasis id="Testing_the_plotting_program" effect="bold">

Testing the plotting program

</emphasis>




</title>




<para id="p1031">
I am assuming that you have accomplished the minimal steps required to get 
the 

<link id="a1125" url="http://www.oracle.com/technetwork/java/javase/downloads/index.html">


Java Development Kit (JDK)

</link>

 that is available from Oracle installed on your 
computer

</para>





<para id="p1032">
To run the plotting program named 

<emphasis id="strong1014" effect="bold">
Graph01

</emphasis>
 in self-test mode, 
do the following:

</para>





<list id="ul1012" list-type="bulleted">

	

<item id="li1109">
Copy the code in 

<link id="a1126" target-id="Listing_39">

Listing 39

</link>

 into a file named 

<emphasis id="strong1015" effect="bold">
Graph01.java

</emphasis>
.

</item>


	

<item id="li1110">
Copy the code in 

<link id="a1127" target-id="Listing_1">

Listing 1

</link>

 into a file named 

<emphasis id="strong1016" effect="bold">
GraphIntfc.java

</emphasis>
, 
	and put that file in the same directory as the file named 

<emphasis id="strong1017" effect="bold">

	Graph01.java

</emphasis>
 above.

</item>


	

<item id="li1111">
Compile the program named 

<emphasis id="strong1018" effect="bold">
Graph01.java

</emphasis>
 using the
	

<link id="a1128" url="http://www.oracle.com/technetwork/java/javase/downloads/index.html">


	Java Development Kit (JDK)

</link>

. 

<emphasis id="em1019" effect="italics">
(Note, you must be using Java Standard 
	Edition (SE) version 1.4 or later. On the date of this module update, Java 
	SE 8u60 is the latest released version.) 

</emphasis>
</item>




</list>




<para id="p1033">
At this point, you should be able to execute the program named 

<emphasis id="strong1019" effect="bold">

Graph01

</emphasis>
 in self-test mode by entering the following command at the 
command prompt in the same directory where you compiled the program:

</para>





<code id="pre1000" display="block">java Graph01 </code>




<para id="p1034">
If everything has been done correctly up to this point, a display similar to 
that shown in 

<link id="a1129" target-id="Figure_4">

Figure 4

</link>

 should appear on your screen. 

<emphasis id="em1020" effect="italics">
(Note that you may need 
to match up the parameter values in the text fields at the bottom of the frame 
and click the 

<emphasis id="strong1020" effect="bold">
Graph

</emphasis>
 button to cause the two displays to match 
exactly.)

</emphasis>
</para>





</section>
<section id="h21005">
<title>
<emphasis id="Using_the_plotting_program" effect="bold">

Using the plotting program

</emphasis>

 

</title>




<para id="p1035">
To use the plotting program with your own data generator program, do the 
following:

</para>





<list id="ul1013" list-type="bulleted">

	

<item id="li1112">
Still working in the same directory, define and compile a data generator 
	class that implements the interface named 

<emphasis id="strong1021" effect="bold">
GraphIntfc01

</emphasis>
, 
	shown in 

<link id="a1130" target-id="Listing_1">

Listing 1

</link>

.

</item>


	

<item id="li1113">
Start the plotting program named 

<emphasis id="strong1022" effect="bold">
Graph01

</emphasis>
 running by 
	following the instructions that I will provide below.

</item>




</list>




<section id="h31002">
<title>
<emphasis id="Plotting_your_data_using_Graph01" effect="bold">

Plotting your data using Graph01

</emphasis>




</title>




<para id="p1036">
Assume that your data-generator class is named 

<emphasis id="strong1023" effect="bold">
MyData

</emphasis>
, and 
that you have successfully compiled it in the same directory as the compiled 
version of Graph01.

</para>





<para id="p1037">
The next step is to enter the following command at the command prompt in the 
same directory. 

<emphasis id="em1021" effect="italics">
(Note that this command differs from the command given 
earlier. This command provides the name of your class as a command-line argument following the name of the plotting program.) 

</emphasis>
</para>





<code id="pre1001" display="block">java Graph01 MyData </code>




<para id="p1038">
When you do this, the plotting program should start pulling the necessary 
data from your data-generator program and plotting that data in the format shown 
in 

<link id="a1131" target-id="Figure_1">

Figure 1

</link>

.

</para>





<section id="h41000">
<title>
Modifying plotting parameters 

</title>




<para id="p1039">
Once all the curves have been plotted, you can change any of the plotting 
parameter values in the text fields at the bottom of the display and press the 
button labeled 

<emphasis id="strong1024" effect="bold">
Graph

</emphasis>
. When you press the button, the plotting program 
will re-plot your data using the new plotting parameters.

</para>





</section>
<section id="h41001">
<title>
The plotting parameters 

</title>




<para id="p1040">
Here is the meaning of the plotting-parameter text fields shown in 

<link id="a1132" target-id="Figure_1">

Figure 1

</link>

:

</para>





<list id="ul1014" list-type="bulleted">

	

<item id="li1114">
xMin and xMax - The values of the left and right ends of all horizontal 
	axes.

</item>


	

<item id="li1115">
yMin and yMax - The values of the bottom and top of the vertical axis in 
	each plotting area. 

<emphasis id="em1022" effect="italics">
(Note that the different plotting areas are identified 
	by alternating white and gray backgrounds.) 

</emphasis>
 

</item>


	

<item id="li1116">
xTicInt - The distance between tic marks on the x-axis.

</item>


	

<item id="li1117">
yTicInt - The distance between tic marks on the y-axis.

</item>


	

<item id="li1118">
xCalcInc - The distance between the points on the x-axis where values 
	for y are computed. 

<emphasis id="em1023" effect="italics">
(Unless your data-generator program is taking too long 
	to run, you should probably leave this set to 1.0 in order to get the best 
	quality plots.) 

</emphasis>
 

</item>




</list>




</section>
<section id="h41002">
<title>
The labels on the axes 

</title>




<para id="p1041">
Each x-axis has a label at the left end and the right end. Similarly, each 
y-axis has a label at the bottom and the top. These labels represent the values 
at the extreme ends of the axes. For example in 

<link id="a1133" target-id="Figure_2">

Figure 2

</link>

, the label 800 appears 
at the right end of each x-axis. This is value of the x-axis where the axis 
intersects the border of the frame.

</para>





</section>
<section id="h41003">
<title>
Keep the pixels in mind 

</title>




<para id="p1042">
When adjusting the plotting parameters, keep in mind that the total width of 
each of the plotting areas is slightly less than 400 pixels.

</para>





<quote id="blockquote1006" display="block">

	

<para id="p1043">
<emphasis id="em1024" effect="italics">
(You can easily increase this to full screen width by changing one value 
	in the 

</emphasis>
<emphasis id="strong1025" effect="bold">
<emphasis id="em1025" effect="italics">
Graph01

</emphasis>
</emphasis>
<emphasis id="em1026" effect="italics">
 program and recompiling 
	the program. However, I had to keep it narrow in order to publish the images 
	in this publication format.)

</emphasis>
</para>





</quote>




<para id="p1044">
While you can theoretically make the horizontal expanse of the x-axes as wide 
as you wish, because of the pixel limitation, you cannot see details that 
require a resolution greater than the number of pixels along the x-axis. 

<emphasis id="em1027" effect="italics">
(This 
might be a good reason for you to modify 
the 

</emphasis>
<emphasis id="strong1026" effect="bold">
<emphasis id="em1028" effect="italics">
Graph01

</emphasis>
</emphasis>
<emphasis id="em1029" effect="italics">
 program as described above). 

</emphasis>
 

</para>





</section>
</section>
<section id="h31003">
<title>
<emphasis id="The_interface_named_GraphIntfc01" effect="bold">

The interface named GraphIntfc01

</emphasis>

 


</title>




<para id="p1045">
Regardless of the simplicity or complexity of your data-generator program, there are only two 
requirements for your program to operate successfully with the 
plotting program named 

<emphasis id="strong1027" effect="bold">
Graph01

</emphasis>
:

</para>





<list id="ol1000" list-type="enumerated">

	

<item id="li1119">
It must implement the interface named 

<emphasis id="strong1028" effect="bold">
GraphIntfc01

</emphasis>
.

</item>


	

<item id="li1120">
It must have a constructor that doesn't require any parameters 

<emphasis id="em1030" effect="italics">
(the 
	default constructor will satisfy that requirement if you don't need another 
	constructor)

</emphasis>
. 

</item>




</list>




<section id="h41004">
<title>
Implementing GraphIntfc01 

</title>




<para id="p1046">
All that is required to implement the interface is to define a class that 
provides a concrete definition for each of the six methods declared in 

<link id="a1134" target-id="Listing_1">

Listing 1

</link>

.

</para>



	


<table id="table1002" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1002">
<row id="tr1004">



<entry id="th1002">
<emphasis id="Listing_1" effect="bold">

Listing 1.

</emphasis>

 Source code for GraphIntfc01.java.


</entry>
</row>
</thead>


<tbody id="tbody1002">
<row id="tr1005">
<entry id="td1002">



<code id="pre1002" display="block">public interface GraphIntfc01{
  public int getNmbr();
  public double f1(double x);
  public double f2(double x);
  public double f3(double x);
  public double f4(double x);
  public double f5(double x);
}//end GraphIntfc01</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h41005">
<title>
The method named getNmbr

</title>


	
	

<para id="p1047">
On several occasions in this module, I have stated that the plotting 
	program can plot up to five functions. However, it doesn't have to plot all 
	five functions. The plotting program can be used 

<emphasis id="em1031" effect="italics">
(without modification)

</emphasis>
 
	to plot any number of functions from one to five.

</para>





<para id="p1048">
The method named 

<emphasis id="strong1029" effect="bold">
getNmbr

</emphasis>
, that you must define in your data-generator program, must return an integer value 
between 1 and 5 that specifies the number of functions to be plotted. The 
plotting program uses that value to divide the total plotting surface into the 
specified number of plotting areas, and plots each of the functions named 


<emphasis id="strong1030" effect="bold">
f1

</emphasis>
 
through 

<emphasis id="strong1031" effect="bold">
fn

</emphasis>
 in one of those plotting areas.

</para>





</section>
<section id="h41006">
<title>
The methods named f1, f2, f3, f4, and f5 

</title>




<para id="p1049">
As you can see in 

<link id="a1135" target-id="Listing_1">

Listing 1

</link>

, each of these methods receives a 

<emphasis id="strong1032" effect="bold">
double

</emphasis>
 value as 
an incoming parameter and returns a 

<emphasis id="strong1033" effect="bold">
double

</emphasis>
 value. In essence, each of these 
methods receives a value for 

<emphasis id="strong1034" effect="bold">
x

</emphasis>
 and returns the corresponding value for 


<emphasis id="strong1035" effect="bold">
y

</emphasis>
.

</para>





</section>
<section id="h41007">
<title>
One plotting area per method 

</title>




<para id="p1050">
Each of these methods provides the data to be plotted in one plotting area. 
The method named 

<emphasis id="strong1036" effect="bold">
f1

</emphasis>
 provides the data for the top plotting area, the method 
named 

<emphasis id="strong1037" effect="bold">
f2

</emphasis>
 provides the data for the first plotting area down from the top, and so 
forth.

</para>





<quote id="blockquote1007" display="block">

	

<para id="p1051">
<emphasis id="em1032" effect="italics">
(For example, if the 

</emphasis>
<emphasis id="strong1038" effect="bold">
<emphasis id="em1033" effect="italics">
getNmbr

</emphasis>
</emphasis>
<emphasis id="em1034" effect="italics">
 method returns a value of 4, the method 
	named 

<emphasis id="strong1039" effect="bold">
f5

</emphasis>
 will never be called. If 

<emphasis id="strong1040" effect="bold">
getNmbr

</emphasis>
 returns 5, the method named 
	

<emphasis id="strong1041" effect="bold">
f5

</emphasis>
 
	will be called to provide the data for the bottom plotting area.) 

</emphasis>
 

</para>





</quote>




</section>
<section id="h41008">
<title>
How does it work? 

</title>




<para id="p1052">
Each plotting area contains a horizontal axis. The plotting program moves 
across the horizontal axis in each plotting area one step at a time 

<emphasis id="em1035" effect="italics">
(moving in 
incremental steps equal to the plotting parameter named 

<emphasis id="strong1042" effect="bold">
xCalcInc

</emphasis>
)

</emphasis>
. 

</para>





<para id="p1053">
At each step along the way, the plotting program calls the method 
associated with that plotting area, 

<emphasis id="em1036" effect="italics">
(

</emphasis>
<emphasis id="strong1043" effect="bold">
<emphasis id="em1037" effect="italics">
f1

</emphasis>
</emphasis>
<emphasis id="em1038" effect="italics">
, 


</emphasis>
<emphasis id="strong1044" effect="bold">
<emphasis id="em1039" effect="italics">
f2

</emphasis>
</emphasis>
<emphasis id="em1040" effect="italics">
, etc.)

</emphasis>
, passing the horizontal 
position as a parameter to the method.

</para>





<para id="p1054">
The value returned by the method is assumed to be the vertical value 
associated with that horizontal position, and that is the vertical value that is 
plotted for that horizontal position.

</para>





</section>
<section id="h41009">
<title>
Doesn't know and doesn't care 

</title>




<para id="p1055">
The plotting program doesn't know, and doesn't care how the method decides on 
the value to return for each value that it receives as an incoming parameter. 
The plotting program simply calls the methods to get the data, and then plots 
the data.

</para>





</section>
<section id="h41010">
<title>
Computed "on the fly" 

</title>




<para id="p1056">
For example, the returned values could be computed and returned "on the fly" 
as is the case in the sample program named 

<emphasis id="strong1045" effect="bold">
Graph01Demo

</emphasis>
, which we will look at shortly.

</para>





</section>
<section id="h41011">
<title>
Returned from an array 

</title>




<para id="p1057">
On the other hand, the values could have been computed earlier and saved in 
an array, as will be the case in the sample program named 

<emphasis id="strong1046" effect="bold">
Dsp002

</emphasis>
 example that we will look at later.

</para>





</section>
<section id="h41012">
<title>
From a disk file, a database, the internet, etc. 

</title>




<para id="p1058">
The returned values could be read from a disk file, obtained from a database 
on another computer, or obtained from any other source such as another computer 
on the internet. All that matters is that when the plotting program named


<emphasis id="strong1047" effect="bold">
Graph01

</emphasis>
 calls one of the five 
methods named 

<emphasis id="strong1048" effect="bold">
f1

</emphasis>
 through 

<emphasis id="strong1049" effect="bold">
f5

</emphasis>
, passing a 

<emphasis id="strong1050" effect="bold">
double

</emphasis>
 value as a parameter, it expects 
to receive a 

<emphasis id="strong1051" effect="bold">
double

</emphasis>
 value as a return value, and it will plot the value that it 
receives.

</para>





</section>
<section id="h41013">
<title>
It is up to you 

</title>




<para id="p1059">
It is up to you, the author of the data-generator program, to decide how you 
will implement the methods named 

<emphasis id="strong1052" effect="bold">
f1

</emphasis>
 through 

<emphasis id="strong1053" effect="bold">
f5

</emphasis>
. In some cases, the 
implementation may be simple. In other cases, the implementation may be more 
complex. The first case that we will examine, 

<emphasis id="strong1054" effect="bold">
Graph01Demo

</emphasis>
, is very simple. A subsequent case,


<emphasis id="strong1055" effect="bold">
Dsp002

</emphasis>
, is not so simple.

</para>





</section>
</section>
</section>
<section id="h21006">
<title>
<emphasis id="The_class_named_Graph01Demo" effect="bold">

The class named Graph01Demo

</emphasis>

 

</title>




<para id="p1060">
Although this is a very simple class definition, I am going to break it down 
and discuss it in fragments in order to help you focus your attention on the 
important points. A complete listing of the class definition is shown in 


<link id="a1136" target-id="Listing_37">

 Listing 37

</link>

 near the end of the module.

</para>





<section id="h31004">
<title>
<emphasis id="Defining_data-generator_classes" effect="bold">

Defining data-generator classes

</emphasis>

 

</title>




<para id="p1061">
This class named 

<emphasis id="strong1056" effect="bold">
Graph01Demo

</emphasis>
 is used to demonstrate how to write data-generator classes that 
will operate successfully with the program named 

<emphasis id="strong1057" effect="bold">
Graph01

</emphasis>
.

</para>





<quote id="blockquote1008" display="block">

	

<para id="p1062">
<emphasis id="em1041" effect="italics">
(

<link id="a1137" target-id="Figure_1">

Figure 1

</link>

 shows the display of the data produced by this class. You might 
	want to refer to that figure while examining the code in this class.) 

</emphasis>
 

</para>





</quote>




<para id="p1063">
<link id="a1138" target-id="Listing_2">

Listing 2

</link>

 shows the beginning of the class definition, which names the class 


<emphasis id="strong1058" effect="bold">
Graph01Demo

</emphasis>
, 
and specifies that the class implements the interface named 

<emphasis id="strong1059" effect="bold">
GraphIntfc01

</emphasis>
.

</para>



	


<table id="table1003" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1003">
<row id="tr1006">



<entry id="th1003">
<emphasis id="Listing_2" effect="bold">

Listing 2.

</emphasis>

 Beginning of the class named Graph01Demo.


</entry>
</row>
</thead>


<tbody id="tbody1003">
<row id="tr1007">
<entry id="td1003">

		

<code id="pre1003" display="block">class Graph01Demo implements GraphIntfc01{</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31005">
<title>
<emphasis id="The_number_of_functions_to_plot_" effect="bold">

The number of functions to plot


</emphasis>


</title>




<para id="p1064">
<link id="a1139" target-id="Listing_3">

Listing 3

</link>

 shows the entire listing of the method named 

<emphasis id="strong1060" effect="bold">
getNmbr

</emphasis>
.

</para>





<table id="table1004" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1004">
<row id="tr1008">



<entry id="th1004">
<emphasis id="Listing_3" effect="bold">

Listing 3.

</emphasis>

 The method named getNmbr.


</entry>
</row>
</thead>


<tbody id="tbody1004">
<row id="tr1009">
<entry id="td1004">



<code id="pre1004" display="block">  public int getNmbr(){
    return 5;
  }//end getNmbr</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1065">
Recall from the earlier discussion that the method named 

<emphasis id="strong1061" effect="bold">
getNmbr

</emphasis>
 
must return an integer value between 1 and 5, which tells the plotting program 
named 

<emphasis id="strong1062" effect="bold">
Graph01

</emphasis>
 how many functions to plot.

</para>





<para id="p1066">
This demonstration plots all five functions, as shown in 

<link id="a1140" target-id="Figure_1">

Figure 1

</link>

, so this 
method returns the value 5.

</para>





</section>
<section id="h31006">
<title>
<emphasis id="Themethodnamedf1" effect="bold">

The method named f1

</emphasis>


</title>




<para id="p1067">
<link id="a1141" target-id="Listing_4">

Listing 4

</link>

 shows the entire method named 

<emphasis id="strong1063" effect="bold">
f1

</emphasis>
. The output from this method is plotted in the 
topmost plotting area of the display in 

<link id="a1142" target-id="Figure_1">

Figure 1

</link>

. 

<emphasis id="em1042" effect="italics">
(This is the area at the top 
with the white background.) 

</emphasis>
 

</para>





<table id="table1005" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1005">
<row id="tr1010">



<entry id="th1005">
<emphasis id="Listing_4" effect="bold">

Listing 4.

</emphasis>

 The method named f1.


</entry>
</row>
</thead>


<tbody id="tbody1005">
<row id="tr1011">
<entry id="td1005">



<code id="pre1005" display="block">  public double f1(double x){
    return -(x*x)/200.0;
  }//end f1</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1068">
This method receives an incoming parameter known locally as 

<emphasis id="strong1064" effect="bold">
x

</emphasis>
.


<emphasis id="em1043" effect="italics">
(Computations are performed on the fly by all five data-generator methods 
defined in this class.)

</emphasis>
 The method computes and returns the negative square 
of the incoming parameter 

<emphasis id="em1044" effect="italics">
(divided by 200)

</emphasis>
. This produces the inverted 
bowl shape at the top of 

<link id="a1143" target-id="Figure_1">

Figure 1

</link>

.

</para>





</section>
<section id="h31007">
<title>
<emphasis id="The_method_named_f2" effect="bold">

The method named f2

</emphasis>


</title>




<para id="p1069">
The curve plotted in the top-most plotting area with the gray background in 


<link id="a1144" target-id="Figure_1">

Figure 1

</link>

 is produced by the method named 

<emphasis id="strong1065" effect="bold">
f2

</emphasis>
, which is shown in 
its entirety in 

<link id="a1145" target-id="Listing_5">

Listing 5

</link>

.

</para>





<table id="table1006" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1006">
<row id="tr1012">



<entry id="th1006">
<emphasis id="Listing_5" effect="bold">

Listing 5.

</emphasis>

 The method named f2.


</entry>
</row>
</thead>


<tbody id="tbody1006">
<row id="tr1013">
<entry id="td1006">



<code id="pre1006" display="block">  public double f2(double x){
    return -(x*x*x)/200.0;
  }//end f2</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1070">
As before, this function receives an incoming parameter known locally as


<emphasis id="strong1066" effect="bold">
x

</emphasis>
. The function computes and returns the negative cube of the 
incoming parameter 

<emphasis id="em1045" effect="italics">
(divided by 200)

</emphasis>
. This produces the curve shown in 
the top-most gray area of 

<link id="a1146" target-id="Figure_1">

Figure 1

</link>

.

</para>





</section>
<section id="h31008">
<title>
<emphasis id="The_method_named_f3" effect="bold">

The method named f3

</emphasis>


</title>




<para id="p1071">
The method named 

<emphasis id="strong1067" effect="bold">
f3

</emphasis>
, shown in 

<link id="a1147" target-id="Listing_6">

Listing 6

</link>

, produces the curve 
shown in the center plotting area with the white background in 

<link id="a1148" target-id="Figure_1">

Figure 1

</link>

.

</para>






<table id="table1007" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1007">
<row id="tr1014">



<entry id="th1007">
<emphasis id="Listing_6" effect="bold">

Listing 6.

</emphasis>

 The method named f3.


</entry>
</row>
</thead>


<tbody id="tbody1007">
<row id="tr1015">
<entry id="td1007">



<code id="pre1007" display="block">  public double f3(double x){
    return 100*Math.cos(x/10.0);
  }//end f3</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1072">
This is a simple cosine curve, which is computed on the fly. Each time the 
method is called, the incoming parameter named 

<emphasis id="strong1068" effect="bold">
x

</emphasis>
 is used to 
calculate the cosine of an angle in radians given by one-tenth the value of


<emphasis id="strong1069" effect="bold">
x

</emphasis>
. The cosine of that angle is multiplied by 100 and returned.

</para>





<quote id="blockquote1009" display="block">

	

<para id="p1073">
<emphasis id="em1046" effect="italics">
(Note that the cosine of the angle is computed using a static method 
	of the standard Java class named 

</emphasis>
<emphasis id="strong1070" effect="bold">
<emphasis id="em1047" effect="italics">
Math

</emphasis>
</emphasis>
<emphasis id="em1048" effect="italics">
. 
	This is the class that contains the Java math library.) 

</emphasis>
</para>





</quote>




</section>
<section id="h31009">
<title>
<emphasis id="The_method_named_f4" effect="bold">

The method named f4

</emphasis>

 

</title>




<para id="p1074">
The curve shown in the bottom-most gray plotting area of 

<link id="a1149" target-id="Figure_1">

Figure 1

</link>

 is produced 
by the method named 

<emphasis id="strong1071" effect="bold">
f4

</emphasis>
, shown in 

<link id="a1150" target-id="Listing_7">

Listing 7

</link>

.

</para>






<table id="table1008" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1008">
<row id="tr1016">



<entry id="th1008">
<emphasis id="Listing_7" effect="bold">

Listing 7.

</emphasis>

 The method named f4.


</entry>
</row>
</thead>


<tbody id="tbody1008">
<row id="tr1017">
<entry id="td1008">



<code id="pre1008" display="block">  public double f4(double x){
    return 100*Math.sin(x/20.0);
  }//end f4</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1075">
The body of the method named 

<emphasis id="strong1072" effect="bold">
f4

</emphasis>
 is similar to the body of 
the method named 

<emphasis id="strong1073" effect="bold">
f3

</emphasis>
, except that 

<emphasis id="strong1074" effect="bold">
f4

</emphasis>
 computes 
and returns sine values instead of cosine values. Also, the value of 

<emphasis id="strong1075" effect="bold">
x

</emphasis>
 
is used differently so that the period of the curve produced by 

<emphasis id="strong1076" effect="bold">
f4

</emphasis>
 
is twice the period of the curve produced by 

<emphasis id="strong1077" effect="bold">
f3

</emphasis>
.

</para>





</section>
<section id="h31010">
<title>
<emphasis id="The_method_named_f5" effect="bold">

The method named f5

</emphasis>

 

</title>




<para id="p1076">
Finally, the bottom white plotting area in 

<link id="a1151" target-id="Figure_1">

Figure 1

</link>

 shows the output produced 
by the method named 

<emphasis id="strong1078" effect="bold">
f5

</emphasis>
, which is shown in 

<link id="a1152" target-id="Listing_8">

Listing 8

</link>

.

</para>






<table id="table1009" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1009">
<row id="tr1018">



<entry id="th1009">
<emphasis id="Listing_8" effect="bold">

Listing 8.

</emphasis>

 The method named f5.


</entry>
</row>
</thead>


<tbody id="tbody1009">
<row id="tr1019">
<entry id="td1009">



<code id="pre1009" display="block">  public double f5(double x){
    return 100*(Math.sin(x/20.0)*Math.cos(x/10.0));
  }//end f5</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1077">
This method computes and returns the product of sine and cosine functions 
identical to those discussed above.

</para>





</section>
<section id="h31011">
<title>
<emphasis id="The_end_of_the_class_definition" effect="bold">

The end of the class definition

</emphasis>




</title>




<para id="p1078">
<link id="a1153" target-id="Listing_8">

Listing 8

</link>

 also shows the closing curly brace that signifies the end of the 
class definition for the class named 

<emphasis id="strong1079" effect="bold">
Graph01Demo

</emphasis>
.

</para>





<para id="p1079">
That's really all that you need to know to be able to make effective use of 
the generalized plotting program named 

<emphasis id="strong1080" effect="bold">
Graph01

</emphasis>
. If you can 
define the methods named 

<emphasis id="strong1081" effect="bold">
f1

</emphasis>
 through 

<emphasis id="strong1082" effect="bold">
f5

</emphasis>
, which 
will return the required values for your computational experiment, then you can 
make use of this program to plot your data.

</para>





</section>
</section>
<section id="h21007">
<title>
<emphasis id="The_class_named_Dsp002" effect="bold">

The class named Dsp002

</emphasis>


</title>




<para id="p1080">
Lest you go away believing that this is all too trivial to be interesting, I 
am going to show you another example that is far from trivial. In the next 
example, I will demonstrate two of the most important operations in the field 
commonly referred to as digital signal processing, or DSP for short.

</para>





<para id="p1081">
Because many of you are unlikely to be familiar with the techniques and 
terminology involved, the discussion will of necessity be fairly shallow. 
However, I do want to show at least one example of how you can perform 
substantive computational experiments using this approach.

</para>





<section id="h31012">
<title>
<emphasis id="A_DSP_example_" effect="bold">

A DSP example 

</emphasis>


</title>




<para id="p1082">
A DSP example involving convolution filtering and spectral analysis is shown in 


<link id="a1154" target-id="Figure_3">

Figure 3

</link>

.

</para>







<table id="table1010" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1010">
<row id="tr1020">
<entry id="th1010">



<emphasis id="Figure_3" effect="bold">

Figure 3.

</emphasis>

 A Digital Signal Processing (DSP) Example.


</entry>
</row>
</thead>


<tbody id="tbody1010">
<row id="tr1021">
<entry id="td1010">



<media id="media1002" alt="missing image" display="block">
<image id="img1002" mime-type="image/gif" src="../../media/java1468c.gif" width="401" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<para id="p1083">
In the field of DSP, the five individual plots shown in the plotting areas of 


<link id="a1155" target-id="Figure_3">

Figure 3

</link>

 are commonly referred to as traces. I will use that terminology in this 
discussion.

</para>





<section id="h41014">
<title>
White random noise 

</title>




<para id="p1084">
The top trace in the area with the white background shows about 256 samples 
of white random noise. When we get to the code, we will see that this data was 
created using a Java pseudo-random number generator.

</para>





</section>
<section id="h41015">
<title>
A convolution filter 

</title>




<para id="p1085">
The second trace from the top shows a 33-point narrow-band convolution 
filter, which is simply a chunk taken out of a sinusoid whose frequency is 
one-fourth the sampling frequency. In other words, the sinusoid is represented 
by four samples per cycle.

</para>





</section>
<section id="h41016">
<title>
The convolution filter output 

</title>




<para id="p1086">
The middle trace shows the result of applying the narrow-band convolution 
filter to the white noise. The output from the convolution process was amplified 
to bring it back into an appropriate amplitude range for visual analysis.

</para>





<para id="p1087">
If you compare the middle trace with the top trace, you will notice that much 
of the high-frequency energy and much of the low-frequency energy has been 
removed. Most of the energy in the middle trace appears to be about the same 
frequency as the design frequency of the convolution filter 

<emphasis id="em1049" effect="italics">
(which is what 
we would expect)

</emphasis>
. 

</para>





</section>
<section id="h41017">
<title>
Time-domain vs. frequency-domain 

</title>




<para id="p1088">
The top three traces represent information in the time domain. The bottom two 
traces represent information in the frequency domain.

</para>





<quote id="blockquote1010" display="block">

	

<para id="p1089">
<emphasis id="em1050" effect="italics">
(Think of the frequency domain as the information that is visible on 
	many audio systems, consisting of parallel vertical bars with lights that 
	dance up and down. These lights are often associated with a device referred 
	to as a frequency equalizer. When the music contains a lot of drums, or 
	other sounds at the bass end, the lights at the low (usually left) end of 
	the frequency spectrum are very active. When the music contains a lot of 
	symbols, or sounds at the treble end, the lights at the high (right) end of 
	the frequency spectrum are very active. That is a form of real-time spectrum 
	analysis.) 

</emphasis>
</para>





</quote>




</section>
<section id="h41018">
<title>
Frequency spectrum analysis 

</title>




<para id="p1090">
The two bottom traces in 

<link id="a1156" target-id="Figure_3">

Figure 3

</link>

 result from performing frequency spectrum 
analysis on the top trace and the middle trace respectively.

</para>





</section>
<section id="h41019">
<title>
The white noise spectrum 

</title>




<para id="p1091">
The trace in the gray area immediately below the center is an estimate of the 
spectral distribution of the white noise in the top trace. The spectrum analysis 
was performed across the frequency range from zero frequency to the sampling 
frequency.

</para>





<para id="p1092">
While not perfectly flat, as would be the case for perfectly white noise, you 
can see that the energy appears to be distributed across that entire range.

</para>





<quote id="blockquote1011" display="block">

	

<para id="p1093">
<emphasis id="em1051" effect="italics">
(If we wanted to improve our estimate, we could capture and analyze a 
	much longer sample of the white noise.)

</emphasis>
 

</para>





</quote>




<para id="p1094">
If you examine this trace carefully, you might notice that there is a point 
of near symmetry in the middle. The values that you see above that point 

<emphasis id="em1052" effect="italics">

(the folding frequency)

</emphasis>
 are a mirror-image of the values that you see below 
that point. 

<emphasis id="em1053" effect="italics">
(I will have more to say about this later.) 

</emphasis>
</para>





</section>
<section id="h41020">
<title>
The filtered noise spectrum 

</title>




<para id="p1095">
The bottom trace shows an estimate of the spectral distribution of the 
filtered noise in the center trace. Again, the spectrum analysis was performed 
across the frequency range from zero frequency to the sampling frequency. Again 
also, there is a symmetry point in the middle with everything to the right of 
that point being a mirror image of everything to the left of that point.

</para>





</section>
<section id="h41021">
<title>
Two spectral peaks are visible 

</title>




<para id="p1096">
Unlike the spectral analysis of the white noise, this spectral analysis shows 
two obvious peaks. One peak appears at one-fourth the sampling frequency, and 
the other peak appears at three-fourths the sampling frequency.

</para>





<para id="p1097">
In other words, as we concluded from examining the center trace, the 
filtering process removed much of the energy above and below the design 
frequency of the convolution filter.

</para>





<quote id="blockquote1012" display="block">

	

<para id="p1098">
<emphasis id="em1054" effect="italics">
(By changing the design frequency of the convolution filter, and 
	repeating the process, we could move this peak up or down along the 
	frequency axis.)

</emphasis>
 

</para>





</quote>




</section>
<section id="h41022">
<title>
What does the symmetry mean? 

</title>




<para id="p1099">
Without getting into a lot of detail at this point, the point of symmetry 
that I identified above is known as the Nyquist folding frequency. 

<emphasis id="em1055" effect="italics">
(See the 
earlier module titled 


<link id="a1157" url="http://cnx.org/contents/0d7ff757-3804-403b-8288-35d9cf8d08df/Dsp00104-Sampled-Time-Series#The_Nyquist_folding_frequency">

Dsp00104-Sampled Time Series

</link>

.)

</emphasis>
</para>





<para id="p1100">
In order to be able to identify the frequency of a sine wave, you must have 
at least two samples per cycle of the sine wave. The Nyquist folding frequency 
is the frequency at which you have exactly two samples per cycle.

</para>





<para id="p1101">
As the frequency of the sine wave continues to increase beyond that point, 
without a corresponding change in the sampling frequency, it is impossible to 
determine from the samples so obtained whether the frequency is increasing or 
decreasing.

</para>





</section>
<section id="h41023">
<title>
An ambiguity in the spectrum analysis 

</title>




<para id="p1102">
As a result, the spectrum analysis process was unable to determine if the 
peak in the frequency spectrum was below or above the folding frequency. Thus, 
the bottom trace in 

<link id="a1158" target-id="Figure_3">

Figure 3

</link>

 shows two peaks which are mirror images of one 
another with the folding frequency being half way between the two peaks.

</para>





<quote id="blockquote1013" display="block">

	

<para id="p1103">
<emphasis id="em1056" effect="italics">
(As a practical matter, when doing spectrum analysis, there is no point 
	in computing the values above the folding frequency. I did that here just to 
	illustrate that there is a folding frequency, which is equal to one-half the 
	sampling frequency.)

</emphasis>
 

</para>





</quote>




</section>
<section id="h41024">
<title>
Let's see some code 

</title>




<para id="p1104">
The class used to produce the data displayed in 

<link id="a1159" target-id="Figure_3">

Figure 3

</link>

 is named 

<emphasis id="strong1083" effect="bold">
Dsp002

</emphasis>
. A 
complete listing of this class definition is shown in 

<link id="a1160" target-id="Listing_38">

Listing 38

</link>

 near the end of 
the module.

</para>





<para id="p1105">
I will break this class down into fragments and briefly discuss it to show how 
you can define significant classes and easily connect them to the generalized 
plotting program named 

<emphasis id="strong1084" effect="bold">
Graph01

</emphasis>
.

</para>





<para id="p1106">
As before, having compiled the class named 

<emphasis id="strong1085" effect="bold">
Dsp002

</emphasis>
, you would exercise it by 
entering the following at a command prompt:

</para>





<code id="pre1010" display="block">java Graph01 Dsp002 </code>




</section>
<section id="h41025">
<title>
Different from the previous example class 

</title>




<para id="p1107">
This class differs from the class named 

<emphasis id="strong1086" effect="bold">
Graph01Demo

</emphasis>
 in one very significant 
way. In that class, all the values returned by the methods named 

<emphasis id="strong1087" effect="bold">
f1

</emphasis>
 through 


<emphasis id="strong1088" effect="bold">
f5

</emphasis>
 
were computed 

<emphasis id="em1057" effect="italics">
on the fly

</emphasis>
 as the methods were called.

</para>





<para id="p1108">
In this new class named 

<emphasis id="strong1089" effect="bold">
Dsp002

</emphasis>
, all the data is generated and stored in array 
objects when an object of the class named 

<emphasis id="strong1090" effect="bold">
Dsp002

</emphasis>
 is instantiated. When the 
methods named 

<emphasis id="strong1091" effect="bold">
f1

</emphasis>
 through 

<emphasis id="strong1092" effect="bold">
f5

</emphasis>
 are called later, they simply retrieve the data from 
the array objects and return that data to the plotting program.

</para>





</section>
<section id="h41026">
<title>
Basic operation of the program 

</title>




<para id="p1109">
As mentioned earlier, this program applies a narrow-band convolution filter 
to white noise, and then computes the amplitude spectrum of the filtered noise 
using a

<emphasis id="em1058" effect="italics">
 Discrete Fourier Transform (DFT)

</emphasis>
 algorithm. The spectrum of the white 
noise is also computed. All of the processing occurs when an object of the class 
is instantiated, and the processed results are saved in arrays.

</para>





<para id="p1110">
The input noise, the filter, the filtered output, and the two spectra are 
deposited in five arrays for later retrieval and display. The data in the five 
arrays are returned by the methods named 

<emphasis id="strong1093" effect="bold">
f1

</emphasis>
, 

<emphasis id="strong1094" effect="bold">
f2

</emphasis>
, 


<emphasis id="strong1095" effect="bold">
f3

</emphasis>
, 

<emphasis id="strong1096" effect="bold">
f4

</emphasis>
, and 

<emphasis id="strong1097" effect="bold">
f5

</emphasis>
 respectively.

</para>





<para id="p1111">
The values that are returned by the methods are scaled for appropriate 
display in the plotting areas provided by the program named 

<emphasis id="strong1098" effect="bold">
Graph01

</emphasis>
.

</para>





</section>
</section>
<section id="h31013">
<title>
<emphasis id="Beginning_of_the_class_named_Dsp002" effect="bold">

Beginning of the class named 
Dsp002

</emphasis>


</title>




<para id="p1112">
The code in 

<link id="a1161" target-id="Listing_9">

Listing 9

</link>

 establishes the data lengths for the white noise, the 
convolution filter, the filtered output, and the spectrum.

</para>






<table id="table1011" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1011">
<row id="tr1022">



<entry id="th1011">
<emphasis id="Listing_9" effect="bold">

Listing 9.

</emphasis>

 Beginning of the class named Dsp002.


</entry>
</row>
</thead>


<tbody id="tbody1011">
<row id="tr1023">
<entry id="td1011">



<code id="pre1011" display="block">class Dsp002 implements GraphIntfc01{
  int operatorLen = 33;
  int dataLen = 256+operatorLen;
  int outputLen = dataLen - operatorLen;
  int spectrumPts = outputLen;</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31014">
<title>
<emphasis id="Create_data_arrays_" effect="bold">

Create data arrays 

</emphasis>


</title>




<para id="p1113">
The code in 

<link id="a1162" target-id="Listing_10">

Listing 10

</link>

 creates the array objects that will be used to store 
the data until it is retrieved by the methods named 

<emphasis id="strong1099" effect="bold">
f1

</emphasis>
 through


<emphasis id="strong1100" effect="bold">
f5

</emphasis>
.

</para>






<table id="table1012" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1012">
<row id="tr1024">



<entry id="th1012">
<emphasis id="Listing_10" effect="bold">

Listing 10.

</emphasis>

 Create data arrays.

</entry>
</row>
</thead>


<tbody id="tbody1012">
<row id="tr1025">
<entry id="td1012">



<code id="pre1012" display="block">  double[] data = new double[dataLen];
  double[] operator =
               new double[operatorLen];
  double[] output =
                 new double[outputLen];
  double[] spectrumA =
               new double[spectrumPts];
  double[] spectrumB =
               new double[spectrumPts];</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31015">
<title>
<emphasis id="Beginning_of_the_constructor" effect="bold">

Beginning of the constructor

</emphasis>

 

</title>




<para id="p1114">
Most of the hard work is done by the constructor or by methods called by the 
constructor.

</para>





<para id="p1115">
The code in 

<link id="a1163" target-id="Listing_11">

Listing 11

</link>

 shows the beginning of the constructor for the class. 
This code generates and saves the white noise in the array object named 

<emphasis id="strong1101" effect="bold">

data

</emphasis>
.

</para>





<table id="table1013" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1013">
<row id="tr1026">



<entry id="th1013">
<emphasis id="Listing_11" effect="bold">

Listing 11.

</emphasis>

 Beginning of the constructor.

</entry>
</row>
</thead>


<tbody id="tbody1013">
<row id="tr1027">
<entry id="td1013">

		

<code id="pre1013" display="block">  public Dsp002(){//constructor
    Random generator = new Random(
                 new Date().getTime());
    for(int cnt=0;cnt &lt; data.length;
                                cnt++){
      //Get data, scale it, remove the
      // dc offset, and save it.
      data[cnt] = 100*generator.
                       nextDouble()-50;
    }//end for loop</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41027">
<title>
The random noise generator seed 

</title>




<para id="p1116">
Note that by virtue of the way this white noise is being generated, a 
different seed is passed to the constructor for the 

<emphasis id="strong1102" effect="bold">
Random

</emphasis>
 
class each time an object of the 

<emphasis id="strong1103" effect="bold">
Dsp002

</emphasis>
 class is instantiated. 
Thus, each new object presents different random noise.

</para>





<quote id="blockquote1014" display="block">

	

<para id="p1117">
<emphasis id="em1059" effect="italics">
(In some cases, this may not be desirable and it may be preferable to 
	use the same seed each time an object is instantiated.)

</emphasis>
 

</para>





</quote>




</section>
</section>
<section id="h31016">
<title>
<emphasis id="Create_the_convolution_operator_" effect="bold">

Create the convolution operator


</emphasis>


</title>




<para id="p1118">
The code in 

<link id="a1164" target-id="Listing_12">

Listing 12

</link>

 creates the 33-point convolution operator, as a 
segment of a cosine wave, and saves it in the designated array.

</para>





<table id="table1014" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1014">
<row id="tr1028">



<entry id="th1014">
<emphasis id="Listing_12" effect="bold">

Listing 12.

</emphasis>

 Create the convolution operator.

</entry>
</row>
</thead>


<tbody id="tbody1014">
<row id="tr1029">
<entry id="td1014">

		

<code id="pre1014" display="block">    for(int cnt = 0; cnt &lt; operatorLen;
                                cnt++){
      operator[cnt] = Math.cos(
                      cnt*2*Math.PI/4);
    }//end for loop</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1119">
Note that the constant value of 4 in the denominator of the argument to the


<emphasis id="strong1104" effect="bold">
cos

</emphasis>
 method specifies the frequency of the cosine wave relative 
to the sampling frequency. 

<emphasis id="em1060" effect="italics">
(In this case, the frequency of the cosine wave 
is one-fourth the sampling frequency.) 

</emphasis>
</para>





</section>
<section id="h31017">
<title>
<emphasis id="Apply_the_convolution_operator_" effect="bold">

Apply the convolution operator 

</emphasis>




</title>




<para id="p1120">
The code in 

<link id="a1165" target-id="Listing_13">

Listing 13

</link>

 calls a static method named 

<emphasis id="strong1105" effect="bold">
convolve

</emphasis>
 in a class named 


<emphasis id="strong1106" effect="bold">
Convolve01

</emphasis>
 to apply the convolution operator to the white noise and save the 
filtered result in the appropriate array. I will briefly discuss this method 
later.

</para>





<table id="table1015" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1015">
<row id="tr1030">



<entry id="th1015">
<emphasis id="Listing_13" effect="bold">

Listing 13.

</emphasis>

 Apply the convolution operator.

</entry>
</row>
</thead>


<tbody id="tbody1015">
<row id="tr1031">
<entry id="td1015">



<code id="pre1015" display="block">    Convolve01.convolve(data,dataLen,
          operator,operatorLen,output);</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31018">
<title>
<emphasis id="Compute_spectrum_of_each_of_two_traces" effect="bold">

Compute spectrum of each of 
two traces

</emphasis>

 

</title>




<para id="p1121">
The code in 

<link id="a1166" target-id="Listing_14">

Listing 14

</link>

 calls a static method named 

<emphasis id="strong1107" effect="bold">
dft

</emphasis>
 of a class named 


<emphasis id="strong1108" effect="bold">
Dft01

</emphasis>
 
twice in succession to compute the spectra for the white noise and the filtered 
noise, and to save those spectra in the appropriate arrays.

</para>





<table id="table1016" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1016">
<row id="tr1032">



<entry id="th1016">
<emphasis id="Listing_14" effect="bold">

Listing 14.

</emphasis>

 Compute spectrum of each of two traces.

</entry>
</row>
</thead>


<tbody id="tbody1016">
<row id="tr1033">
<entry id="td1016">



<code id="pre1016" display="block">    Dft01.dft(data,spectrumPts,
                            spectrumA);
    Dft01.dft(output,spectrumPts,
                            spectrumB);
  }//end constructor</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41028">
<title>
All results have been computed and saved 

</title>




<para id="p1122">
That is the end of the constructor. At this point, all the results have been 
computed and saved in the appropriate arrays for later retrieval by the methods 
named 

<emphasis id="strong1109" effect="bold">
f1

</emphasis>
 through 

<emphasis id="strong1110" effect="bold">
f5

</emphasis>
.

</para>





<para id="p1123">
When the constructor finishes execution, the new object of the class named


<emphasis id="strong1111" effect="bold">
Dsp002

</emphasis>
 has been created and occupies memory. The array objects 
contained in the new object have been populated with five different types of 
data. That data is available to be retrieved and plotted.

</para>





</section>
</section>
<section id="h31019">
<title>
<emphasis id="The_getNmbr_method" effect="bold">

The getNmbr method

</emphasis>

 

</title>




<para id="p1124">
The class definition for the class named 

<emphasis id="strong1112" effect="bold">
Dsp002

</emphasis>
 contains 
several more methods that I need to explain. For example, the 

<emphasis id="strong1113" effect="bold">
getNmbr

</emphasis>
 
method for this class is exactly the same as for the class discussed earlier. As 
before, it returns the integer value 5, telling the plotting program that there 
are five plots to be generated. This method is shown in 

<link id="a1167" target-id="Listing_15">

Listing 15

</link>

.

</para>






<para id="p1125">
</para>





<table id="table1017" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1017">
<row id="tr1034">



<entry id="th1017">
<emphasis id="Listing_15" effect="bold">

Listing 15.

</emphasis>

 The getNmbr method.

</entry>
</row>
</thead>


<tbody id="tbody1017">
<row id="tr1035">
<entry id="td1017">

		

<code id="pre1017" display="block">  public int getNmbr(){
    return 5;
  }//end getNmbr</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31020">
<title>
<emphasis id="The_method_named_f1" effect="bold">

The method named f1

</emphasis>

 

</title>




<para id="p1126">
The method named 

<emphasis id="strong1114" effect="bold">
f1

</emphasis>
 is representative of all five of the 
methods named 

<emphasis id="strong1115" effect="bold">
f1

</emphasis>
 through 

<emphasis id="strong1116" effect="bold">
f5

</emphasis>
 in this class. 
Therefore, I will discuss only the first of the five methods in detail. The 
method named f1 is shown in its entirety in 

<link id="a1168" target-id="Listing_16">

Listing 16

</link>

.

</para>





<table id="table1018" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1018">
<row id="tr1036">



<entry id="th1018">
<emphasis id="Listing_16" effect="bold">

Listing 16.

</emphasis>

 The method named f1.

</entry>
</row>
</thead>


<tbody id="tbody1018">
<row id="tr1037">
<entry id="td1018">



<code id="pre1018" display="block">  public double f1(double x){
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
                index &gt; data.length-1){
      return 0;
    }else{
      return data[index];
    }//end else
  }//end f1</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1127">
In all five cases, the purpose of the method is to fetch and return a value 
from an array, where the incoming parameter will be converted to an array index.

</para>





<section id="h41029">
<title>
Convert incoming parameter to an index 

</title>




<para id="p1128">
The incoming parameter is received as type 

<emphasis id="strong1117" effect="bold">
double

</emphasis>
. However, 
an array must be indexed using type 

<emphasis id="strong1118" effect="bold">
int

</emphasis>
. The first statement in 
the method calls the 

<emphasis id="strong1119" effect="bold">
round

</emphasis>
 method of the 

<emphasis id="strong1120" effect="bold">
Math

</emphasis>
 
class to convert the 

<emphasis id="strong1121" effect="bold">
double

</emphasis>
 value to the nearest integer. That 
integer will be used as an array index.

</para>





</section>
<section id="h41030">
<title>
Stay within array bounds 

</title>




<para id="p1129">
Following this, the method applies some logic to confirm that the index value 
is within the bounds of the array. If not, the method returns the value 0.

</para>





<para id="p1130">
If the index is within the array bounds, the method retrieves and returns the 
value stored at that index location in the array.

</para>





<para id="p1131">
And that's all there is to it.

</para>





</section>
</section>
<section id="h31021">
<title>
<emphasis id="Methods_f2_through_f5_" effect="bold">

Methods f2 through f5 

</emphasis>


</title>




<para id="p1132">
Except for the scale factors applied to the data before returning it, the 
behavior of the methods named 

<emphasis id="strong1122" effect="bold">
f2

</emphasis>
 through 

<emphasis id="strong1123" effect="bold">
f5

</emphasis>
 is 
essentially the same as the behavior of the method named 

<emphasis id="strong1124" effect="bold">
f1

</emphasis>
. In 
each case, the method retrieves, scales, and returns a value previously stored 
in an array. Therefore, I won't discuss these other methods. You can view them 
in 

<link id="a1169" target-id="Listing_38">

Listing 38

</link>

 near the end of the module.

</para>





<para id="p1133">
And that ends the definition of the class named 

<emphasis id="strong1125" effect="bold">
Dsp002

</emphasis>
.

</para>





</section>
</section>
<section id="h21008">
<title>
<emphasis id="The_class_named_Convolve01" effect="bold">

The class named Convolve01

</emphasis>

 

</title>




<para id="p1134">
The entire class named 

<emphasis id="strong1126" effect="bold">
Convolve01

</emphasis>
 is shown in 

<link id="a1170" target-id="Listing_17">

Listing 17

</link>

.

</para>





<para id="p1135">
If you already understand convolution, you will probably find the code in 
this class straightforward. If not, the code will probably still be 
straightforward, but the reason for the code may be obscure.

</para>





<table id="table1019" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1019">
<row id="tr1038">



<entry id="th1019">
<emphasis id="Listing_17" effect="bold">

Listing 17.

</emphasis>

 The class named Convolve01.

</entry>
</row>
</thead>


<tbody id="tbody1019">
<row id="tr1039">
<entry id="td1019">

		

<code id="pre1019" display="block">class Convolve01{
  public static void convolve(
                     double[] data,
                     int dataLen,
                     double[] operator,
                     int operatorLen,
                     double[] output){
    //Apply the operator to the data,
    // dealing with the index
    // reversal required by
    // convolution.
    for(int i=0;
          i &lt; dataLen-operatorLen;i++){
      output[i] = 0;
      for(int j=operatorLen-1;j&gt;=0;
                                  j--){
        output[i] +=
                 data[i+j]*operator[j];
      }//end inner loop
    }//end outer loop
  }//end convolve method
}//end Class Convolve01</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1136">
To make a long story short, the class named 

<emphasis id="strong1127" effect="bold">
Convolve01

</emphasis>
 
provides a static method named 

<emphasis id="strong1128" effect="bold">
convolve

</emphasis>
, which applies an 
incoming convolution operator to an incoming set of data and deposits the 
filtered data in an output array whose reference is received as an incoming 
parameter.

</para>





<para id="p1137">
This class could easily be broken out and put in a library as a stand-alone 
class, or the 

<emphasis id="strong1129" effect="bold">
convolve

</emphasis>
 method could be added to a class 
containing a variety of DSP methods.

</para>





</section>
<section id="h21009">
<title>
<emphasis id="The_discrete_Fourier_transform" effect="bold">

The discrete Fourier transform

</emphasis>

 
(DFT) 

</title>




<para id="p1138">
The entire class named 

<emphasis id="strong1130" effect="bold">
Dft01

</emphasis>
 is shown in 

<link id="a1171" target-id="Listing_18">

Listing 18

</link>

.

</para>





<para id="p1139">
As with convolution, if you already understand the discrete Fourier 
transform, you will probably find the code in this class to be straightforward. 
If not, the code will probably still be straightforward, but the reasons for the 
code may be obscure. Since the purpose of this module is not to explain digital 
signal processing concepts, I won't attempt to provide a detailed explanation 
for the code in this method at this time.

</para>





<table id="table1020" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1020">
<row id="tr1040">



<entry id="th1020">
<emphasis id="Listing_18" effect="bold">

Listing 18.

</emphasis>

 The discrete Fourier transform (DFT).

</entry>
</row>
</thead>


<tbody id="tbody1020">
<row id="tr1041">
<entry id="td1020">

		

<code id="pre1020" display="block">class Dft01{
  public static void dft(
                    double[] data,
                    int dataLen,
                    double[] spectrum){
    //Set the frequency increment to
    // the reciprocal of the data
    // length.  This is convenience
    // only, and is not a requirement
    // of the DFT algorithm.
    double delF = 1.0/dataLen;
    //Outer loop iterates on frequency
    // values.
    for(int i=0; i &lt; dataLen;i++){
      double freq = i*delF;
      double real = 0;
      double imag = 0;
      //Inner loop iterates on time-
      // series points.
      for(int j=0; j &lt; dataLen; j++){
        real += data[j]*Math.cos(
                     2*Math.PI*freq*j);
        imag += data[j]*Math.sin(
                     2*Math.PI*freq*j);
        spectrum[i] = Math.sqrt(
                real*real + imag*imag);
      }//end inner loop
    }//end outer loop
  }//end dft
}//end Dft01</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1140">
Once again, to make a long story short, this class provides a static method 
named 

<emphasis id="strong1131" effect="bold">
dft

</emphasis>
, which computes and returns the amplitude spectrum of 
an incoming time series.

</para>





<para id="p1141">
The amplitude spectrum is computed as the square root of the sum of the 
squares of the real and imaginary parts.

</para>





<para id="p1142">
A DFT algorithm can compute any number of points in the frequency domain. In 
this case, the number of points computed in the frequency domain is equal to the 
number of samples in the incoming time series, which is a fairly common 
practice.

</para>





<para id="p1143">
The method deposits the frequency data in an array whose reference is 
received as an incoming parameter.

</para>





<para id="p1144">
As with convolution, this class could easily be broken out and put in a 
library as a stand-alone class, or the 

<emphasis id="strong1132" effect="bold">
dft

</emphasis>
 method could be 
added to a class containing a variety of DSP methods.

</para>





</section>
<section id="h21010">
<title>
<emphasis id="The_plotting_programs" effect="bold">

Two plotting programs

</emphasis>

 

</title>




<para id="p1145">
Now that you have examined the sample data-generator programs, some of you 
may be interested in an explanation of the plotting program itself.

</para>





<para id="p1146">
If you are interested only in how to use the plotting programs, and are not 
interested in the programming details of the plotting programs, skip ahead to 
the section titled 

<link id="a1172" url="Java1468-rev.htm#Run%20the%20program">

Run the 
Program

</link>

.

</para>





<para id="p1147">
If you are interested in learning how the plotting programs do what they do, 
keep reading.

</para>





<para id="p1148">
Two very similar plotting programs are shown in the listings near the end of 
the module. The program named 

<emphasis id="strong1133" effect="bold">
Graph01

</emphasis>
, shown in 

<link id="a1173" target-id="Listing_39">

Listing 39

</link>

, can 
be used to plot as many as five separate functions, each in its own plotting 
area. Examples of the display produce by this program are shown in 

<link id="a1174" target-id="Figure_1">

Figure 1

</link>

, 


<link id="a1175" target-id="Figure_2">

Figure 2

</link>

, 

<link id="a1176" target-id="Figure_3">

Figure 3

</link>

, and 

<link id="a1177" target-id="Figure_4">

Figure 4

</link>

. I will briefly discuss this program in the 
paragraphs that follow.

</para>





<para id="p1149">
The program named 

<emphasis id="strong1134" effect="bold">
Graph02

</emphasis>
, shown in 

<link id="a1178" target-id="Listing_40">

Listing 40

</link>

, can also be 
used to plot as many as five separate functions. In this case, however, the 
graphs produced by the functions are superimposed in the same plotting area. 
This is simply an alternative display format. I won't discuss any of the 
particulars of this program, but if you understand the program named 

<emphasis id="strong1135" effect="bold">

Graph01

</emphasis>
, you will have no difficulty understanding this program named


<emphasis id="strong1136" effect="bold">
Graph02

</emphasis>
 as well.

</para>





</section>
<section id="h21011">
<title>
<emphasis id="The_program_named_Graph01" effect="bold">

The program named Graph01

</emphasis>

 

</title>




<para id="p1150">
This program is designed to instantiate an object of a class file that implements the interface 
named 

<emphasis id="strong1137" effect="bold">
GraphIntfc01

</emphasis>
, and to plot the data provided by up to five functions defined in that class file.

</para>





<para id="p1151">
The methods in the class corresponding to the functions to be plotted are 
named 

<emphasis id="strong1138" effect="bold">
f1

</emphasis>
, 

<emphasis id="strong1139" effect="bold">
f2

</emphasis>
, 

<emphasis id="strong1140" effect="bold">
f3

</emphasis>
, 

<emphasis id="strong1141" effect="bold">
f4

</emphasis>
, and 


<emphasis id="strong1142" effect="bold">
f5

</emphasis>
.

</para>





<para id="p1152">
As you learned in the earlier discussion, the class containing the functions 
must also define a static method named 

<emphasis id="strong1143" effect="bold">
getNmbr

</emphasis>
. This method takes no parameters 
and returns the number of functions to be plotted. If this method returns a 
value greater than 5, a 

<emphasis id="strong1144" effect="bold">
NoSuchMethodException

</emphasis>
 will be thrown.

</para>





<section id="h31022">
<title>
<emphasis id="Some_general_comments" effect="bold">

Some general comments

</emphasis>


</title>




<section id="h41031">
<title>
Separate plotting areas 

</title>




<para id="p1153">
The overall plotting surface is divided into the required number of equally 
sized plotting areas. One function is plotted on Cartesian coordinates in each 
plotting area.

</para>





</section>
<section id="h41032">
<title>
A noarg constructor is required 

</title>




<para id="p1154">
The constructor for the class that implements 

<emphasis id="strong1145" effect="bold">
GraphIntfc01

</emphasis>
 must not require 
any parameters. This is because the 

<emphasis id="strong1146" effect="bold">
newInstance

</emphasis>
 method of the 


<emphasis id="strong1147" effect="bold">
Class

</emphasis>
 class is 
used to instantiate an object, based on a 

<emphasis id="strong1148" effect="bold">
String

</emphasis>
 provided as a command-line 
argument. The 

<emphasis id="strong1149" effect="bold">
newInstance

</emphasis>
 method can only create objects using a noarg 
constructor.

</para>





</section>
<section id="h41033">
<title>
Some methods may not be called 

</title>




<para id="p1155">
If the 

<emphasis id="strong1150" effect="bold">
getNmbr

</emphasis>
 method returns a value less than 5, then the methods that will 
not be called begin with 

<emphasis id="strong1151" effect="bold">
f5

</emphasis>
 and work down toward 

<emphasis id="strong1152" effect="bold">
f1

</emphasis>
. For example, if the value 
returned by 

<emphasis id="strong1153" effect="bold">
getNmbr

</emphasis>
 is 3, then the program will call the methods named 


<emphasis id="strong1154" effect="bold">
f1

</emphasis>
, 

<emphasis id="strong1155" effect="bold">
f2

</emphasis>
, 
and 

<emphasis id="strong1156" effect="bold">
f3

</emphasis>
. While the methods named 

<emphasis id="strong1157" effect="bold">
f4

</emphasis>
 and 

<emphasis id="strong1158" effect="bold">
f5

</emphasis>
 must exist in order to satisfy the 
interface, they won't be called. Therefore, it doesn't matter what those methods 
return as long as it is type double.

</para>





</section>
<section id="h41034">
<title>
The visual appearance 

</title>




<para id="p1156">
As shown in 

<link id="a1179" target-id="Figure_1">

Figure 1

</link>

, the plotting areas have alternating white and gray 
backgrounds to make them easy to separate visually.

</para>





<para id="p1157">
All curves are plotted in black. A Cartesian coordinate system with axes, tic 
marks, and labels is drawn in red in each plotting area.

</para>





<para id="p1158">
The Cartesian coordinate system in each plotting area has the same horizontal 
and vertical scale, as well as the same tic marks and labels on the axes.

</para>





<para id="p1159">
The labels displayed on the axes, correspond to the values of the extreme 
edges of the plotting area.

</para>





</section>
<section id="h41035">
<title>
A test class 

</title>




<para id="p1160">
The program also compiles a test class named 

<emphasis id="strong1159" effect="bold">
junk

</emphasis>
, which contains the five 
required methods plus the method named 

<emphasis id="strong1160" effect="bold">
getNmbr

</emphasis>
. This makes it easy to compile 
and test the program in a stand-alone mode.

</para>





</section>
<section id="h41036">
<title>
Usage instructions 

</title>




<para id="p1161">
At runtime, the name of the class that implements the 

<emphasis id="strong1161" effect="bold">
GraphIntfc01

</emphasis>
 interface 
must be provided as a command-line argument.

</para>





<para id="p1162">
If the command-line argument is missing, the program instantiates an object 
from the internal test class named 

<emphasis id="strong1162" effect="bold">
junk

</emphasis>
 and plots the data 
produced by that 
object. Therefore, you can test the program by running it with no command-line 
arguments. This will produce the display shown in 

<link id="a1180" target-id="Figure_4">

Figure 4

</link>

.

</para>







<table id="table1021" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1021">
<row id="tr1042">
<entry id="th1021">



<emphasis id="Figure_4" effect="bold">

Figure 4.

</emphasis>

 Graphic Display for Self-Test Class.


</entry>
</row>
</thead>


<tbody id="tbody1021">
<row id="tr1043">
<entry id="td1021">



<media id="media1003" alt="missing image" display="block">
<image id="img1003" mime-type="image/gif" src="../../media/java1468d.gif" width="401" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<para id="p1163">
If the command-line argument is provided, the program instantiates an object 
of the class whose name matches the argument, and plots the data produced by 
that object.

</para>





</section>
<section id="h41037">
<title>
Plotting parameters 

</title>




<para id="p1164">
This program provides the following text fields for user input, along with a 
button labeled 

<emphasis id="strong1163" effect="bold">
Graph

</emphasis>
. This allows the user to adjust the 
parameters and re-plot the graph as many times as needed with as many different 
plotting scales as may be needed:

</para>





<list id="ul1015" list-type="bulleted">

	

<item id="li1121">
xMin = minimum x-axis value

</item>


	

<item id="li1122">
xMax = maximum x-axis value

</item>


	

<item id="li1123">
yMin = minimum y-axis value

</item>


	

<item id="li1124">
yMax = maximum y-axis value

</item>


	

<item id="li1125">
xTicInt = tic interval on x-axis

</item>


	

<item id="li1126">
yTicInt = tic interval on y-axis

</item>


	

<item id="li1127">
xCalcInc = calculation interval

</item>




</list>




<para id="p1165">
The user can modify any of these parameters and then press the 

<emphasis id="strong1164" effect="bold">
Graph

</emphasis>
 
button to cause the five functions to be re-plotted according to the new 
parameters.

</para>





</section>
<section id="h41038">
<title>
A new object 

</title>




<para id="p1166">
Whenever the 

<emphasis id="strong1165" effect="bold">
Graph

</emphasis>
 button is pressed, the event handler for 
that button instantiates a new object of the class that implements the 

<emphasis id="strong1166" effect="bold">

GraphIntfc01

</emphasis>
 interface.

</para>





<para id="p1167">
Depending on the nature of that class, this may be redundant in some cases. 
However, it is useful in those cases where it is necessary to refresh the values 
of instance variables defined in the class 

<emphasis id="em1061" effect="italics">
(such as a counter, for example)

</emphasis>
.

</para>





<quote id="blockquote1015" display="block">

	

<para id="p1168">
<emphasis id="em1062" effect="italics">
(I will show you how to eliminate this feature from the plotting 
	program if you decide that it is unnecessary for your data.) 

</emphasis>
</para>





</quote>




</section>
<section id="h41039">
<title>
Requires Java SDK 1.4 or later 

</title>




<para id="p1169">
This program uses constants that were first defined in the 

<emphasis id="strong1167" effect="bold">
Color

</emphasis>
 
class of v1.4.0. Therefore, the program requires v1.4.0 or later to compile and 
execute correctly.

</para>





</section>
<section id="h41040">
<title>
Will discuss in fragments 

</title>




<para id="p1170">
I will discuss this program in fragments. As mentioned earlier, a complete 
listing of the program is provided in 

<link id="a1181" target-id="Listing_39">

Listing 39

</link>

 near the end of the module. You 
should be able to copy and paste that code into your Java source file, and then 
compile and execute it successfully.

</para>





</section>
</section>
<section id="h31023">
<title>
<emphasis id="The_class_named_Graph01" effect="bold">

The class named Graph01

</emphasis>

 

</title>




<para id="p1171">
The entire class, including the 

<emphasis id="strong1168" effect="bold">
main

</emphasis>
 method is shown in 

<link id="a1182" target-id="Listing_19">

Listing 19

</link>

.

</para>






<table id="table1022" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1022">
<row id="tr1044">



<entry id="th1022">
<emphasis id="Listing_19" effect="bold">

Listing 19.

</emphasis>

 The class named Graph01.

</entry>
</row>
</thead>


<tbody id="tbody1022">
<row id="tr1045">
<entry id="td1022">



<code id="pre1021" display="block">import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph01{
  public static void main(
          String[] args)
          throws NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{
    if(args.length == 1){
      //pass command-line parameter
      new GUI(args[0]);
    }else{
      //no command-line parameter given
      new GUI(null);
    }//end else
  }// end main
}//end class Graph01 definition</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1172">
The primary purpose of 

<emphasis id="strong1169" effect="bold">
main

</emphasis>
 method is to instantiate an 
object of the class named 

<emphasis id="strong1170" effect="bold">
GUI

</emphasis>
. 

</para>





<para id="p1173">
In addition, the 

<emphasis id="strong1171" effect="bold">
main

</emphasis>
 method checks to see if the user 
provided a command-line argument, and if so, passes it along to the constructor 
for the 

<emphasis id="strong1172" effect="bold">
GUI

</emphasis>
 class.

</para>





</section>
<section id="h31024">
<title>
<emphasis id="Beginning_of_the_class_named_GUI" effect="bold">

Beginning of the class named GUI

</emphasis>

 

</title>




<para id="p1174">
The class named 

<emphasis id="strong1173" effect="bold">
GUI

</emphasis>
 begins in 

<link id="a1183" target-id="Listing_20">

Listing 20

</link>

.

</para>





<table id="table1023" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1023">
<row id="tr1046">



<entry id="th1023">
<emphasis id="Listing_20" effect="bold">

Listing 20.

</emphasis>

 Beginning of the class named GUI.

</entry>
</row>
</thead>


<tbody id="tbody1023">
<row id="tr1047">
<entry id="td1023">



<code id="pre1022" display="block">class GUI extends JFrame
             implements ActionListener{

  //Define plotting parameters and
  // their default values.
  double xMin = 0.0;
  double xMax = 400.0;
  double yMin = -100.0;
  double yMax = 100.0;

  //Tic mark intervals
  double xTicInt = 20.0;
  double yTicInt = 20.0;

  //Tic mark lengths.  If too small
  // on x-axis, a default value is
  // used later.
  double xTicLen = (yMax-yMin)/50;
  double yTicLen = (xMax-xMin)/50;

  //Calculation interval along x-axis
  double xCalcInc = 1.0;

  //Text fields for plotting parameters
  JTextField xMinTxt =
             new JTextField("" + xMin);
  JTextField xMaxTxt =
             new JTextField("" + xMax);
  JTextField yMinTxt =
             new JTextField("" + yMin);
  JTextField yMaxTxt =
             new JTextField("" + yMax);
  JTextField xTicIntTxt =
          new JTextField("" + xTicInt);
  JTextField yTicIntTxt =
          new JTextField("" + yTicInt);
  JTextField xCalcIncTxt =
         new JTextField("" + xCalcInc);

  //Panels to contain a label and a
  // text field
  JPanel pan0 = new JPanel();
  JPanel pan1 = new JPanel();
  JPanel pan2 = new JPanel();
  JPanel pan3 = new JPanel();
  JPanel pan4 = new JPanel();
  JPanel pan5 = new JPanel();
  JPanel pan6 = new JPanel();

  //Misc instance variables
  int frmWidth = 408;
  int frmHeight = 430;
  int width;
  int height;
  int number;
  GraphIntfc01 data;
  String args = null;

  //Plots are drawn on the canvases
  // in this array.
  Canvas[] canvases;</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1175">
The code in 

<link id="a1184" target-id="Listing_20">

Listing 20

</link>

 declares and in some cases initializes several 
instance variables that are required later to support the plotting process. The 
comments and the names of the variables generally indicate the purpose of those 
variables.

</para>





</section>
<section id="h31025">
<title>
<emphasis id="Beginning_of_the_constructor_for_the_GUI_class" effect="bold">

Beginning of the 
constructor for the GUI class

</emphasis>

 

</title>




<para id="p1176">
The beginning of the constructor for the GUI class is shown in 

<link id="a1185" target-id="Listing_21">

Listing 21

</link>

.

</para>





<table id="table1024" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1024">
<row id="tr1048">



<entry id="th1024">
<emphasis id="Listing_21" effect="bold">

Listing 21.

</emphasis>

 Beginning of the 
constructor for the GUI class.


</entry>
</row>
</thead>


<tbody id="tbody1024">
<row id="tr1049">
<entry id="td1024">



<code id="pre1023" display="block">  GUI(String args)throws
                NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{

    if(args != null){
      //Save for use later in the
      // ActionEvent handler
      this.args = args;
      //Instantiate an object of the
      // target class using the String
      // name of the class.
      data = (GraphIntfc01)
                   Class.forName(args).
                         newInstance();
    }else{
      //Instantiate an object of the
      // test class named junk.
      data = new junk();
    }//end else</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1177">
The main purpose of the code in 

<link id="a1186" target-id="Listing_21">

Listing 21

</link>

 is to instantiated the object that 
will provide the data to be plotted. If the user provided the name of a class as 
a command-line argument, an attempt will be made to create a 

<emphasis id="strong1174" effect="bold">
newInstance

</emphasis>
 
of that class.

</para>





<quote id="blockquote1016" display="block">

	

<para id="p1178">
<emphasis id="em1063" effect="italics">
(In case you are unfamiliar with this approach, this is one way to 
	create an object of a class whose name is specified as a String at runtime.)
	

</emphasis>
</para>





</quote>




<para id="p1179">
Otherwise, the code in 

<link id="a1187" target-id="Listing_21">

Listing 21

</link>

 will instantiate an object of the test 
class named 

<emphasis id="strong1175" effect="bold">
junk

</emphasis>
 

<emphasis id="em1064" effect="italics">
(to be discussed later)

</emphasis>
. 

</para>





</section>
<section id="h31026">
<title>
<emphasis id="Array_to_hold_Canvas_objects_" effect="bold">

Array to hold Canvas objects 

</emphasis>




</title>




<para id="p1180">
Each of the separate plotting areas in 

<link id="a1188" target-id="Figure_1">

Figure 1

</link>

 is an object of a class that 
extends the 

<emphasis id="strong1176" effect="bold">
Canvas

</emphasis>
 class. The code in 

<link id="a1189" target-id="Listing_22">

Listing 22

</link>

 calls the


<emphasis id="strong1177" effect="bold">
getNmbr

</emphasis>
 method on the new object to determine how many 
functions are to be plotted. Then it creates an array object to hold the 
requisite number of 

<emphasis id="strong1178" effect="bold">
Canvas

</emphasis>
 objects.

</para>






<table id="table1025" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1025">
<row id="tr1050">



<entry id="th1025">
<emphasis id="Listing_22" effect="bold">

Listing 22.

</emphasis>

 Array to hold Canvas objects.

</entry>
</row>
</thead>


<tbody id="tbody1025">
<row id="tr1051">
<entry id="td1025">



<code id="pre1024" display="block">    //Create array to hold correct
    // number of Canvas objects.
    canvases =
            new Canvas[data.getNmbr()];

    //Throw exception if number of
    // functions is greater than 5.
    number = data.getNmbr();
    if(number &gt; 5){
      throw new NoSuchMethodException(
                "Too many functions.  "
                  + "Only 5 allowed.");
    }//end if</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1181">
Although the limit could easily be increased, this program is currently 
limited to plotting the output from five functions. The code in 

<link id="a1190" target-id="Listing_22">

Listing 22

</link>

 
checks this limit and throws an exception if an attempt is made to plot more 
than five functions.

</para>





</section>
<section id="h31027">
<title>
<emphasis id="Routine_GUI_construction_code" effect="bold">

Routine GUI construction code

</emphasis>




</title>




<para id="p1182">
Although somewhat long and rather tedious, the code in 

<link id="a1191" target-id="Listing_23">

Listing 23

</link>

 is 
completely straightforward. This code continues with the construction of the GUI 
object, creating text fields, a button, etc.

</para>





<table id="table1026" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1026">
<row id="tr1052">



<entry id="th1026">
<emphasis id="Listing_23" effect="bold">

Listing 23.

</emphasis>

 Routine GUI construction code.

</entry>
</row>
</thead>


<tbody id="tbody1026">
<row id="tr1053">
<entry id="td1026">



<code id="pre1025" display="block">    //Create the control panel and
    // give it a border for cosmetics.
    JPanel ctlPnl = new JPanel();
    ctlPnl.setLayout(//?rows x 4 cols
                  new GridLayout(0,4));
    ctlPnl.setBorder(
                   new EtchedBorder());

    //Button for replotting the graph
    JButton graphBtn =
                  new JButton("Graph");
    graphBtn.addActionListener(this);

    //Populate each panel with a label
    // and a text field.  Will place
    // these panels in a grid on the
    // control panel later.
    pan0.add(new JLabel("xMin"));
    pan0.add(xMinTxt);

    pan1.add(new JLabel("xMax"));
    pan1.add(xMaxTxt);

    pan2.add(new JLabel("yMin"));
    pan2.add(yMinTxt);

    pan3.add(new JLabel("yMax"));
    pan3.add(yMaxTxt);

    pan4.add(new JLabel("xTicInt"));
    pan4.add(xTicIntTxt);

    pan5.add(new JLabel("yTicInt"));
    pan5.add(yTicIntTxt);

    pan6.add(new JLabel("xCalcInc"));
    pan6.add(xCalcIncTxt);

    //Add the populated panels and the
    // button to the control panel with
    // a grid layout.
    ctlPnl.add(pan0);
    ctlPnl.add(pan1);
    ctlPnl.add(pan2);
    ctlPnl.add(pan3);
    ctlPnl.add(pan4);
    ctlPnl.add(pan5);
    ctlPnl.add(pan6);
    ctlPnl.add(graphBtn);</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1183">
Because of the routine nature of the code in 

<link id="a1192" target-id="Listing_23">

Listing 23

</link>

, I will let the 
comments suffice as an explanation.

</para>





</section>
<section id="h31028">
<title>
<emphasis id="The_Canvas_objects" effect="bold">

The Canvas objects

</emphasis>

 

</title>




<para id="p1184">
If you refer back to 

<link id="a1193" target-id="Figure_1">

Figure 1

</link>

, you will see that from one to five 

<emphasis id="strong1179" effect="bold">

Canvas

</emphasis>
 objects are stacked vertically in the center of a frame.

</para>





<para id="p1185">
This is accomplished by placing a 

<emphasis id="strong1180" effect="bold">
JPanel

</emphasis>
 object in the 
center of the frame, and setting the layout manager on the 

<emphasis id="strong1181" effect="bold">
JPanel

</emphasis>
 
to 

<emphasis id="strong1182" effect="bold">
GridLayout

</emphasis>
. The grid is defined as having one column and an 
unspecified number of rows. Then one 

<emphasis id="strong1183" effect="bold">
Canvas

</emphasis>
 object is placed in 
each cell of the grid, beginning at the top and working downward from the top, 
until the required number of 

<emphasis id="strong1184" effect="bold">
Canvas

</emphasis>
 objects have been placed in 
the grid.

</para>





<para id="p1186">
This is accomplished by the code in 

<link id="a1194" target-id="Listing_24">

Listing 24

</link>

.

</para>





<table id="table1027" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1027">
<row id="tr1054">



<entry id="th1027">
<emphasis id="Listing_24" effect="bold">

Listing 24.

</emphasis>

 The Canvas objects.

</entry>
</row>
</thead>


<tbody id="tbody1027">
<row id="tr1055">
<entry id="td1027">



<code id="pre1026" display="block">    //Create a panel to contain the
    // Canvas objects.  They will be
    // displayed in a one-column grid.
    JPanel canvasPanel = new JPanel();
    canvasPanel.setLayout(//?rows,1 col
                  new GridLayout(0,1));

    //Create a custom Canvas object for
    // each function to be plotted and
    // add them to the one-column grid.
    // Make background colors alternate
    // between white and gray.
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      switch(cnt){
        case 0 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 1 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 2 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 3 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 4 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].
            setBackground(Color.WHITE);
      }//end switch
      
      //Add the object to the grid.
      canvasPanel.add(canvases[cnt]);
    }//end for loop</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1187">
The code in 

<link id="a1195" target-id="Listing_24">

Listing 24

</link>

:

</para>





<list id="ul1016" list-type="bulleted">

	

<item id="li1128">
Creates the JPanel object, and sets its layout property to GridLayout.

</item>


	

<item id="li1129">
Creates the requisite number of objects of the MyCanvas class (which 
	extends Canvas), setting the background colors of the panels alternately to 
	white and gray.

</item>


	

<item id="li1130">
Adds the MyCanvas objects to the cells in the grid. (Note that the 
	constructor for each MyCanvas object receives an integer that specifies its 
	position in the stack of MyCanvas objects. We will see how that information 
	is used later.) 

</item>




</list>




</section>
<section id="h31029">
<title>
<emphasis id="More_routine_construction_code_" effect="bold">

More routine construction code 

</emphasis>

 


</title>




<para id="p1188">
The code in 

<link id="a1196" target-id="Listing_25">

Listing 25

</link>

 is simply more routine code required to:

</para>





<list id="ul1017" list-type="bulleted">

	

<item id="li1131">
Finish the construction of the GUI object

</item>


	

<item id="li1132">
Set its location and size on the screen

</item>


	

<item id="li1133">
Make it visible

</item>




</list>




<para id="p1189">
Once again, I will let the comments serve as the explanation for this code.

</para>






<table id="table1028" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1028">
<row id="tr1056">



<entry id="th1028">
<emphasis id="Listing_25" effect="bold">

Listing 25.

</emphasis>

 More routine construction code.

</entry>
</row>
</thead>


<tbody id="tbody1028">
<row id="tr1057">
<entry id="td1028">



<code id="pre1027" display="block">    //Add the sub-assemblies to the
    // frame.  Set its location, size,
    // and title, and make it visible.
    getContentPane().
                   add(ctlPnl,"South");
    getContentPane().
             add(canvasPanel,"Center");

    setBounds(0,0,frmWidth,frmHeight);
    setTitle("Graph01, " +
                 "Copyright 2002, " +
                 "Richard G. Baldwin");
    setVisible(true);

    //Set to exit on X-button click
    setDefaultCloseOperation(
                        EXIT_ON_CLOSE);

    //Get and save the size of the
    // plotting surface
    width = canvases[0].getWidth();
    height = canvases[0].getHeight();</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




</section>
<section id="h31030">
<title>
<emphasis id="Force_a_repaint_" effect="bold">

Force a repaint 

</emphasis>


</title>




<para id="p1190">
As you will see later, the actual plotting behavior of this program is 
defined by the code in an overridden version of the 

<emphasis id="strong1185" effect="bold">
paint

</emphasis>
 
method in the 

<emphasis id="strong1186" effect="bold">
MyCanvas

</emphasis>
 class. I will discuss that code in some 
detail later.

</para>





<para id="p1191">
One way to cause the code in the overridden 

<emphasis id="strong1187" effect="bold">
paint

</emphasis>
 method to 
be executed is to call the 

<emphasis id="strong1188" effect="bold">
repaint

</emphasis>
 method on a reference to a 

<emphasis id="strong1189" effect="bold">
MyCanvas

</emphasis>
 
object. 

</para>





<para id="p1192">
The code in 

<link id="a1197" target-id="Listing_26">

Listing 26

</link>

 calls the 

<emphasis id="strong1190" effect="bold">
repaint

</emphasis>
 method on each


<emphasis id="strong1191" effect="bold">
MyCanvas

</emphasis>
 object in sequence, to guarantee that they are 
properly painted when the GUI object first becomes visible.

</para>





<table id="table1029" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1029">
<row id="tr1058">



<entry id="th1029">
<emphasis id="Listing_26" effect="bold">

Listing 26.

</emphasis>

 Force a repaint.

</entry>
</row>
</thead>


<tbody id="tbody1029">
<row id="tr1059">
<entry id="td1029">



<code id="pre1028" display="block">    for(int cnt = 0; cnt &lt; number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end constructor</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1193">
Similar code will be used again later to cause the graphs to be repainted 
each time the user presses the 

<emphasis id="strong1192" effect="bold">
Graph

</emphasis>
 button in the bottom right 
corner of 

<link id="a1198" target-id="Figure_1">

Figure 1

</link>

.

</para>





</section>
<section id="h31031">
<title>
<emphasis id="End_of_the_constructor_" effect="bold">

End of the constructor 

</emphasis>


</title>




<para id="p1194">
The code in 

<link id="a1199" target-id="Listing_26">

Listing 26

</link>

 also ends the constructor for the 

<emphasis id="strong1193" effect="bold">
GUI

</emphasis>
 
object. When the constructor finishes execution, the 

<emphasis id="strong1194" effect="bold">
GUI

</emphasis>
 
appears on the screen with all plotting areas properly painted.

</para>





</section>
<section id="h31032">
<title>
<emphasis id="Re-plotting_the_data_" effect="bold">

Re-plotting the data 

</emphasis>

 

</title>




<para id="p1195">
<link id="a1200" target-id="Listing_27">


</link>

 shows the beginning of the event handler that is registered on the 
button to cause the functions to be re-plotted.

</para>





<table id="table1030" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1030">
<row id="tr1060">



<entry id="th1030">
<emphasis id="Listing_27" effect="bold">


</emphasis>

 Beginning of the re-plot code.


</entry>
</row>
</thead>


<tbody id="tbody1030">
<row id="tr1061">
<entry id="td1030">



<code id="pre1029" display="block">  public void actionPerformed(
                      ActionEvent evt){
    //Re-instantiate the object that
    // provides the data
    try{
      if(args != null){
        data = (GraphIntfc01)Class.
           forName(args).newInstance();
      }else{
        data = new junk();
      }//end else
    }catch(Exception e){
      //Known to be safe at this point.
      // Otherwise would have aborted
      // earlier.
    }//end catch</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1196">
The purpose of the event handler is to cause the functions to be re-plotted 
after the user changes the plotting parameters.

</para>





</section>
<section id="h31033">
<title>
<emphasis id="A_new_object_of_the_target_class" effect="bold">

A new object of the target class

</emphasis>




</title>




<para id="p1197">
However, the code in 

<link id="a1201" target-id="Listing_27">

Listing 27

</link>

 goes beyond that. In particular, the code in 


<link id="a1202" target-id="Listing_27">

Listing 27

</link>

 creates a new object from which to get the data that is to be 
plotted.

</para>





<para id="p1198">
In some cases, this may be required, depending on the nature of the class 
from which that object is instantiated. In other cases, it may not be necessary, 
and could slow down the re-plotting process.

</para>





<para id="p1199">
If your class doesn't contain counters or other variables that need to be 
re-initialized whenever you re-plot, you could probably safely remove or disable 
the code in 

<link id="a1203" target-id="Listing_27">

Listing 27

</link>

. This will make the program run faster, although you may 
not be able to see the difference.

</para>





</section>
<section id="h31034">
<title>
<emphasis id="The_remainder_of_the_event_handler_" effect="bold">

The remainder of the event 
handler 

</emphasis>


</title>




<para id="p1200">
The remaining code in the event handler is shown in 

<link id="a1204" target-id="Listing_28">

Listing 28

</link>

.

</para>





<table id="table1031" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1031">
<row id="tr1062">



<entry id="th1031">
<emphasis id="Listing_28" effect="bold">

Listing 28.

</emphasis>

 The remainder of the event 
handler.

</entry>
</row>
</thead>


<tbody id="tbody1031">
<row id="tr1063">
<entry id="td1031">



<code id="pre1030" display="block">    //Set plotting parameters using
    // data from the text fields.
    xMin = Double.parseDouble(
                    xMinTxt.getText());
    xMax = Double.parseDouble(
                    xMaxTxt.getText());
    yMin = Double.parseDouble(
                    yMinTxt.getText());
    yMax = Double.parseDouble(
                    yMaxTxt.getText());
    xTicInt = Double.parseDouble(
                 xTicIntTxt.getText());
    yTicInt = Double.parseDouble(
                 yTicIntTxt.getText());
    xCalcInc = Double.parseDouble(
                xCalcIncTxt.getText());

    //Calculate new values for the
    // length of the tic marks on the
    // axes.  If too small on x-axis,
    // a default value is used later.
    xTicLen = (yMax-yMin)/50;
    yTicLen = (xMax-xMin)/50;

    //Repaint the plotting areas
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end actionPerformed</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1201">
This code is very straightforward. It performs the following actions:

</para>





<list id="ul1018" list-type="bulleted">

	

<item id="li1134">
Get new plotting parameters from the text fields.

</item>


	

<item id="li1135">
Perform some calculations.

</item>


	

<item id="li1136">
Cause each of the 

<emphasis id="strong1195" effect="bold">
MyCanvas

</emphasis>
 objects to be repainted 
	using the new plotting parameters.

</item>




</list>




<para id="p1202">
Again, I will let the comments provide any necessary explanations.

</para>





<para id="p1203">
That brings us to the most interesting part of the program, the extended


<emphasis id="strong1196" effect="bold">
Canvas

</emphasis>
 class.

</para>





</section>
<section id="h31035">
<title>
<emphasis id="Beginning_of_the_class_named_MyCanvas" effect="bold">

Beginning of the class named 
MyCanvas

</emphasis>

 

</title>




<para id="p1204">
The class named 

<emphasis id="strong1197" effect="bold">
MyCanvas

</emphasis>
 is an inner class of the 

<emphasis id="strong1198" effect="bold">

GUI

</emphasis>
 class, which is used to override the 

<emphasis id="strong1199" effect="bold">
paint

</emphasis>
 method 
in each of the plotting areas shown in 

<link id="a1205" target-id="Figure_1">

Figure 1

</link>

. 

</para>





<quote id="blockquote1017" display="block">

	

<para id="p1205">
<emphasis id="em1065" effect="italics">
(Virtually all graphics operations in Java, other than those 
	involving standard GUI components, are implemented by overriding the 

<emphasis id="strong1200" effect="bold">

	paint

</emphasis>
 method on an object.) 

</emphasis>
</para>





</quote>




<para id="p1206">
The beginning of this class definition is shown in 

<link id="a1206" target-id="Listing_29">

Listing 29

</link>

.

</para>





<table id="table1032" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1032">
<row id="tr1064">



<entry id="th1032">
<emphasis id="Listing_29" effect="bold">

Listing 29.

</emphasis>

 Beginning of the class named 
MyCanvas.


</entry>
</row>
</thead>


<tbody id="tbody1032">
<row id="tr1065">
<entry id="td1032">



<code id="pre1031" display="block">class MyCanvas extends Canvas{
  int cnt;//object number
  //Factors to convert from double
  // values to integer pixel locations.
  double xScale;
  double yScale;

  MyCanvas(int cnt){//save obj number
    this.cnt = cnt;
  }//end constructor</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41041">
<title>
Floating data vs. pixels 

</title>




<para id="p1207">
Most of the calculations in this program are performed on data of type


<emphasis id="strong1201" effect="bold">
double

</emphasis>
. However, graphics operations are ultimately performed 
in terms integer numbers of pixels. The code in 

<link id="a1207" target-id="Listing_29">

Listing 29

</link>

 declares scale 
factors used later to convert from 

<emphasis id="strong1202" effect="bold">
double

</emphasis>
 values to 

<emphasis id="strong1203" effect="bold">

integer

</emphasis>
 pixel locations.

</para>





</section>
<section id="h41042">
<title>
A simple constructor 

</title>




<para id="p1208">
The code in 

<link id="a1208" target-id="Listing_29">

Listing 29

</link>

 also defines the constructor, whose only purpose is to 
save an integer identifying the position of this object in the vertical stack of


<emphasis id="strong1204" effect="bold">
MyCanvas

</emphasis>
 objects.

</para>





</section>
</section>
<section id="h31036">
<title>
<emphasis id="Beginning_of_the_overridden_paint_method_" effect="bold">

Beginning of the 
overridden paint method 

</emphasis>


</title>




<para id="p1209">
The beginning of the overridden paint method for the 

<emphasis id="strong1205" effect="bold">
MyCanvas

</emphasis>
 class is shown 
in 

<link id="a1209" target-id="Listing_30">

Listing 30

</link>

.

</para>






<table id="table1033" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1033">
<row id="tr1066">



<entry id="th1033">
<emphasis id="Listing_30" effect="bold">

Listing 30.

</emphasis>

 Beginning of the 
overridden paint method.

</entry>
</row>
</thead>


<tbody id="tbody1033">
<row id="tr1067">
<entry id="td1033">



<code id="pre1032" display="block">  public void paint(Graphics g){
    //Calculate the scale factors
    xScale = width/(xMax-xMin);
    yScale = height/(yMax-yMin);

    //Set the origin based on the
    // minimum values in x and y
    g.translate((int)((0-xMin)*xScale),
               (int)((0-yMin)*yScale));
    drawAxes(g);//Draw the axes
    g.setColor(Color.BLACK);</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1210">
The code in 

<link id="a1210" target-id="Listing_30">

Listing 30

</link>

:

</para>





<list id="ul1019" list-type="bulleted">

	

<item id="li1137">
Calculates and saves the scale factors for converting from 

<emphasis id="strong1206" effect="bold">

	double

</emphasis>
 coordinate values to 

<emphasis id="strong1207" effect="bold">
integer

</emphasis>
 values in 
	pixels.

</item>


	

<item id="li1138">
Moves the plotting origin to the correct location.

</item>


	

<item id="li1139">
Calls a method to draw the axes 

<emphasis id="em1066" effect="italics">
(in red)

</emphasis>
 on the 

<emphasis id="strong1208" effect="bold">

	MyCanvas

</emphasis>
 object.

</item>


	

<item id="li1140">
Sets the color to black for the remainder of the plotting activity on 
	the object.

</item>




</list>




</section>
<section id="h31037">
<title>
<emphasis id="Get_old_coordinate_values_" effect="bold">

Get old coordinate values 

</emphasis>

 

</title>




<para id="p1211">
The plotting process consists of drawing straight line segment between pairs 
of 
points. For each line segment, one of the points is defined by a pair of old coordinate values. The 
other point is defined by a pair of new coordinate values.

</para>





<para id="p1212">
The code in 

<link id="a1211" target-id="Listing_31">

Listing 31

</link>

 initializes the beginning point for the plot. The 
initial value for the x-coordinate is the left edge of the plotting area. 

</para>





<table id="table1034" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1034">
<row id="tr1068">



<entry id="th1034">
<emphasis id="Listing_31" effect="bold">

Listing 31.

</emphasis>

 Get old coordinate values.

</entry>
</row>
</thead>


<tbody id="tbody1034">
<row id="tr1069">
<entry id="td1034">



<code id="pre1033" display="block">    //Get initial data values
    double xVal = xMin;
    int oldX = getTheX(xVal);
    int oldY = 0;
    //Use the Canvas obj number to
    // determine which method to
    // call to get the value for y.
    switch(cnt){
      case 0 :
        oldY = getTheY(data.f1(xVal));
        break;
      case 1 :
        oldY = getTheY(data.f2(xVal));
        break;
      case 2 :
        oldY = getTheY(data.f3(xVal));
        break;
      case 3 :
        oldY = getTheY(data.f4(xVal));
        break;
      case 4 :
        oldY = getTheY(data.f5(xVal));
    }//end switch</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<section id="h41043">
<title>
The initial y-coordinate value 

</title>




<para id="p1213">
The initial value for the y-coordinate depends on which function is being 
plotted on the 

<emphasis id="strong1209" effect="bold">
MyCanvas

</emphasis>
 object. Recall that each 

<emphasis id="strong1210" effect="bold">

MyCanvas

</emphasis>
 object contains an instance variable that identifies its 
position in the vertical stack of 

<emphasis id="strong1211" effect="bold">
MyCanvas

</emphasis>
 objects. The 

<emphasis id="strong1212" effect="bold">

switch

</emphasis>
 statement in 

<link id="a1212" target-id="Listing_31">

Listing 31

</link>

 uses that information to call one of the 
five methods named 

<emphasis id="strong1213" effect="bold">
f1

</emphasis>
 through 

<emphasis id="strong1214" effect="bold">
f5

</emphasis>
. This gets 
the correct value for the y-coordinate based on the value of the x-coordinate 
for each 

<emphasis id="strong1215" effect="bold">
MyCanvas

</emphasis>
 object.

</para>





<para id="p1214">
The methods named 

<emphasis id="strong1216" effect="bold">
getTheX

</emphasis>
 and 

<emphasis id="strong1217" effect="bold">
getTheY

</emphasis>
 
called by the code in 

<link id="a1213" target-id="Listing_31">

Listing 31

</link>

 convert the coordinate values from type 

<emphasis id="strong1218" effect="bold">

double

</emphasis>
 to integer values in pixels.

</para>





<para id="p1215">
The method named 

<emphasis id="strong1219" effect="bold">
getTheY

</emphasis>
 also changes the sign on the data 
so that positive y-values go up the screen rather than down the screen.

</para>





<quote id="blockquote1018" display="block">

	

<para id="p1216">
<emphasis id="em1067" effect="italics">
(By default, positive vertical coordinate values go down the screen 
	from top to bottom in Java.) 

</emphasis>
</para>





</quote>




</section>
</section>
<section id="h31038">
<title>
<emphasis id="Plot_the_points" effect="bold">

Plot the points

</emphasis>

 

</title>




<para id="p1217">
The remainder of the overridden paint method is shown in 

<link id="a1214" target-id="Listing_32">

Listing 32

</link>

.

</para>





<table id="table1035" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1035">
<row id="tr1070">



<entry id="th1035">
<emphasis id="Listing_32" effect="bold">


</emphasis>

 Plot the points.

</entry>
</row>
</thead>


<tbody id="tbody1035">
<row id="tr1071">
<entry id="td1035">



<code id="pre1034" display="block">    //Now loop and plot the points
    while(xVal &lt; xMax){
      int yVal = 0;
      //Get next data value.  Use the
      // Canvas obj number to
      // determine which method to
      // invoke to get the value for y.
      switch(cnt){
        case 0 :
          yVal =
                getTheY(data.f1(xVal));
          break;
        case 1 :
          yVal =
                getTheY(data.f2(xVal));
          break;
        case 2 :
          yVal =
                getTheY(data.f3(xVal));
          break;
        case 3 :
          yVal =
                getTheY(data.f4(xVal));
          break;
        case 4 :
          yVal =
                getTheY(data.f5(xVal));
      }//end switch1

      //Convert the x-value to an int
      // and draw the next line segment
      int x = getTheX(xVal);
      g.drawLine(oldX,oldY,x,yVal);

      //Increment along the x-axis
      xVal += xCalcInc;

      //Save end point to use as start
      // point for next line segment.
      oldX = x;
      oldY = yVal;
    }//end while loop

  }//end overridden paint method</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1218">
The code in 

<link id="a1215" target-id="Listing_32">

Listing 32

</link>

 is relatively straightforward. This code simply 
iterates from the minimum x-value to the maximum x-value, calling the 
appropriate method 

<emphasis id="em1068" effect="italics">
(from 

</emphasis>
<emphasis id="strong1220" effect="bold">
<emphasis id="em1069" effect="italics">
f1

</emphasis>
</emphasis>
<emphasis id="em1070" effect="italics">
 through 

</emphasis>



<emphasis id="strong1221" effect="bold">
<emphasis id="em1071" effect="italics">
f5

</emphasis>
</emphasis>
<emphasis id="em1072" effect="italics">
 )

</emphasis>
 to get the new y-values. In the process, 
it calls the 

<emphasis id="strong1222" effect="bold">
drawLine

</emphasis>
 method of the 

<emphasis id="strong1223" effect="bold">
Graphics

</emphasis>
 
class to connect the points.

</para>





</section>
<section id="h31039">
<title>
<emphasis id="The_drawAxes_method" effect="bold">

The drawAxes method

</emphasis>

 

</title>




<para id="p1219">
As it turns out, it is more difficult to draw and label the axes with tic 
marks than it is to plot the actual data.

</para>





<para id="p1220">
The code to accomplish this is shown in 

<link id="a1216" target-id="Listing_33">

Listing 33

</link>

.

</para>





<table id="table1036" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1036">
<row id="tr1072">



<entry id="th1036">
<emphasis id="Listing_33" effect="bold">

Listing 33.

</emphasis>

 The drawAxes method.

</entry>
</row>
</thead>


<tbody id="tbody1036">
<row id="tr1073">
<entry id="td1036">



<code id="pre1035" display="block">  void drawAxes(Graphics g){
    g.setColor(Color.RED);

    //Label left x-axis and bottom
    // y-axis.  These are the easy
    // ones.  Separate the labels from
    // the ends of the tic marks by
    // two pixels.
    g.drawString("" + (int)xMin,
                 getTheX(xMin),
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMin,
                  getTheX(yTicLen/2)+2,
                        getTheY(yMin));

    //Label the right x-axis and the
    // top y-axis.  These are the hard
    // ones because the position must
    // be adjusted by the font size and
    // the number of characters.
    //Get the width of the string for
    // right end of x-axis and the
    // height of the string for top of
    // y-axis
    //Create a string that is an
    // integer representation of the
    // label for the right end of the
    // x-axis.  Then get a character
    // array that represents the
    // string.
    int xMaxInt = (int)xMax;
    String xMaxStr = "" + xMaxInt;
    char[] array = xMaxStr.
                         toCharArray();

    //Get a FontMetrics object that can
    // be used to get the size of the
    // string in pixels.
    FontMetrics fontMetrics =
                    g.getFontMetrics();
    //Get a bounding rectangle for the
    // string
    Rectangle2D r2d =
           fontMetrics.getStringBounds(
               array,0,array.length,g);
    //Get the width and the height of
    // the bounding rectangle.  The
    // width is the width of the label
    // at the right end of the
    // x-axis.  The height applies to
    // all the labels, but is needed
    // specifically for the label at
    // the top end of the y-axis.
    int labWidth =
                 (int)(r2d.getWidth());
    int labHeight =
                (int)(r2d.getHeight());

    //Label the positive x-axis and the
    // positive y-axis using the width
    // and height from above to
    // position the labels.  These
    // labels apply to the very ends of
    // the axes at the edge of the
    // plotting surface.
    g.drawString("" + (int)xMax,
                getTheX(xMax)-labWidth,
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMax,
              getTheX(yTicLen/2)+2,
              getTheY(yMax)+labHeight);

    //Draw the axes
    g.drawLine(getTheX(xMin),
                         getTheY(0.0),
                         getTheX(xMax),
                         getTheY(0.0));

    g.drawLine(getTheX(0.0),
                        getTheY(yMin),
                        getTheX(0.0),
                        getTheY(yMax));

    //Draw the tic marks on axes
    xTics(g);
    yTics(g);
  }//end drawAxes</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1221">
The code in 

<link id="a1217" target-id="Listing_33">

Listing 33

</link>

 is fairly complex, particularly with respect to 
putting the labels on the ends of the axes. However, I doubt that many of you 
are interested in the details, so I will let the comments suffice to explain the 
code.

</para>





</section>
<section id="h31040">
<title>
<emphasis id="Drawing_tic_marks" effect="bold">

Drawing tic marks

</emphasis>

 

</title>




<para id="p1222">
<link id="a1218" target-id="Listing_34">

Listing 34

</link>

 shows the methods called from the code in 

<link id="a1219" target-id="Listing_33">

Listing 33

</link>

 to actually 
draw the tic marks on the axes.

</para>





<table id="table1037" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1037">
<row id="tr1074">



<entry id="th1037">
<emphasis id="Listing_34" effect="bold">

Listing 34.

</emphasis>

 Drawing tic marks.

</entry>
</row>
</thead>


<tbody id="tbody1037">
<row id="tr1075">
<entry id="td1037">



<code id="pre1036" display="block">  void xTics(Graphics g){
    double xDoub = 0;
    int x = 0;

    //Get the ends of the tic marks.
    int topEnd = getTheY(xTicLen/2);
    int bottomEnd =
                   getTheY(-xTicLen/2);

    //If the vertical size of the
    // plotting area is small, the
    // calculated tic size may be too
    // small.  In that case, set it to
    // 10 pixels.
    if(topEnd &lt; 5){
      topEnd = 5;
      bottomEnd = -5;
    }//end if

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive x-axis
    // moving to the right from zero.
    while(xDoub &lt; xMax){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub += xTicInt;
    }//end while

    //Now do the negative x-axis moving
    // to the left from zero
    xDoub = 0;
    while(xDoub &gt; xMin){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub -= xTicInt;
    }//end while

  }//end xTics
  //---------------------------------//

  //Method to draw tic marks on y-axis
  void yTics(Graphics g){
    double yDoub = 0;
    int y = 0;
    int rightEnd = getTheX(yTicLen/2);
    int leftEnd = getTheX(-yTicLen/2);

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive y-axis
    // moving up from zero.
    while(yDoub &lt; yMax){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub += yTicInt;
    }//end while

    //Now do the negative y-axis moving
    // down from zero.
    yDoub = 0;
    while(yDoub &gt; yMin){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub -= yTicInt;
    }//end while

  }//end yTics</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1223">
Again, I am going to let the comments suffice to explain this code.

</para>





</section>
<section id="h31041">
<title>
<emphasis id="The_getTheX_and_getTheY_methods_" effect="bold">

The getTheX and getTheY methods


</emphasis>

 

</title>




<para id="p1224">
As mentioned earlier, methods named 

<emphasis id="strong1224" effect="bold">
getTheX

</emphasis>
 and 

<emphasis id="strong1225" effect="bold">

getTheY

</emphasis>
 are used to convert coordinate values from type 

<emphasis id="strong1226" effect="bold">
double

</emphasis>
 
to integer values in pixels. Those two methods are shown in 

<link id="a1220" target-id="Listing_35">

Listing 35

</link>

.

</para>





<table id="table1038" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1038">
<row id="tr1076">



<entry id="th1038">
<emphasis id="Listing_35" effect="bold">

Listing 35.

</emphasis>

 The getTheX and getTheY methods.

</entry>
</row>
</thead>


<tbody id="tbody1038">
<row id="tr1077">
<entry id="td1038">



<code id="pre1037" display="block">  //This method translates and scales
  // a double y value to plot properly
  // in the integer coordinate system.
  // In addition to scaling, it causes
  // the positive direction of the
  // y-axis to be from bottom to top.
  int getTheY(double y){
    double yDoub = (yMax+yMin)-y;
    int yInt = (int)(yDoub*yScale);
    return yInt;
  }//end getTheY
  //---------------------------------//

  //This method scales a double x value
  // to plot properly in the integer
  // coordinate system.
  int getTheX(double x){
    return (int)(x*xScale);
  }//end getTheX
  //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1225">
<link id="a1221" target-id="Listing_35">

Listing 35

</link>

 also marks the end of the inner class named 

<emphasis id="strong1227" effect="bold">
MyCanvas

</emphasis>
 
and the end of the class named 

<emphasis id="strong1228" effect="bold">
GUI

</emphasis>
.

</para>





</section>
<section id="h31042">
<title>
<emphasis id="The_test_class_named_junk" effect="bold">

The test class named junk

</emphasis>

 

</title>




<para id="p1226">
<link id="a1222" target-id="Listing_36">

Listing 36

</link>

 defines a test class named 

<emphasis id="strong1229" effect="bold">
junk

</emphasis>
 that implements the interface 
named 

<emphasis id="strong1230" effect="bold">
GraphIntfc01

</emphasis>
.

</para>





<table id="table1039" summary="This is a table." pgwide="677">
<tgroup cols="1">


<thead id="thead1039">
<row id="tr1078">



<entry id="th1039">
<emphasis id="Listing_36" effect="bold">

Listing 36.

</emphasis>

 The test class named junk.

</entry>
</row>
</thead>


<tbody id="tbody1039">
<row id="tr1079">
<entry id="td1039">



<code id="pre1038" display="block">//Sample test class.  Required for
// compilation and stand-alone
// testing.
class junk implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 4;
  }//end getNmbr

  public double f1(double x){
    return (x*x*x)/200.0;
  }//end f1

  public double f2(double x){
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    return (x*x)/200.0;
  }//end f3

  public double f4(double x){
    return 50*Math.cos(x/10.0);
  }//end f4

  public double f5(double x){
    return 100*Math.sin(x/20.0);
  }//end f5

}//end sample class junk</code>




</entry>
</row>
</tbody>


</tgroup>
</table>




<para id="p1227">
This class defines the methods declared in the interface, and makes it 
possible to test the plotting program in a stand-alone mode without having 
access to another class that implements the interface. 

</para>





<para id="p1228">
Since I discussed the implementation of this interface in some detail earlier 
in the module, there should be no need for me to provide further discussion of 
the code in 

<link id="a1223" target-id="Listing_36">

Listing 36

</link>

. You might note, however, that since the method named


<emphasis id="strong1231" effect="bold">
getNmbr

</emphasis>
 returns the value 4, the method named 

<emphasis id="strong1232" effect="bold">
f5

</emphasis>
 
will not be called by the plotting program.

</para>





<para id="p1229">
<link id="a1224" target-id="Figure_4">

Figure 4

</link>

 shows the type of output produced by this self-test class.

</para>





</section>
</section>
<section id="h21012">
<title>
<emphasis id="The_program_named_Graph02" effect="bold">

The program named Graph02

</emphasis>


</title>




<para id="p1230">
As I mentioned earlier, the program named 

<emphasis id="strong1233" effect="bold">
Graph02

</emphasis>
, shown in 


<link id="a1225" target-id="Listing_40">

Listing 40

</link>

, can also be used to plot as many as five separate functions. The 
graphs produced by the functions are superimposed in the same plotting area. 
This is simply an alternative display format. A sample output from 

<emphasis id="strong1234" effect="bold">

Graph02

</emphasis>
 is shown in 

<link id="a1226" target-id="Figure_5">

Figure 5

</link>

.

</para>







<table id="table1040" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1040">
<row id="tr1080">
<entry id="th1040">



<emphasis id="Figure_5" effect="bold">

Figure 5.

</emphasis>

 Sample output format from Graph02.


</entry>
</row>
</thead>


<tbody id="tbody1040">
<row id="tr1081">
<entry id="td1040">



<media id="media1004" alt="missing image" display="block">
<image id="img1004" mime-type="image/jpeg" src="../../media/java1468e.jpg" width="401" height="431"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>





<para id="p1231">
Because of the similarity of this program to 

<emphasis id="strong1235" effect="bold">
Graph01

</emphasis>
, I won't discuss any of the particulars of 
this program. If you understand the program named 

<emphasis id="strong1236" effect="bold">
Graph01

</emphasis>
, 
you should have no difficulty understanding the program named 

<emphasis id="strong1237" effect="bold">
Graph02

</emphasis>
  
as well.

</para>






</section>
</section>
<section id="h11004">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the program

</emphasis>


</title>





<para id="p1232">
Copy the code for the plotting program from 

<link id="a1227" target-id="Listing_39">

Listing 39

</link>

 into a Java source 
file named 

<emphasis id="strong1238" effect="bold">
Graph01.java

</emphasis>
.

</para>





<para id="p1233">
Copy the code for the interface from 

<link id="a1228" target-id="Listing_1">

Listing 1

</link>

 into a Java source file named


<emphasis id="strong1239" effect="bold">
GraphIntfc01.java

</emphasis>
.

</para>





<para id="p1234">
Compile and run the program named 

<emphasis id="strong1240" effect="bold">
Graph01

</emphasis>
 with no 
command-line arguments. This should use the internal test class named 

<emphasis id="strong1241" effect="bold">

junk

</emphasis>
 discussed earlier to produce a display similar to that shown in 


<link id="a1229" target-id="Figure_4">

Figure 4

</link>

.

</para>





<para id="p1235">
Once you have the display on your screen, make changes to the plotting 
parameters in the text fields at the bottom and press the button labeled 

<emphasis id="strong1242" effect="bold">

Graph

</emphasis>
. When you do, you should see the same functions being re-plotted 
with different plotting parameters.

</para>





<para id="p1236">
Once that is successful, copy the code in 

<link id="a1230" target-id="Listing_37">

Listing 37

</link>

 into a file named


<emphasis id="strong1243" effect="bold">
Graph01Demo.java

</emphasis>
. Copy the code in 

<link id="a1231" target-id="Listing_38">

Listing 38

</link>

 into a file named


<emphasis id="strong1244" effect="bold">
Dsp002.java

</emphasis>
.

</para>





<para id="p1237">
Compile these two files. Rerun the plotting program named 

<emphasis id="strong1245" effect="bold">
Graph01

</emphasis>
 
providing 

<emphasis id="strong1246" effect="bold">
Graph01Demo

</emphasis>
 as a command-line argument. Also rerun 
the plotting program providing 

<emphasis id="strong1247" effect="bold">
Dsp002

</emphasis>
 as a command-line 
argument. This should produce displays similar to 

<link id="a1232" target-id="Figure_1">

Figure 1

</link>

 and 

<link id="a1233" target-id="Figure_3">

Figure 3

</link>

. 

<emphasis id="em1073" effect="italics">

(You may need to adjust some of the plotting parameters at the bottom to make 
them match. Also remember that 

<link id="a1234" target-id="Figure_3">

Figure 3

</link>

 was produced using random data so it 
won't be possible to match it exactly.)

</emphasis>
</para>





<para id="p1238">
You must be running Java version 1.4 or later to successfully compile and 
execute this program.

</para>





</section>
<section id="h11005">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1239">
I provided two generalized plotting programs in this module. One of the 
programs plots up to five functions in a vertical stack. The other program 
superimposes the plots for up to five functions on the same Cartesian coordinate 
system.

</para>





<para id="p1240">
Each of these programs is capable of plotting the data produced by any object 
that implements a simple interface named 

<emphasis id="strong1248" effect="bold">
GraphIntfc01

</emphasis>
.

</para>





<para id="p1241">
I explained the interface named 

<emphasis id="strong1249" effect="bold">
GraphIntfc01

</emphasis>
. I also 
explained how you can define classes of your own that implement the interface 
making them suitable for being plotted using either of the plotting programs.

</para>





<para id="p1242">
I also provided two different sample classes that implement the interface for 
you to use as models as you come up to speed in defining your own classes.

</para>





</section>
<section id="h11006">
<title>
<emphasis id="Complete_program_listings" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1243">
Complete listings of the programs discussed in this module are shown below.

</para>






<table id="table1041" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1041">
<row id="tr1082">
<entry id="th1041">



<emphasis id="Listing_37" effect="bold">

Listing 37.

</emphasis>

 Graph01Demo.java.

</entry>
</row>
</thead>


<tbody id="tbody1041">
<row id="tr1083">
<entry id="td1041">



<code id="pre1039" display="block">/* File Graph01Demo.java
Copyright 2002, R.G.Baldwin

This class is used to demonstrate how 
to write data-generator classes that
will operate successfully with the
program named Graph01.

Tested using JDK 1.8 under Win 7.
**************************************/
class Graph01Demo 
               implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 5;
  }//end getNmbr

  public double f1(double x){
    //This is a simple x-squared
    // function with a negative
    // sign.
    return -(x*x)/200.0;
  }//end f1

  public double f2(double x){
    //This is a simple x-cubed
    // function
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    //This is a simple cosine
    // function
    return 100*Math.cos(x/10.0);
  }//end f3

  public double f4(double x){
    //This is a simple sine
    // function
    return 100*Math.sin(x/20.0);
  }//end f4

  public double f5(double x){
    //This is function which
    // returns the product of
    // the above sine and cosines.
    return 100*(Math.sin(x/20.0)
                    *Math.cos(x/10.0));
  }//end f5

}//end sample class Graph01Demo</code>




</entry>
</row>
</tbody>


</tgroup>
</table>






<table id="table1042" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1042">
<row id="tr1084">
<entry id="th1042">



<emphasis id="Listing_38" effect="bold">

Listing 38.

</emphasis>

 Dsp002.java,

</entry>
</row>
</thead>


<tbody id="tbody1042">
<row id="tr1085">
<entry id="td1042">



<code id="pre1040" display="block">/* File Dsp002.java
Copyright 2002, R.G.Baldwin

Note:  This program requires access to
the interface named GraphIntfc01.

This is a sample DSP program whose
output is designed to be plotted
by the programs named Graph01 and
Graph02.  This requires that the
class implement GraphIntfc01.  It
also requires a noarg constructor.

This program applies a narrow-band
convolution filter to white noise, and
then computes the amplitude spectrum of
the filtered result using a simple
Discrete Fourier Transform (DFT)
algorithm.  The spectrum of the white
noise is also computed.

The program convolves a 33-point
sinusoidal convolution filter with
wide-band noise, and then computes the
amplitude spectrum of the raw data and
the filtered result.  The processing
occurs when an object of the class is
instantiated.

The input noise, the filter, the
filtered output, and the two spectra
are deposited in five arrays for
later retrieval and display.

The input noise, the filter, the
filtered output, the spectrum of the
noise, and the spectrum of the filtered
result are returned by the methods
named f1, f2, f3, f4, and f5
respectively.

The output values that are returned
are scaled for appropriate display in
the plotting areas provided by the
program named Graph01.

Tested using JDK 1.8 under Win 7.
**************************************/
import java.util.*;

class Dsp002 implements GraphIntfc01{
  //Establish data and spectrum
  // lengths.
  int operatorLen = 33;
  int dataLen = 256+operatorLen;
  int outputLen =
                 dataLen - operatorLen;
  int spectrumPts = outputLen;

  //Create arrays for the data and
  // the results.
  double[] data = new double[dataLen];
  double[] operator =
               new double[operatorLen];
  double[] output =
                 new double[outputLen];
  double[] spectrumA =
               new double[spectrumPts];
  double[] spectrumB =
               new double[spectrumPts];

  public Dsp002(){//constructor
    //Generate and save some wide-band
    // random noise.  Seed with a
    // different value each time the
    // object is constructed.
    Random generator = new Random(
                 new Date().getTime());
    for(int cnt=0;cnt &lt; data.length;
                                cnt++){
      //Get data, scale it, remove the
      // dc offset, and save it.
      data[cnt] = 100*generator.
                       nextDouble()-50;
    }//end for loop

    //Create a convolution operator and
    // save it in the array.
    for(int cnt = 0; cnt &lt; operatorLen;
                                cnt++){
      //Note, the value of the
      // denominator in the argument
      // to the cos method specifies
      // the frequency relative to the
      // sampling frequency.
      operator[cnt] = Math.cos(
                      cnt*2*Math.PI/4);
    }//end for loop

    //Apply the operator to the data
    Convolve01.convolve(data,dataLen,
          operator,operatorLen,output);

    //Compute DFT of the raw data and
    // save it in spectrumA array.
    Dft01.dft(data,spectrumPts,
                            spectrumA);

    //Compute DFT of the filtered data
    // and save it in spectrumB array.
    Dft01.dft(output,spectrumPts,
                            spectrumB);
    //All of the data has now been
    // produced and saved.  It may be
    // retrieved by invoking the
    // following methods named f1
    // through f5.

  }//end constructor

  //---------------------------------//
  //The following six methods are
  // required by the interface named
  // GraphIntfc01.
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 5;
  }//end getNmbr
  //---------------------------------//
  public double f1(double x){
    int index = (int)Math.round(x);
    //This version of this method
    // returns the random noise data.
    // Be careful to stay within the
    // array bounds.
    if(index &lt; 0 ||
                index &gt; data.length-1){
      return 0;
    }else{
      return data[index];
    }//end else
  }//end f1
  //---------------------------------//
  public double f2(double x){
    //Return the convolution operator
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
            index &gt; operator.length-1){
      return 0;
    }else{
      //Scale for good visibility in
      // the plot
      return operator[index] * 50;
    }//end else
  }//end f2
  //---------------------------------//
  public double f3(double x){
    //Return filtered output
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
              index &gt; output.length-1){
      return 0;
    }else{
      //Scale to approx same p-p as
      // input data
      return output[index]/6;
    }//end else
  }//end f3
  //---------------------------------//
  public double f4(double x){
    //Return spectrum of raw data
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
           index &gt; spectrumA.length-1){
      return 0;
    }else{
      //Scale for good visibility in
      // the plot.
      return spectrumA[index]/10;
    }//end else
  }//end f4
  //---------------------------------//
  public double f5(double x){
    //Return the spectrum of the
    // filtered data.
    int index = (int)Math.round(x);
    if(index &lt; 0 ||
           index &gt; spectrumB.length-1){
      return 0;
    }else{
      //Scale for good visibility in
      // the plot.
      return spectrumB[index]/100;
    }//end else
  }//end f5

}//end sample class Dsp002
//===================================//

//This class provides a static method
// named convolve, which applies an
// incoming convolution operator to
// an incoming set of data and deposits
// the filtered data in an output
// array whose reference is received
// as an incoming parameter.
//This class could easily be broken out
// and put in a library as a stand-
// alone class, or the convolve method
// could be added to a class containing
// a variety of DSP methods.
class Convolve01{
  public static void convolve(
                     double[] data,
                     int dataLen,
                     double[] operator,
                     int operatorLen,
                     double[] output){
    //Apply the operator to the data,
    // dealing with the index
    // reversal required by
    // convolution.
    for(int i=0;
          i &lt; dataLen-operatorLen;i++){
      output[i] = 0;
      for(int j=operatorLen-1;j&gt;=0;
                                  j--){
        output[i] +=
                 data[i+j]*operator[j];
      }//end inner loop
    }//end outer loop
  }//end convolve method
}//end Class Convolve01
//===================================//

//This class provides a static method
// named dft, which computes and
// returns the amplitude spectrum of
// an incoming time series.  The
// amplitude spectrum is computed as
// the square root of the sum of the
// squares of the real and imaginary
// parts.
//Returns a number of points in the
// frequency domain equal to the number
// of samples in the incoming time
// series.  Deposits the frequency
// data in an array whose reference is
// received as an incoming parameter.
//This class could easily be broken out
// and put in a library as a stand-
// alone class, or the dft method
// could be added to a class containing
// a variety of DSP methods.
class Dft01{
  public static void dft(
                    double[] data,
                    int dataLen,
                    double[] spectrum){
    //Set the frequency increment to
    // the reciprocal of the data
    // length.  This is convenience
    // only, and is not a requirement
    // of the DFT algorithm.
    double delF = 1.0/dataLen;
    //Outer loop iterates on frequency
    // values.
    for(int i=0; i &lt; dataLen;i++){
      double freq = i*delF;
      double real = 0;
      double imag = 0;
      //Inner loop iterates on time-
      // series points.
      for(int j=0; j &lt; dataLen; j++){
        real += data[j]*Math.cos(
                     2*Math.PI*freq*j);
        imag += data[j]*Math.sin(
                     2*Math.PI*freq*j);
        spectrum[i] = Math.sqrt(
                real*real + imag*imag);
      }//end inner loop
    }//end outer loop
  }//end dft

}//end Dft01

//===================================//</code>




</entry>
</row>
</tbody>


</tgroup>
</table>


	



<table id="table1043" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1043">
<row id="tr1086">
<entry id="th1043">



<emphasis id="Listing_39" effect="bold">

Listing 39.

</emphasis>

 Graph01.java.

</entry>
</row>
</thead>


<tbody id="tbody1043">
<row id="tr1087">
<entry id="td1043">



<code id="pre1041" display="block">/* File Graph01.java
Copyright 2002, R.G.Baldwin

Note:  This program requires access to
the interface named GraphIntfc01.

This is a plotting program.  It is
designed to access a class file, which
implements GraphIntfc01, and to plot up
to five functions defined in that class
file.  The plotting surface is divided
into the required number of equally
sized plotting areas, and one function
is plotted on Cartesian coordinates in
each area.

The methods corresponding to the
functions are named f1, f2, f3, f4,
and f5.

The class containing the functions must
also define a static method named
getNmbr(), which takes no parameters
and returns the number of functions to
be plotted.  If this method returns a
value greater than 5, a
NoSuchMethodException will be thrown.

Note that the constructor for the class
that implements GraphIntfc01 must not
require any parameters due to the
use of the newInstance method of the
Class class to instantiate an object
of that class.

If the number of functions is less
than 5, then the absent method names
must begin with f5 and work down toward
f1.  For example, if the number of
functions is 3, then the program will
expect to call methods named f1, f2,
and f3.  It is OK for the absent
methods to be defined in the class.
They simply won't be invoked.

The plotting areas have alternating
white and gray backgrounds to make them
easy to separate visually.

All curves are plotted in black.  A
Cartesian coordinate system with axes,
tic marks, and labels is drawn in red
in each plotting area.

The Cartesian coordinate system in each
plotting area has the same horizontal
and vertical scale, as well as the
same tic marks and labels on the axes.

The labels displayed on the axes,
correspond to the values of the extreme
edges of the plotting area.

The program also compiles a sample
class named junk, which contains five
methods and the method named getNmbr.
This makes it easy to compile and test
this program in a stand-alone mode.

At runtime, the name of the class that
implements the GraphIntfc01 interface
must be provided as a command-line
parameter.  If this parameter is
missing, the program instantiates an
object from the internal class named
junk and plots the data provided by
that class.  Thus, you can test the
program by running it with no
command-line parameter.

This program provides the following
text fields for user input, along with
a button labeled Graph.  This allows
the user to adjust the parameters and
replot the graph as many times with as
many plotting scales as needed:

xMin = minimum x-axis value
xMax = maximum x-axis value
yMin = minimum y-axis value
yMax = maximum y-axis value
xTicInt = tic interval on x-axis
yTicInt = tic interval on y-axis
xCalcInc = calculation interval

The user can modify any of these
parameters and then click the Graph
button to cause the five functions
to be re-plotted according to the
new parameters.

Whenever the Graph button is clicked,
the event handler instantiates a new
object of the class that implements
the GraphIntfc01 interface.  Depending
on the nature of that class, this may
be redundant in some cases.  However,
it is useful in those cases where it
is necessary to refresh the values of
instance variables defined in the
class (such as a counter, for example).

Tested using JDK 1.8 under Win 7.

This program uses constants that were
first defined in the Color class of
v1.4.0.  Therefore, the program
requires v1.4.0 or later to compile and
run correctly.
**************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph01{
  public static void main(
          String[] args)
          throws NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{
    if(args.length == 1){
      //pass command-line parameter
      new GUI(args[0]);
    }else{
      //no command-line parameter given
      new GUI(null);
    }//end else
  }// end main
}//end class Graph01 definition
//===================================//

class GUI extends JFrame
             implements ActionListener{

  //Define plotting parameters and
  // their default values.
  double xMin = 0.0;
  double xMax = 400.0;
  double yMin = -100.0;
  double yMax = 100.0;

  //Tic mark intervals
  double xTicInt = 20.0;
  double yTicInt = 20.0;

  //Tic mark lengths.  If too small
  // on x-axis, a default value is
  // used later.
  double xTicLen = (yMax-yMin)/50;
  double yTicLen = (xMax-xMin)/50;

  //Calculation interval along x-axis
  double xCalcInc = 1.0;

  //Text fields for plotting parameters
  JTextField xMinTxt =
             new JTextField("" + xMin);
  JTextField xMaxTxt =
             new JTextField("" + xMax);
  JTextField yMinTxt =
             new JTextField("" + yMin);
  JTextField yMaxTxt =
             new JTextField("" + yMax);
  JTextField xTicIntTxt =
          new JTextField("" + xTicInt);
  JTextField yTicIntTxt =
          new JTextField("" + yTicInt);
  JTextField xCalcIncTxt =
         new JTextField("" + xCalcInc);

  //Panels to contain a label and a
  // text field
  JPanel pan0 = new JPanel();
  JPanel pan1 = new JPanel();
  JPanel pan2 = new JPanel();
  JPanel pan3 = new JPanel();
  JPanel pan4 = new JPanel();
  JPanel pan5 = new JPanel();
  JPanel pan6 = new JPanel();

  //Misc instance variables
  int frmWidth = 408;
  int frmHeight = 430;
  int width;
  int height;
  int number;
  GraphIntfc01 data;
  String args = null;

  //Plots are drawn on the canvases
  // in this array.
  Canvas[] canvases;

  //Constructor
  GUI(String args)throws
                NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{

    if(args != null){
      //Save for use later in the
      // ActionEvent handler
      this.args = args;
      //Instantiate an object of the
      // target class using the String
      // name of the class.
      data = (GraphIntfc01)
                   Class.forName(args).
                         newInstance();
    }else{
      //Instantiate an object of the
      // test class named junk.
      data = new junk();
    }//end else

    //Create array to hold correct
    // number of Canvas objects.
    canvases =
            new Canvas[data.getNmbr()];

    //Throw exception if number of
    // functions is greater than 5.
    number = data.getNmbr();
    if(number &gt; 5){
      throw new NoSuchMethodException(
                "Too many functions.  "
                  + "Only 5 allowed.");
    }//end if

    //Create the control panel and
    // give it a border for cosmetics.
    JPanel ctlPnl = new JPanel();
    ctlPnl.setLayout(//?rows x 4 cols
                  new GridLayout(0,4));
    ctlPnl.setBorder(
                   new EtchedBorder());

    //Button for replotting the graph
    JButton graphBtn =
                  new JButton("Graph");
    graphBtn.addActionListener(this);

    //Populate each panel with a label
    // and a text field.  Will place
    // these panels in a grid on the
    // control panel later.
    pan0.add(new JLabel("xMin"));
    pan0.add(xMinTxt);

    pan1.add(new JLabel("xMax"));
    pan1.add(xMaxTxt);

    pan2.add(new JLabel("yMin"));
    pan2.add(yMinTxt);

    pan3.add(new JLabel("yMax"));
    pan3.add(yMaxTxt);

    pan4.add(new JLabel("xTicInt"));
    pan4.add(xTicIntTxt);

    pan5.add(new JLabel("yTicInt"));
    pan5.add(yTicIntTxt);

    pan6.add(new JLabel("xCalcInc"));
    pan6.add(xCalcIncTxt);

    //Add the populated panels and the
    // button to the control panel with
    // a grid layout.
    ctlPnl.add(pan0);
    ctlPnl.add(pan1);
    ctlPnl.add(pan2);
    ctlPnl.add(pan3);
    ctlPnl.add(pan4);
    ctlPnl.add(pan5);
    ctlPnl.add(pan6);
    ctlPnl.add(graphBtn);

    //Create a panel to contain the
    // Canvas objects.  They will be
    // displayed in a one-column grid.
    JPanel canvasPanel = new JPanel();
    canvasPanel.setLayout(//?rows,1 col
                  new GridLayout(0,1));

    //Create a custom Canvas object for
    // each function to be plotted and
    // add them to the one-column grid.
    // Make background colors alternate
    // between white and gray.
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      switch(cnt){
        case 0 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 1 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 2 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                          Color.WHITE);
          break;
        case 3 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].setBackground(
                     Color.LIGHT_GRAY);
          break;
        case 4 :
          canvases[cnt] =
                     new MyCanvas(cnt);
          canvases[cnt].
            setBackground(Color.WHITE);
      }//end switch
      //Add the object to the grid.
      canvasPanel.add(canvases[cnt]);
    }//end for loop

    //Add the sub-assemblies to the
    // frame.  Set its location, size,
    // and title, and make it visible.
    getContentPane().
                   add(ctlPnl,"South");
    getContentPane().
             add(canvasPanel,"Center");

    setBounds(0,0,frmWidth,frmHeight);
    setTitle("Graph01, " +
                 "Copyright 2002, " +
                 "Richard G. Baldwin");
    setVisible(true);

    //Set to exit on X-button click
    setDefaultCloseOperation(
                        EXIT_ON_CLOSE);

    //Get and save the size of the
    // plotting surface
    width = canvases[0].getWidth();
    height = canvases[0].getHeight();

    //Guarantee a repaint on startup.
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end constructor
  //---------------------------------//

  //This event handler is registered
  // on the JButton to cause the
  // functions to be replotted.
  public void actionPerformed(
                      ActionEvent evt){
    //Re-instantiate the object that
    // provides the data
    try{
      if(args != null){
        data = (GraphIntfc01)Class.
           forName(args).newInstance();
      }else{
        data = new junk();
      }//end else
    }catch(Exception e){
      //Known to be safe at this point.
      // Otherwise would have aborted
      // earlier.
    }//end catch

    //Set plotting parameters using
    // data from the text fields.
    xMin = Double.parseDouble(
                    xMinTxt.getText());
    xMax = Double.parseDouble(
                    xMaxTxt.getText());
    yMin = Double.parseDouble(
                    yMinTxt.getText());
    yMax = Double.parseDouble(
                    yMaxTxt.getText());
    xTicInt = Double.parseDouble(
                 xTicIntTxt.getText());
    yTicInt = Double.parseDouble(
                 yTicIntTxt.getText());
    xCalcInc = Double.parseDouble(
                xCalcIncTxt.getText());

    //Calculate new values for the
    // length of the tic marks on the
    // axes.  If too small on x-axis,
    // a default value is used later.
    xTicLen = (yMax-yMin)/50;
    yTicLen = (xMax-xMin)/50;

    //Repaint the plotting areas
    for(int cnt = 0;
                  cnt &lt; number; cnt++){
      canvases[cnt].repaint();
    }//end for loop

  }//end actionPerformed
  //---------------------------------//


//This is an inner class, which is used
// to override the paint method on the
// plotting surface.
class MyCanvas extends Canvas{
  int cnt;//object number
  //Factors to convert from double
  // values to integer pixel locations.
  double xScale;
  double yScale;

  MyCanvas(int cnt){//save obj number
    this.cnt = cnt;
  }//end constructor

  //Override the paint method
  public void paint(Graphics g){
    //Calculate the scale factors
    xScale = width/(xMax-xMin);
    yScale = height/(yMax-yMin);

    //Set the origin based on the
    // minimum values in x and y
    g.translate((int)((0-xMin)*xScale),
               (int)((0-yMin)*yScale));
    drawAxes(g);//Draw the axes
    g.setColor(Color.BLACK);

    //Get initial data values
    double xVal = xMin;
    int oldX = getTheX(xVal);
    int oldY = 0;
    //Use the Canvas obj number to
    // determine which method to
    // invoke to get the value for y.
    switch(cnt){
      case 0 :
        oldY = getTheY(data.f1(xVal));
        break;
      case 1 :
        oldY = getTheY(data.f2(xVal));
        break;
      case 2 :
        oldY = getTheY(data.f3(xVal));
        break;
      case 3 :
        oldY = getTheY(data.f4(xVal));
        break;
      case 4 :
        oldY = getTheY(data.f5(xVal));
    }//end switch

    //Now loop and plot the points
    while(xVal &lt; xMax){
      int yVal = 0;
      //Get next data value.  Use the
      // Canvas obj number to
      // determine which method to
      // invoke to get the value for y.
      switch(cnt){
        case 0 :
          yVal =
                getTheY(data.f1(xVal));
          break;
        case 1 :
          yVal =
                getTheY(data.f2(xVal));
          break;
        case 2 :
          yVal =
                getTheY(data.f3(xVal));
          break;
        case 3 :
          yVal =
                getTheY(data.f4(xVal));
          break;
        case 4 :
          yVal =
                getTheY(data.f5(xVal));
      }//end switch1

      //Convert the x-value to an int
      // and draw the next line segment
      int x = getTheX(xVal);
      g.drawLine(oldX,oldY,x,yVal);

      //Increment along the x-axis
      xVal += xCalcInc;

      //Save end point to use as start
      // point for next line segment.
      oldX = x;
      oldY = yVal;
    }//end while loop

  }//end overridden paint method
  //---------------------------------//

  //Method to draw axes with tic marks
  // and labels in the color RED
  void drawAxes(Graphics g){
    g.setColor(Color.RED);

    //Label left x-axis and bottom
    // y-axis.  These are the easy
    // ones.  Separate the labels from
    // the ends of the tic marks by
    // two pixels.
    g.drawString("" + (int)xMin,
                 getTheX(xMin),
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMin,
                  getTheX(yTicLen/2)+2,
                        getTheY(yMin));

    //Label the right x-axis and the
    // top y-axis.  These are the hard
    // ones because the position must
    // be adjusted by the font size and
    // the number of characters.
    //Get the width of the string for
    // right end of x-axis and the
    // height of the string for top of
    // y-axis
    //Create a string that is an
    // integer representation of the
    // label for the right end of the
    // x-axis.  Then get a character
    // array that represents the
    // string.
    int xMaxInt = (int)xMax;
    String xMaxStr = "" + xMaxInt;
    char[] array = xMaxStr.
                         toCharArray();

    //Get a FontMetrics object that can
    // be used to get the size of the
    // string in pixels.
    FontMetrics fontMetrics =
                    g.getFontMetrics();
    //Get a bounding rectangle for the
    // string
    Rectangle2D r2d =
           fontMetrics.getStringBounds(
               array,0,array.length,g);
    //Get the width and the height of
    // the bounding rectangle.  The
    // width is the width of the label
    // at the right end of the
    // x-axis.  The height applies to
    // all the labels, but is needed
    // specifically for the label at
    // the top end of the y-axis.
    int labWidth =
                 (int)(r2d.getWidth());
    int labHeight =
                (int)(r2d.getHeight());

    //Label the positive x-axis and the
    // positive y-axis using the width
    // and height from above to
    // position the labels.  These
    // labels apply to the very ends of
    // the axes at the edge of the
    // plotting surface.
    g.drawString("" + (int)xMax,
                getTheX(xMax)-labWidth,
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMax,
              getTheX(yTicLen/2)+2,
              getTheY(yMax)+labHeight);

    //Draw the axes
    g.drawLine(getTheX(xMin),
                         getTheY(0.0),
                         getTheX(xMax),
                         getTheY(0.0));

    g.drawLine(getTheX(0.0),
                        getTheY(yMin),
                        getTheX(0.0),
                        getTheY(yMax));

    //Draw the tic marks on axes
    xTics(g);
    yTics(g);
  }//end drawAxes

  //---------------------------------//

  //Method to draw tic marks on x-axis
  void xTics(Graphics g){
    double xDoub = 0;
    int x = 0;

    //Get the ends of the tic marks.
    int topEnd = getTheY(xTicLen/2);
    int bottomEnd =
                   getTheY(-xTicLen/2);

    //If the vertical size of the
    // plotting area is small, the
    // calculated tic size may be too
    // small.  In that case, set it to
    // 10 pixels.
    if(topEnd &lt; 5){
      topEnd = 5;
      bottomEnd = -5;
    }//end if

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive x-axis
    // moving to the right from zero.
    while(xDoub &lt; xMax){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub += xTicInt;
    }//end while

    //Now do the negative x-axis moving
    // to the left from zero
    xDoub = 0;
    while(xDoub &gt; xMin){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub -= xTicInt;
    }//end while

  }//end xTics
  //---------------------------------//

  //Method to draw tic marks on y-axis
  void yTics(Graphics g){
    double yDoub = 0;
    int y = 0;
    int rightEnd = getTheX(yTicLen/2);
    int leftEnd = getTheX(-yTicLen/2);

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive y-axis
    // moving up from zero.
    while(yDoub &lt; yMax){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub += yTicInt;
    }//end while

    //Now do the negative y-axis moving
    // down from zero.
    yDoub = 0;
    while(yDoub &gt; yMin){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub -= yTicInt;
    }//end while

  }//end yTics

  //---------------------------------//

  //This method translates and scales
  // a double y value to plot properly
  // in the integer coordinate system.
  // In addition to scaling, it causes
  // the positive direction of the
  // y-axis to be from bottom to top.
  int getTheY(double y){
    double yDoub = (yMax+yMin)-y;
    int yInt = (int)(yDoub*yScale);
    return yInt;
  }//end getTheY
  //---------------------------------//

  //This method scales a double x value
  // to plot properly in the integer
  // coordinate system.
  int getTheX(double x){
    return (int)(x*xScale);
  }//end getTheX
  //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI
//===================================//

//Sample test class.  Required for
// compilation and stand-alone
// testing.
class junk implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 4;
  }//end getNmbr

  public double f1(double x){
    return (x*x*x)/200.0;
  }//end f1

  public double f2(double x){
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    return (x*x)/200.0;
  }//end f3

  public double f4(double x){
    return 50*Math.cos(x/10.0);
  }//end f4

  public double f5(double x){
    return 100*Math.sin(x/20.0);
  }//end f5

}//end sample class junk</code>




</entry>
</row>
</tbody>


</tgroup>
</table>


	



<table id="table1044" summary="This is a table." pgwide="630">
<tgroup cols="1">


<thead id="thead1044">
<row id="tr1088">
<entry id="th1044">



<emphasis id="Listing_40" effect="bold">

Listing 40.

</emphasis>

 Graph02.java.


</entry>
</row>
</thead>


<tbody id="tbody1044">
<row id="tr1089">
<entry id="td1044">



<code id="pre1042" display="block">/* File Graph02.java
Copyright 2002, R.G.Baldwin

Note:  This program requires access to
the interface named GraphIntfc01.

This is a modified version of the
program named Graph01.  That program
plots up to five separate curves in
separate plotting areas.  This program
superimposes up to five separate curves
in different colors in the same
plotting area.

This is a plotting program.  It is
designed to access a class file, which
implements GraphIntfc01, and to plot up
to five functions defined in that class
file.

The methods corresponding to the
functions are named f1, f2, f3, f4,
and f5.

The class containing the functions must
also define a static method named
getNmbr(), which takes no parameters
and returns the number of functions to
be plotted.  If this method returns a
value greater than 5, a
NoSuchMethodException will be thrown.

Note that the constructor for the class
that implements GraphIntfc01 must not
require any parameters due to the
use of the newInstance method of the
Class class to instantiate an object
of that class.

If the number of functions is less
than 5, then the absent method names
must begin with f5 and work down toward
f1.  For example, if the number of
functions is 3, then the program will
expect to call methods named f1, f2,
and f3.  It is OK for the absent
methods to be defined in the class.
They simply won't be invoked.

Each curve is plotted in a different
color.  The correspondence between
colors and function calls is as
follows:

f1: BLACK
f2: BLUE
f3: RED
f4: MAGENTA
f5: CYAN

A Cartesian coordinate system with
axes, tic marks, and labels is drawn in
green.

The labels displayed on the axes,
correspond to the values of the extreme
edges of the plotting area.

The program also compiles a sample
class named junk, which contains five
methods and the method named getNmbr.
This makes it easy to compile and test
this program in a stand-alone mode.

At runtime, the name of the class that
implements the GraphIntfc01 interface
must be provided as a command-line
parameter.  If this parameter is
missing, the program instantiates an
object from the internal class named
junk and plots the data provided by
that class.  Thus, you can test the
program by running it with no
command-line parameter.

This program provides the following
text fields for user input, along with
a button labeled Graph.  This allows
the user to adjust the parameters and
replot the graph as many times with as
many plotting scales as needed:

xMin = minimum x-axis value
xMax = maximum x-axis value
yMin = minimum y-axis value
yMax = maximum y-axis value
xTicInt = tic interval on x-axis
yTicInt = tic interval on y-axis
xCalcInc = calculation interval

The user can modify any of these
parameters and then click the Graph
button to cause the five functions
to be re-plotted according to the
new parameters.

Whenever the Graph button is clicked,
the event handler instantiates a new
object of the class that implements
the GraphIntfc01 interface.  Depending
on the nature of that class, this may
be redundant in some cases.  However,
it is useful in those cases where it
is necessary to refresh the values of
instance variables defined in the
class (such as a counter, for example).

Tested using JDK 1.8 under Win 7.

This program uses constants that were
first defined in the Color class of
v1.4.0.  Therefore, the program
requires v1.4.0 or later to compile and
run correctly.
**************************************/

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;
import javax.swing.border.*;

class Graph02{
  public static void main(
          String[] args)
          throws NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{
    if(args.length == 1){
      //pass command-line parameter
      new GUI(args[0]);
    }else{
      //no command-line parameter given
      new GUI(null);
    }//end else
  }// end main
}//end class Graph02 definition
//===================================//

class GUI extends JFrame
             implements ActionListener{

  //Define plotting parameters and
  // their default values.
  double xMin = 0.0;
  double xMax = 400.0;
  double yMin = -100.0;
  double yMax = 100.0;

  //Tic mark intervals
  double xTicInt = 20.0;
  double yTicInt = 20.0;

  //Tic mark lengths.  If too small
  // on x-axis, a default value is
  // used later.
  double xTicLen = (yMax-yMin)/50;
  double yTicLen = (xMax-xMin)/50;

  //Calculation interval along x-axis
  double xCalcInc = 1.0;

  //Text fields for plotting parameters
  JTextField xMinTxt =
             new JTextField("" + xMin);
  JTextField xMaxTxt =
             new JTextField("" + xMax);
  JTextField yMinTxt =
             new JTextField("" + yMin);
  JTextField yMaxTxt =
             new JTextField("" + yMax);
  JTextField xTicIntTxt =
          new JTextField("" + xTicInt);
  JTextField yTicIntTxt =
          new JTextField("" + yTicInt);
  JTextField xCalcIncTxt =
         new JTextField("" + xCalcInc);

  //Panels to contain a label and a
  // text field
  JPanel pan0 = new JPanel();
  JPanel pan1 = new JPanel();
  JPanel pan2 = new JPanel();
  JPanel pan3 = new JPanel();
  JPanel pan4 = new JPanel();
  JPanel pan5 = new JPanel();
  JPanel pan6 = new JPanel();

  //Misc instance variables
  int frmWidth = 408;
  int frmHeight = 430;
  int width;
  int height;
  int number;
  GraphIntfc01 data;
  String args = null;

  //Plots are drawn on theCanvas
  Canvas theCanvas;

  //Constructor
  GUI(String args)throws
                NoSuchMethodException,
                ClassNotFoundException,
                InstantiationException,
                IllegalAccessException{

    if(args != null){
      //Save for use later in the
      // ActionEvent handler
      this.args = args;
      //Instantiate an object of the
      // target class using the String
      // name of the class.
      data = (GraphIntfc01)
                   Class.forName(args).
                         newInstance();
    }else{
      //Instantiate an object of the
      // test class named junk.
      data = new junk();
    }//end else

    //Throw exception if number of
    // functions is greater than 5.
    number = data.getNmbr();
    if(number &gt; 5){
      throw new NoSuchMethodException(
                "Too many functions.  "
                  + "Only 5 allowed.");
    }//end if

    //Create the control panel and
    // give it a border for cosmetics.
    JPanel ctlPnl = new JPanel();
    ctlPnl.setLayout(//?rows x 4 cols
                  new GridLayout(0,4));
    ctlPnl.setBorder(
                   new EtchedBorder());

    //Button for replotting the graph
    JButton graphBtn =
                  new JButton("Graph");
    graphBtn.addActionListener(this);

    //Populate each panel with a label
    // and a text field.  Will place
    // these panels in a grid on the
    // control panel later.
    pan0.add(new JLabel("xMin"));
    pan0.add(xMinTxt);

    pan1.add(new JLabel("xMax"));
    pan1.add(xMaxTxt);

    pan2.add(new JLabel("yMin"));
    pan2.add(yMinTxt);

    pan3.add(new JLabel("yMax"));
    pan3.add(yMaxTxt);

    pan4.add(new JLabel("xTicInt"));
    pan4.add(xTicIntTxt);

    pan5.add(new JLabel("yTicInt"));
    pan5.add(yTicIntTxt);

    pan6.add(new JLabel("xCalcInc"));
    pan6.add(xCalcIncTxt);

    //Add the populated panels and the
    // button to the control panel with
    // a grid layout.
    ctlPnl.add(pan0);
    ctlPnl.add(pan1);
    ctlPnl.add(pan2);
    ctlPnl.add(pan3);
    ctlPnl.add(pan4);
    ctlPnl.add(pan5);
    ctlPnl.add(pan6);
    ctlPnl.add(graphBtn);

    //Create a custom Canvas object for
    // all functions to be plotted on.
    theCanvas = new MyCanvas();
    theCanvas.setBackground(
                          Color.WHITE);

    //Add the sub-assemblies to the
    // frame.  Set its location, size,
    // and title, and make it visible.
    getContentPane().add(
                       ctlPnl,"South");
    getContentPane().add(
                   theCanvas,"Center");

    setBounds(0,0,frmWidth,frmHeight);
    setTitle("Graph02, " +
                 "Copyright 2002, " +
                 "Richard G. Baldwin");
    setVisible(true);

    //Set to exit on X-button click
    setDefaultCloseOperation(
                        EXIT_ON_CLOSE);

    //Get and save the size of the
    // plotting surface
    width = theCanvas.getWidth();
    height = theCanvas.getHeight();

    //Guarantee a repaint on startup.
    theCanvas.repaint();

  }//end constructor
  //---------------------------------//

  //This event handler is registered
  // on the JButton to cause the
  // functions to be replotted.
  public void actionPerformed(
                      ActionEvent evt){
    //Re-instantiate the object that
    // provides the data
    try{
      if(args != null){
        data = (GraphIntfc01)Class.
           forName(args).newInstance();
      }else{
        data = new junk();
      }//end else
    }catch(Exception e){
      //Known to be safe at this point.
      // Otherwise would have aborted
      // earlier.
    }//end catch

    //Set plotting parameters using
    // data from the text fields.
    xMin = Double.parseDouble(
                    xMinTxt.getText());
    xMax = Double.parseDouble(
                    xMaxTxt.getText());
    yMin = Double.parseDouble(
                    yMinTxt.getText());
    yMax = Double.parseDouble(
                    yMaxTxt.getText());
    xTicInt = Double.parseDouble(
                 xTicIntTxt.getText());
    yTicInt = Double.parseDouble(
                 yTicIntTxt.getText());
    xCalcInc = Double.parseDouble(
                xCalcIncTxt.getText());

    //Calculate new values for the
    // length of the tic marks on the
    // axes.  If too small on x-axis,
    // a default value is used later.
    xTicLen = (yMax-yMin)/50;
    yTicLen = (xMax-xMin)/50;

    //Repaint the plotting area
    theCanvas.repaint();

  }//end actionPerformed
  //---------------------------------//


//This is an inner class, which is used
// to override the paint method on the
// plotting surface.
class MyCanvas extends Canvas{
  //Factors to convert from double
  // values to integer pixel locations.
  double xScale;
  double yScale;

  //Override the paint method
  public void paint(Graphics g){
    //Calculate the scale factors
    xScale = width/(xMax-xMin);
    yScale = height/(yMax-yMin);

    //Set the origin based on the
    // minimum values in x and y
    g.translate((int)((0-xMin)*xScale),
               (int)((0-yMin)*yScale));
    drawAxes(g);//Draw the axes

    //Draw each curve in a different
    // color.
    for(int cnt=0; cnt &lt; number;
                                cnt++){

      //Get initial data values
      double xVal = xMin;
      int oldX = getTheX(xVal);
      int oldY = 0;
      //Use the curve number to
      // determine which method to
      // invoke to get the value for y.
      switch(cnt){
        case 0 :
          oldY= getTheY(data.f1(xVal));
          g.setColor(Color.BLACK);
          break;
        case 1 :
          oldY= getTheY(data.f2(xVal));
          g.setColor(Color.BLUE);
          break;
        case 2 :
          oldY= getTheY(data.f3(xVal));
          g.setColor(Color.RED);
          break;
        case 3 :
          oldY= getTheY(data.f4(xVal));
          g.setColor(Color.MAGENTA);
          break;
        case 4 :
          oldY= getTheY(data.f5(xVal));
          g.setColor(Color.CYAN);
      }//end switch

      //Now loop and plot the points
      while(xVal &lt; xMax){
        int yVal = 0;
        //Get next data value.  Use the
        // curve number to determine
        // which method to invoke to
        // get the value for y.
        switch(cnt){
          case 0 :
            yVal = getTheY(
                        data.f1(xVal));
            break;
          case 1 :
            yVal = getTheY(
                        data.f2(xVal));
            break;
          case 2 :
            yVal = getTheY(
                        data.f3(xVal));
            break;
          case 3 :
            yVal = getTheY(
                        data.f4(xVal));
            break;
          case 4 :
            yVal = getTheY(
                        data.f5(xVal));
        }//end switch1

        //Convert the x-value to an int
        // and draw the next line
        // segment
        int x = getTheX(xVal);
        g.drawLine(oldX,oldY,x,yVal);

        //Increment along the x-axis
        xVal += xCalcInc;

        //Save end point to use as
        // start point for next line
        // segment.
        oldX = x;
        oldY = yVal;
      }//end while loop

    }//end for loop

  }//end overridden paint method
  //---------------------------------//

  //Method to draw axes with tic marks
  // and labels in the color GREEN
  void drawAxes(Graphics g){
    g.setColor(Color.GREEN);

    //Label left x-axis and bottom
    // y-axis.  These are the easy
    // ones.  Separate the labels from
    // the ends of the tic marks by
    // two pixels.
    g.drawString("" + (int)xMin,
                 getTheX(xMin),
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMin,
                  getTheX(yTicLen/2)+2,
                        getTheY(yMin));

    //Label the right x-axis and the
    // top y-axis.  These are the hard
    // ones because the position must
    // be adjusted by the font size and
    // the number of characters.
    //Get the width of the string for
    // right end of x-axis and the
    // height of the string for top of
    // y-axis
    //Create a string that is an
    // integer representation of the
    // label for the right end of the
    // x-axis.  Then get a character
    // array that represents the
    // string.
    int xMaxInt = (int)xMax;
    String xMaxStr = "" + xMaxInt;
    char[] array = xMaxStr.
                         toCharArray();

    //Get a FontMetrics object that can
    // be used to get the size of the
    // string in pixels.
    FontMetrics fontMetrics =
                    g.getFontMetrics();
    //Get a bounding rectangle for the
    // string
    Rectangle2D r2d =
           fontMetrics.getStringBounds(
               array,0,array.length,g);

    //Get the width and the height of
    // the bounding rectangle.  The
    // width is the width of the label
    // at the right end of the
    // x-axis.  The height applies to
    // all the labels, but is needed
    // specifically for the label at
    // the top end of the y-axis.
    int labWidth =
                 (int)(r2d.getWidth());
    int labHeight =
                (int)(r2d.getHeight());

    //Label the positive x-axis and the
    // positive y-axis using the width
    // and height from above to
    // position the labels.  These
    // labels apply to the very ends of
    // the axes at the edge of the
    // plotting surface.
    g.drawString("" + (int)xMax,
                getTheX(xMax)-labWidth,
                 getTheY(xTicLen/2)-2);
    g.drawString("" + (int)yMax,
              getTheX(yTicLen/2)+2,
              getTheY(yMax)+labHeight);

    //Draw the axes
    g.drawLine(getTheX(xMin),
                         getTheY(0.0),
                         getTheX(xMax),
                         getTheY(0.0));

    g.drawLine(getTheX(0.0),
                        getTheY(yMin),
                        getTheX(0.0),
                        getTheY(yMax));

    //Draw the tic marks on axes
    xTics(g);
    yTics(g);
  }//end drawAxes

  //---------------------------------//

  //Method to draw tic marks on x-axis
  void xTics(Graphics g){
    double xDoub = 0;
    int x = 0;

    //Get the ends of the tic marks.
    int topEnd = getTheY(xTicLen/2);
    int bottomEnd =
                   getTheY(-xTicLen/2);

    //If the vertical size of the
    // plotting area is small, the
    // calculated tic size may be too
    // small.  In that case, set it to
    // 10 pixels.
    if(topEnd &lt; 5){
      topEnd = 5;
      bottomEnd = -5;
    }//end if

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive x-axis
    // moving to the right from zero.
    while(xDoub &lt; xMax){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub += xTicInt;
    }//end while

    //Now do the negative x-axis moving
    // to the left from zero
    xDoub = 0;
    while(xDoub &gt; xMin){
      x = getTheX(xDoub);
      g.drawLine(x,topEnd,x,bottomEnd);
      xDoub -= xTicInt;
    }//end while

  }//end xTics
  //---------------------------------//

  //Method to draw tic marks on y-axis
  void yTics(Graphics g){
    double yDoub = 0;
    int y = 0;
    int rightEnd = getTheX(yTicLen/2);
    int leftEnd = getTheX(-yTicLen/2);

    //Loop and draw a series of short
    // lines to serve as tic marks.
    // Begin with the positive y-axis
    // moving up from zero.
    while(yDoub &lt; yMax){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub += yTicInt;
    }//end while

    //Now do the negative y-axis moving
    // down from zero.
    yDoub = 0;
    while(yDoub &gt; yMin){
      y = getTheY(yDoub);
      g.drawLine(rightEnd,y,leftEnd,y);
      yDoub -= yTicInt;
    }//end while

  }//end yTics

  //---------------------------------//

  //This method translates and scales
  // a double y value to plot properly
  // in the integer coordinate system.
  // In addition to scaling, it causes
  // the positive direction of the
  // y-axis to be from bottom to top.
  int getTheY(double y){
    double yDoub = (yMax+yMin)-y;
    int yInt = (int)(yDoub*yScale);
    return yInt;
  }//end getTheY
  //---------------------------------//

  //This method scales a double x value
  // to plot properly in the integer
  // coordinate system.
  int getTheX(double x){
    return (int)(x*xScale);
  }//end getTheX
  //---------------------------------//

}//end inner class MyCanvas
//===================================//

}//end class GUI
//===================================//

//Sample test class.  Required for
// compilation and stand-alone
// testing.
class junk implements GraphIntfc01{
  public int getNmbr(){
    //Return number of functions to
    // process.  Must not exceed 5.
    return 5;
  }//end getNmbr

  public double f1(double x){
    return (x*x*x)/200.0;
  }//end f1

  public double f2(double x){
    return -(x*x*x)/200.0;
  }//end f2

  public double f3(double x){
    return (x*x)/200.0;
  }//end f3

  public double f4(double x){
    return 50*Math.cos(x/10.0);
  }//end f4

  public double f5(double x){
    return 100*Math.sin(x/20.0);
  }//end f5

}//end sample class junk</code>




</entry>
</row>
</tbody>


</tgroup>
</table>


	


	

</section>
<section id="h11007">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1244">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1000" type="">


		


			


				

<emphasis id="strong1250" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1020" list-type="bulleted">

					

<item id="li1141">
Module name: Java1468-Plotting Engineering and 
					Scientific Data using Java

</item>


					

<item id="li1142">
File: Java1468.htm

</item>


					

<item id="li1143">
Published: 04/17/02

</item>



				

</list>




<para id="p1245">
Baldwin shows you how write a generalized plotting program that can be used to plot engineering and scientific data produced by any object that implements a very simple interface.

</para>



				

</note>





	

<note id="note1001" type="">


		


			


				

<emphasis id="strong1251" effect="bold">
Disclaimers:

</emphasis>
<para id="p1246">
<emphasis id="strong1252" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>



				

<para id="p1247">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>



				

<para id="p1248">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>



				

<para id="p1249">
<emphasis id="strong1253" effect="bold">
Affiliation

</emphasis>
: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>




</note>



	

	




<para id="p1250">
-end- 

</para>







</section>
</content>




</document>